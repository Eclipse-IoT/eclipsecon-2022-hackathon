/*
 * Copyright (c) 2012 - 2019, Nordic Semiconductor ASA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form, except as embedded into a Nordic
 *    Semiconductor ASA integrated circuit in a product or a software update for
 *    such product, must reproduce the above copyright notice, this list of
 *    conditions and the following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * 4. This software, with or without modification, must only be used with a
 *    Nordic Semiconductor ASA integrated circuit.
 *
 * 5. Any software provided in binary form under this license must not be reverse
 *    engineered, decompiled, modified and/or disassembled.
 *
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#![allow(
    clippy::fn_to_numeric_cast,
    clippy::missing_safety_doc,
    clippy::redundant_static_lifetimes,
    clippy::useless_transmute
)]

pub type c_schar = i8;
pub type c_uchar = u8;
pub type c_char = u8;

pub type c_short = i16;
pub type c_ushort = u16;

pub type c_int = i32;
pub type c_uint = u32;

pub type c_long = i32;
pub type c_ulong = u32;

pub type c_longlong = i64;
pub type c_ulonglong = u64;

pub type c_void = core::ffi::c_void;

trait ToAsm {
    fn to_asm(self) -> u32;
}

fn to_asm<T: ToAsm>(t: T) -> u32 {
    t.to_asm()
}

impl ToAsm for u32 {
    fn to_asm(self) -> u32 {
        self
    }
}

impl ToAsm for u16 {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl ToAsm for u8 {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl ToAsm for i8 {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<T> ToAsm for *const T {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<T> ToAsm for *mut T {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<T: ToAsm> ToAsm for Option<T> {
    fn to_asm(self) -> u32 {
        match self {
            Some(x) => x.to_asm(),
            None => 0,
        }
    }
}

impl<X, R> ToAsm for unsafe extern "C" fn(X) -> R {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<X, Y, R> ToAsm for unsafe extern "C" fn(X, Y) -> R {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<X, Y, Z, R> ToAsm for unsafe extern "C" fn(X, Y, Z) -> R {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const NRF_ERROR_BASE_NUM: u32 = 0;
pub const NRF_ERROR_SDM_BASE_NUM: u32 = 4096;
pub const NRF_ERROR_SOC_BASE_NUM: u32 = 8192;
pub const NRF_ERROR_STK_BASE_NUM: u32 = 12288;
pub const NRF_SUCCESS: u32 = 0;
pub const NRF_ERROR_SVC_HANDLER_MISSING: u32 = 1;
pub const NRF_ERROR_SOFTDEVICE_NOT_ENABLED: u32 = 2;
pub const NRF_ERROR_INTERNAL: u32 = 3;
pub const NRF_ERROR_NO_MEM: u32 = 4;
pub const NRF_ERROR_NOT_FOUND: u32 = 5;
pub const NRF_ERROR_NOT_SUPPORTED: u32 = 6;
pub const NRF_ERROR_INVALID_PARAM: u32 = 7;
pub const NRF_ERROR_INVALID_STATE: u32 = 8;
pub const NRF_ERROR_INVALID_LENGTH: u32 = 9;
pub const NRF_ERROR_INVALID_FLAGS: u32 = 10;
pub const NRF_ERROR_INVALID_DATA: u32 = 11;
pub const NRF_ERROR_DATA_SIZE: u32 = 12;
pub const NRF_ERROR_TIMEOUT: u32 = 13;
pub const NRF_ERROR_NULL: u32 = 14;
pub const NRF_ERROR_FORBIDDEN: u32 = 15;
pub const NRF_ERROR_INVALID_ADDR: u32 = 16;
pub const NRF_ERROR_BUSY: u32 = 17;
pub const NRF_ERROR_CONN_COUNT: u32 = 18;
pub const NRF_ERROR_RESOURCES: u32 = 19;
pub const BLE_ERROR_NOT_ENABLED: u32 = 12289;
pub const BLE_ERROR_INVALID_CONN_HANDLE: u32 = 12290;
pub const BLE_ERROR_INVALID_ATTR_HANDLE: u32 = 12291;
pub const BLE_ERROR_INVALID_ADV_HANDLE: u32 = 12292;
pub const BLE_ERROR_INVALID_ROLE: u32 = 12293;
pub const BLE_ERROR_BLOCKED_BY_OTHER_LINKS: u32 = 12294;
pub const NRF_L2CAP_ERR_BASE: u32 = 12544;
pub const NRF_GAP_ERR_BASE: u32 = 12800;
pub const NRF_GATTC_ERR_BASE: u32 = 13056;
pub const NRF_GATTS_ERR_BASE: u32 = 13312;
pub const BLE_HCI_STATUS_CODE_SUCCESS: u32 = 0;
pub const BLE_HCI_STATUS_CODE_UNKNOWN_BTLE_COMMAND: u32 = 1;
pub const BLE_HCI_STATUS_CODE_UNKNOWN_CONNECTION_IDENTIFIER: u32 = 2;
pub const BLE_HCI_AUTHENTICATION_FAILURE: u32 = 5;
pub const BLE_HCI_STATUS_CODE_PIN_OR_KEY_MISSING: u32 = 6;
pub const BLE_HCI_MEMORY_CAPACITY_EXCEEDED: u32 = 7;
pub const BLE_HCI_CONNECTION_TIMEOUT: u32 = 8;
pub const BLE_HCI_STATUS_CODE_COMMAND_DISALLOWED: u32 = 12;
pub const BLE_HCI_STATUS_CODE_INVALID_BTLE_COMMAND_PARAMETERS: u32 = 18;
pub const BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION: u32 = 19;
pub const BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_LOW_RESOURCES: u32 = 20;
pub const BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_POWER_OFF: u32 = 21;
pub const BLE_HCI_LOCAL_HOST_TERMINATED_CONNECTION: u32 = 22;
pub const BLE_HCI_UNSUPPORTED_REMOTE_FEATURE: u32 = 26;
pub const BLE_HCI_STATUS_CODE_INVALID_LMP_PARAMETERS: u32 = 30;
pub const BLE_HCI_STATUS_CODE_UNSPECIFIED_ERROR: u32 = 31;
pub const BLE_HCI_STATUS_CODE_LMP_RESPONSE_TIMEOUT: u32 = 34;
pub const BLE_HCI_STATUS_CODE_LMP_ERROR_TRANSACTION_COLLISION: u32 = 35;
pub const BLE_HCI_STATUS_CODE_LMP_PDU_NOT_ALLOWED: u32 = 36;
pub const BLE_HCI_INSTANT_PASSED: u32 = 40;
pub const BLE_HCI_PAIRING_WITH_UNIT_KEY_UNSUPPORTED: u32 = 41;
pub const BLE_HCI_DIFFERENT_TRANSACTION_COLLISION: u32 = 42;
pub const BLE_HCI_PARAMETER_OUT_OF_MANDATORY_RANGE: u32 = 48;
pub const BLE_HCI_CONTROLLER_BUSY: u32 = 58;
pub const BLE_HCI_CONN_INTERVAL_UNACCEPTABLE: u32 = 59;
pub const BLE_HCI_DIRECTED_ADVERTISER_TIMEOUT: u32 = 60;
pub const BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE: u32 = 61;
pub const BLE_HCI_CONN_FAILED_TO_BE_ESTABLISHED: u32 = 62;
pub const BLE_SVC_BASE: u32 = 96;
pub const BLE_SVC_LAST: u32 = 107;
pub const BLE_GAP_SVC_BASE: u32 = 108;
pub const BLE_GAP_SVC_LAST: u32 = 154;
pub const BLE_GATTC_SVC_BASE: u32 = 155;
pub const BLE_GATTC_SVC_LAST: u32 = 167;
pub const BLE_GATTS_SVC_BASE: u32 = 168;
pub const BLE_GATTS_SVC_LAST: u32 = 183;
pub const BLE_L2CAP_SVC_BASE: u32 = 184;
pub const BLE_L2CAP_SVC_LAST: u32 = 191;
pub const BLE_EVT_INVALID: u32 = 0;
pub const BLE_EVT_BASE: u32 = 1;
pub const BLE_EVT_LAST: u32 = 15;
pub const BLE_GAP_EVT_BASE: u32 = 16;
pub const BLE_GAP_EVT_LAST: u32 = 47;
pub const BLE_GATTC_EVT_BASE: u32 = 48;
pub const BLE_GATTC_EVT_LAST: u32 = 79;
pub const BLE_GATTS_EVT_BASE: u32 = 80;
pub const BLE_GATTS_EVT_LAST: u32 = 111;
pub const BLE_L2CAP_EVT_BASE: u32 = 112;
pub const BLE_L2CAP_EVT_LAST: u32 = 143;
pub const BLE_OPT_INVALID: u32 = 0;
pub const BLE_OPT_BASE: u32 = 1;
pub const BLE_OPT_LAST: u32 = 31;
pub const BLE_GAP_OPT_BASE: u32 = 32;
pub const BLE_GAP_OPT_LAST: u32 = 63;
pub const BLE_GATT_OPT_BASE: u32 = 64;
pub const BLE_GATT_OPT_LAST: u32 = 95;
pub const BLE_GATTC_OPT_BASE: u32 = 96;
pub const BLE_GATTC_OPT_LAST: u32 = 127;
pub const BLE_GATTS_OPT_BASE: u32 = 128;
pub const BLE_GATTS_OPT_LAST: u32 = 159;
pub const BLE_L2CAP_OPT_BASE: u32 = 160;
pub const BLE_L2CAP_OPT_LAST: u32 = 191;
pub const BLE_CFG_INVALID: u32 = 0;
pub const BLE_CFG_BASE: u32 = 1;
pub const BLE_CFG_LAST: u32 = 31;
pub const BLE_CONN_CFG_BASE: u32 = 32;
pub const BLE_CONN_CFG_LAST: u32 = 63;
pub const BLE_GAP_CFG_BASE: u32 = 64;
pub const BLE_GAP_CFG_LAST: u32 = 95;
pub const BLE_GATT_CFG_BASE: u32 = 96;
pub const BLE_GATT_CFG_LAST: u32 = 127;
pub const BLE_GATTC_CFG_BASE: u32 = 128;
pub const BLE_GATTC_CFG_LAST: u32 = 159;
pub const BLE_GATTS_CFG_BASE: u32 = 160;
pub const BLE_GATTS_CFG_LAST: u32 = 191;
pub const BLE_L2CAP_CFG_BASE: u32 = 192;
pub const BLE_L2CAP_CFG_LAST: u32 = 223;
pub const BLE_CONN_HANDLE_INVALID: u32 = 65535;
pub const BLE_CONN_HANDLE_ALL: u32 = 65534;
pub const BLE_UUID_UNKNOWN: u32 = 0;
pub const BLE_UUID_SERVICE_PRIMARY: u32 = 10240;
pub const BLE_UUID_SERVICE_SECONDARY: u32 = 10241;
pub const BLE_UUID_SERVICE_INCLUDE: u32 = 10242;
pub const BLE_UUID_CHARACTERISTIC: u32 = 10243;
pub const BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP: u32 = 10496;
pub const BLE_UUID_DESCRIPTOR_CHAR_USER_DESC: u32 = 10497;
pub const BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG: u32 = 10498;
pub const BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG: u32 = 10499;
pub const BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT: u32 = 10500;
pub const BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT: u32 = 10501;
pub const BLE_UUID_GATT: u32 = 6145;
pub const BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED: u32 = 10757;
pub const BLE_UUID_GAP: u32 = 6144;
pub const BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME: u32 = 10752;
pub const BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE: u32 = 10753;
pub const BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR: u32 = 10755;
pub const BLE_UUID_GAP_CHARACTERISTIC_PPCP: u32 = 10756;
pub const BLE_UUID_GAP_CHARACTERISTIC_CAR: u32 = 10918;
pub const BLE_UUID_GAP_CHARACTERISTIC_RPA_ONLY: u32 = 10953;
pub const BLE_UUID_TYPE_UNKNOWN: u32 = 0;
pub const BLE_UUID_TYPE_BLE: u32 = 1;
pub const BLE_UUID_TYPE_VENDOR_BEGIN: u32 = 2;
pub const BLE_APPEARANCE_UNKNOWN: u32 = 0;
pub const BLE_APPEARANCE_GENERIC_PHONE: u32 = 64;
pub const BLE_APPEARANCE_GENERIC_COMPUTER: u32 = 128;
pub const BLE_APPEARANCE_GENERIC_WATCH: u32 = 192;
pub const BLE_APPEARANCE_WATCH_SPORTS_WATCH: u32 = 193;
pub const BLE_APPEARANCE_GENERIC_CLOCK: u32 = 256;
pub const BLE_APPEARANCE_GENERIC_DISPLAY: u32 = 320;
pub const BLE_APPEARANCE_GENERIC_REMOTE_CONTROL: u32 = 384;
pub const BLE_APPEARANCE_GENERIC_EYE_GLASSES: u32 = 448;
pub const BLE_APPEARANCE_GENERIC_TAG: u32 = 512;
pub const BLE_APPEARANCE_GENERIC_KEYRING: u32 = 576;
pub const BLE_APPEARANCE_GENERIC_MEDIA_PLAYER: u32 = 640;
pub const BLE_APPEARANCE_GENERIC_BARCODE_SCANNER: u32 = 704;
pub const BLE_APPEARANCE_GENERIC_THERMOMETER: u32 = 768;
pub const BLE_APPEARANCE_THERMOMETER_EAR: u32 = 769;
pub const BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR: u32 = 832;
pub const BLE_APPEARANCE_HEART_RATE_SENSOR_HEART_RATE_BELT: u32 = 833;
pub const BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE: u32 = 896;
pub const BLE_APPEARANCE_BLOOD_PRESSURE_ARM: u32 = 897;
pub const BLE_APPEARANCE_BLOOD_PRESSURE_WRIST: u32 = 898;
pub const BLE_APPEARANCE_GENERIC_HID: u32 = 960;
pub const BLE_APPEARANCE_HID_KEYBOARD: u32 = 961;
pub const BLE_APPEARANCE_HID_MOUSE: u32 = 962;
pub const BLE_APPEARANCE_HID_JOYSTICK: u32 = 963;
pub const BLE_APPEARANCE_HID_GAMEPAD: u32 = 964;
pub const BLE_APPEARANCE_HID_DIGITIZERSUBTYPE: u32 = 965;
pub const BLE_APPEARANCE_HID_CARD_READER: u32 = 966;
pub const BLE_APPEARANCE_HID_DIGITAL_PEN: u32 = 967;
pub const BLE_APPEARANCE_HID_BARCODE: u32 = 968;
pub const BLE_APPEARANCE_GENERIC_GLUCOSE_METER: u32 = 1024;
pub const BLE_APPEARANCE_GENERIC_RUNNING_WALKING_SENSOR: u32 = 1088;
pub const BLE_APPEARANCE_RUNNING_WALKING_SENSOR_IN_SHOE: u32 = 1089;
pub const BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_SHOE: u32 = 1090;
pub const BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_HIP: u32 = 1091;
pub const BLE_APPEARANCE_GENERIC_CYCLING: u32 = 1152;
pub const BLE_APPEARANCE_CYCLING_CYCLING_COMPUTER: u32 = 1153;
pub const BLE_APPEARANCE_CYCLING_SPEED_SENSOR: u32 = 1154;
pub const BLE_APPEARANCE_CYCLING_CADENCE_SENSOR: u32 = 1155;
pub const BLE_APPEARANCE_CYCLING_POWER_SENSOR: u32 = 1156;
pub const BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR: u32 = 1157;
pub const BLE_APPEARANCE_GENERIC_PULSE_OXIMETER: u32 = 3136;
pub const BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP: u32 = 3137;
pub const BLE_APPEARANCE_PULSE_OXIMETER_WRIST_WORN: u32 = 3138;
pub const BLE_APPEARANCE_GENERIC_WEIGHT_SCALE: u32 = 3200;
pub const BLE_APPEARANCE_GENERIC_OUTDOOR_SPORTS_ACT: u32 = 5184;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_DISP: u32 = 5185;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_DISP: u32 = 5186;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_POD: u32 = 5187;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_POD: u32 = 5188;
pub const BLE_ERROR_GAP_UUID_LIST_MISMATCH: u32 = 12800;
pub const BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST: u32 = 12801;
pub const BLE_ERROR_GAP_INVALID_BLE_ADDR: u32 = 12802;
pub const BLE_ERROR_GAP_WHITELIST_IN_USE: u32 = 12803;
pub const BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE: u32 = 12804;
pub const BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE: u32 = 12805;
pub const BLE_GAP_ROLE_INVALID: u32 = 0;
pub const BLE_GAP_ROLE_PERIPH: u32 = 1;
pub const BLE_GAP_ROLE_CENTRAL: u32 = 2;
pub const BLE_GAP_TIMEOUT_SRC_SCAN: u32 = 1;
pub const BLE_GAP_TIMEOUT_SRC_CONN: u32 = 2;
pub const BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD: u32 = 3;
pub const BLE_GAP_ADDR_TYPE_PUBLIC: u32 = 0;
pub const BLE_GAP_ADDR_TYPE_RANDOM_STATIC: u32 = 1;
pub const BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE: u32 = 2;
pub const BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE: u32 = 3;
pub const BLE_GAP_ADDR_TYPE_ANONYMOUS: u32 = 127;
pub const BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S: u32 = 900;
pub const BLE_GAP_MAX_PRIVATE_ADDR_CYCLE_INTERVAL_S: u32 = 41400;
pub const BLE_GAP_ADDR_LEN: u32 = 6;
pub const BLE_GAP_PRIVACY_MODE_OFF: u32 = 0;
pub const BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY: u32 = 1;
pub const BLE_GAP_PRIVACY_MODE_NETWORK_PRIVACY: u32 = 2;
pub const BLE_GAP_POWER_LEVEL_INVALID: u32 = 127;
pub const BLE_GAP_ADV_SET_HANDLE_NOT_SET: u32 = 255;
pub const BLE_GAP_ADV_SET_COUNT_DEFAULT: u32 = 1;
pub const BLE_GAP_ADV_SET_COUNT_MAX: u32 = 1;
pub const BLE_GAP_ADV_SET_DATA_SIZE_MAX: u32 = 31;
pub const BLE_GAP_ADV_SET_DATA_SIZE_EXTENDED_MAX_SUPPORTED: u32 = 255;
pub const BLE_GAP_ADV_SET_DATA_SIZE_EXTENDED_CONNECTABLE_MAX_SUPPORTED: u32 = 238;
pub const BLE_GAP_ADV_REPORT_SET_ID_NOT_AVAILABLE: u32 = 255;
pub const BLE_GAP_EVT_ADV_SET_TERMINATED_REASON_TIMEOUT: u32 = 1;
pub const BLE_GAP_EVT_ADV_SET_TERMINATED_REASON_LIMIT_REACHED: u32 = 2;
pub const BLE_GAP_AD_TYPE_FLAGS: u32 = 1;
pub const BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE: u32 = 2;
pub const BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE: u32 = 3;
pub const BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE: u32 = 4;
pub const BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE: u32 = 5;
pub const BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE: u32 = 6;
pub const BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE: u32 = 7;
pub const BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME: u32 = 8;
pub const BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME: u32 = 9;
pub const BLE_GAP_AD_TYPE_TX_POWER_LEVEL: u32 = 10;
pub const BLE_GAP_AD_TYPE_CLASS_OF_DEVICE: u32 = 13;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C: u32 = 14;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R: u32 = 15;
pub const BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE: u32 = 16;
pub const BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS: u32 = 17;
pub const BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE: u32 = 18;
pub const BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT: u32 = 20;
pub const BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT: u32 = 21;
pub const BLE_GAP_AD_TYPE_SERVICE_DATA: u32 = 22;
pub const BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS: u32 = 23;
pub const BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS: u32 = 24;
pub const BLE_GAP_AD_TYPE_APPEARANCE: u32 = 25;
pub const BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL: u32 = 26;
pub const BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS: u32 = 27;
pub const BLE_GAP_AD_TYPE_LE_ROLE: u32 = 28;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256: u32 = 29;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256: u32 = 30;
pub const BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID: u32 = 32;
pub const BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID: u32 = 33;
pub const BLE_GAP_AD_TYPE_LESC_CONFIRMATION_VALUE: u32 = 34;
pub const BLE_GAP_AD_TYPE_LESC_RANDOM_VALUE: u32 = 35;
pub const BLE_GAP_AD_TYPE_URI: u32 = 36;
pub const BLE_GAP_AD_TYPE_3D_INFORMATION_DATA: u32 = 61;
pub const BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA: u32 = 255;
pub const BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE: u32 = 1;
pub const BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE: u32 = 2;
pub const BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED: u32 = 4;
pub const BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER: u32 = 8;
pub const BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST: u32 = 16;
pub const BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE: u32 = 5;
pub const BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE: u32 = 6;
pub const BLE_GAP_ADV_INTERVAL_MIN: u32 = 32;
pub const BLE_GAP_ADV_INTERVAL_MAX: u32 = 16384;
pub const BLE_GAP_SCAN_INTERVAL_MIN: u32 = 4;
pub const BLE_GAP_SCAN_INTERVAL_MAX: u32 = 65535;
pub const BLE_GAP_SCAN_WINDOW_MIN: u32 = 4;
pub const BLE_GAP_SCAN_WINDOW_MAX: u32 = 65535;
pub const BLE_GAP_SCAN_TIMEOUT_MIN: u32 = 1;
pub const BLE_GAP_SCAN_TIMEOUT_UNLIMITED: u32 = 0;
pub const BLE_GAP_SCAN_BUFFER_MIN: u32 = 31;
pub const BLE_GAP_SCAN_BUFFER_MAX: u32 = 31;
pub const BLE_GAP_SCAN_BUFFER_EXTENDED_MIN: u32 = 255;
pub const BLE_GAP_SCAN_BUFFER_EXTENDED_MAX: u32 = 1650;
pub const BLE_GAP_SCAN_BUFFER_EXTENDED_MAX_SUPPORTED: u32 = 255;
pub const BLE_GAP_ADV_TYPE_CONNECTABLE_SCANNABLE_UNDIRECTED: u32 = 1;
pub const BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE: u32 = 2;
pub const BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED: u32 = 3;
pub const BLE_GAP_ADV_TYPE_NONCONNECTABLE_SCANNABLE_UNDIRECTED: u32 = 4;
pub const BLE_GAP_ADV_TYPE_NONCONNECTABLE_NONSCANNABLE_UNDIRECTED: u32 = 5;
pub const BLE_GAP_ADV_TYPE_EXTENDED_CONNECTABLE_NONSCANNABLE_UNDIRECTED: u32 = 6;
pub const BLE_GAP_ADV_TYPE_EXTENDED_CONNECTABLE_NONSCANNABLE_DIRECTED: u32 = 7;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_SCANNABLE_UNDIRECTED: u32 = 8;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_SCANNABLE_DIRECTED: u32 = 9;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_UNDIRECTED: u32 = 10;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_DIRECTED: u32 = 11;
pub const BLE_GAP_ADV_FP_ANY: u32 = 0;
pub const BLE_GAP_ADV_FP_FILTER_SCANREQ: u32 = 1;
pub const BLE_GAP_ADV_FP_FILTER_CONNREQ: u32 = 2;
pub const BLE_GAP_ADV_FP_FILTER_BOTH: u32 = 3;
pub const BLE_GAP_ADV_DATA_STATUS_COMPLETE: u32 = 0;
pub const BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA: u32 = 1;
pub const BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_TRUNCATED: u32 = 2;
pub const BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MISSED: u32 = 3;
pub const BLE_GAP_SCAN_FP_ACCEPT_ALL: u32 = 0;
pub const BLE_GAP_SCAN_FP_WHITELIST: u32 = 1;
pub const BLE_GAP_SCAN_FP_ALL_NOT_RESOLVED_DIRECTED: u32 = 2;
pub const BLE_GAP_SCAN_FP_WHITELIST_NOT_RESOLVED_DIRECTED: u32 = 3;
pub const BLE_GAP_ADV_TIMEOUT_HIGH_DUTY_MAX: u32 = 128;
pub const BLE_GAP_ADV_TIMEOUT_LIMITED_MAX: u32 = 18000;
pub const BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED: u32 = 0;
pub const BLE_GAP_DISC_MODE_NOT_DISCOVERABLE: u32 = 0;
pub const BLE_GAP_DISC_MODE_LIMITED: u32 = 1;
pub const BLE_GAP_DISC_MODE_GENERAL: u32 = 2;
pub const BLE_GAP_IO_CAPS_DISPLAY_ONLY: u32 = 0;
pub const BLE_GAP_IO_CAPS_DISPLAY_YESNO: u32 = 1;
pub const BLE_GAP_IO_CAPS_KEYBOARD_ONLY: u32 = 2;
pub const BLE_GAP_IO_CAPS_NONE: u32 = 3;
pub const BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY: u32 = 4;
pub const BLE_GAP_AUTH_KEY_TYPE_NONE: u32 = 0;
pub const BLE_GAP_AUTH_KEY_TYPE_PASSKEY: u32 = 1;
pub const BLE_GAP_AUTH_KEY_TYPE_OOB: u32 = 2;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_START: u32 = 0;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_IN: u32 = 1;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_OUT: u32 = 2;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_CLEAR: u32 = 3;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_END: u32 = 4;
pub const BLE_GAP_SEC_STATUS_SUCCESS: u32 = 0;
pub const BLE_GAP_SEC_STATUS_TIMEOUT: u32 = 1;
pub const BLE_GAP_SEC_STATUS_PDU_INVALID: u32 = 2;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE1_BEGIN: u32 = 3;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE1_END: u32 = 128;
pub const BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED: u32 = 129;
pub const BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE: u32 = 130;
pub const BLE_GAP_SEC_STATUS_AUTH_REQ: u32 = 131;
pub const BLE_GAP_SEC_STATUS_CONFIRM_VALUE: u32 = 132;
pub const BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP: u32 = 133;
pub const BLE_GAP_SEC_STATUS_ENC_KEY_SIZE: u32 = 134;
pub const BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED: u32 = 135;
pub const BLE_GAP_SEC_STATUS_UNSPECIFIED: u32 = 136;
pub const BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS: u32 = 137;
pub const BLE_GAP_SEC_STATUS_INVALID_PARAMS: u32 = 138;
pub const BLE_GAP_SEC_STATUS_DHKEY_FAILURE: u32 = 139;
pub const BLE_GAP_SEC_STATUS_NUM_COMP_FAILURE: u32 = 140;
pub const BLE_GAP_SEC_STATUS_BR_EDR_IN_PROG: u32 = 141;
pub const BLE_GAP_SEC_STATUS_X_TRANS_KEY_DISALLOWED: u32 = 142;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE2_BEGIN: u32 = 143;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE2_END: u32 = 255;
pub const BLE_GAP_SEC_STATUS_SOURCE_LOCAL: u32 = 0;
pub const BLE_GAP_SEC_STATUS_SOURCE_REMOTE: u32 = 1;
pub const BLE_GAP_CP_MIN_CONN_INTVL_NONE: u32 = 65535;
pub const BLE_GAP_CP_MIN_CONN_INTVL_MIN: u32 = 6;
pub const BLE_GAP_CP_MIN_CONN_INTVL_MAX: u32 = 3200;
pub const BLE_GAP_CP_MAX_CONN_INTVL_NONE: u32 = 65535;
pub const BLE_GAP_CP_MAX_CONN_INTVL_MIN: u32 = 6;
pub const BLE_GAP_CP_MAX_CONN_INTVL_MAX: u32 = 3200;
pub const BLE_GAP_CP_SLAVE_LATENCY_MAX: u32 = 499;
pub const BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE: u32 = 65535;
pub const BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN: u32 = 10;
pub const BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX: u32 = 3200;
pub const BLE_GAP_DEVNAME_DEFAULT: &'static [u8; 6usize] = b"nRF5x\0";
pub const BLE_GAP_DEVNAME_DEFAULT_LEN: u32 = 31;
pub const BLE_GAP_DEVNAME_MAX_LEN: u32 = 248;
pub const BLE_GAP_RSSI_THRESHOLD_INVALID: u32 = 255;
pub const BLE_GAP_PHY_AUTO: u32 = 0;
pub const BLE_GAP_PHY_1MBPS: u32 = 1;
pub const BLE_GAP_PHY_2MBPS: u32 = 2;
pub const BLE_GAP_PHY_CODED: u32 = 4;
pub const BLE_GAP_PHY_NOT_SET: u32 = 255;
pub const BLE_GAP_PHYS_SUPPORTED: u32 = 7;
pub const BLE_GAP_SEC_RAND_LEN: u32 = 8;
pub const BLE_GAP_SEC_KEY_LEN: u32 = 16;
pub const BLE_GAP_LESC_P256_PK_LEN: u32 = 64;
pub const BLE_GAP_LESC_DHKEY_LEN: u32 = 32;
pub const BLE_GAP_PASSKEY_LEN: u32 = 6;
pub const BLE_GAP_WHITELIST_ADDR_MAX_COUNT: u32 = 8;
pub const BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT: u32 = 8;
pub const BLE_GAP_CONN_COUNT_DEFAULT: u32 = 1;
pub const BLE_GAP_EVENT_LENGTH_MIN: u32 = 2;
pub const BLE_GAP_EVENT_LENGTH_CODED_PHY_MIN: u32 = 6;
pub const BLE_GAP_EVENT_LENGTH_DEFAULT: u32 = 3;
pub const BLE_GAP_ROLE_COUNT_PERIPH_DEFAULT: u32 = 1;
pub const BLE_GAP_ROLE_COUNT_CENTRAL_DEFAULT: u32 = 3;
pub const BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT: u32 = 1;
pub const BLE_GAP_ROLE_COUNT_COMBINED_MAX: u32 = 20;
pub const BLE_GAP_DATA_LENGTH_AUTO: u32 = 0;
pub const BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MAX: u32 = 48000;
pub const BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MIN: u32 = 1;
pub const BLE_GAP_SEC_MODE: u32 = 0;
pub const BLE_GAP_CHANNEL_COUNT: u32 = 40;
pub const BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_CONTINUOUS: u32 = 0;
pub const BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_MIN_US: u32 = 7500;
pub const BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_MAX_US: u32 = 4000000;
pub const BLE_GAP_CHAR_INCL_CONFIG_INCLUDE: u32 = 0;
pub const BLE_GAP_CHAR_INCL_CONFIG_EXCLUDE_WITH_SPACE: u32 = 1;
pub const BLE_GAP_CHAR_INCL_CONFIG_EXCLUDE_WITHOUT_SPACE: u32 = 2;
pub const BLE_GAP_PPCP_INCL_CONFIG_DEFAULT: u32 = 0;
pub const BLE_GAP_CAR_INCL_CONFIG_DEFAULT: u32 = 0;
pub const BLE_L2CAP_CH_COUNT_MAX: u32 = 64;
pub const BLE_L2CAP_MTU_MIN: u32 = 23;
pub const BLE_L2CAP_MPS_MIN: u32 = 23;
pub const BLE_L2CAP_CID_INVALID: u32 = 0;
pub const BLE_L2CAP_CREDITS_DEFAULT: u32 = 1;
pub const BLE_L2CAP_CH_SETUP_REFUSED_SRC_LOCAL: u32 = 1;
pub const BLE_L2CAP_CH_SETUP_REFUSED_SRC_REMOTE: u32 = 2;
pub const BLE_L2CAP_CH_STATUS_CODE_SUCCESS: u32 = 0;
pub const BLE_L2CAP_CH_STATUS_CODE_LE_PSM_NOT_SUPPORTED: u32 = 2;
pub const BLE_L2CAP_CH_STATUS_CODE_NO_RESOURCES: u32 = 4;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHENTICATION: u32 = 5;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHORIZATION: u32 = 6;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC_KEY_SIZE: u32 = 7;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC: u32 = 8;
pub const BLE_L2CAP_CH_STATUS_CODE_INVALID_SCID: u32 = 9;
pub const BLE_L2CAP_CH_STATUS_CODE_SCID_ALLOCATED: u32 = 10;
pub const BLE_L2CAP_CH_STATUS_CODE_UNACCEPTABLE_PARAMS: u32 = 11;
pub const BLE_L2CAP_CH_STATUS_CODE_NOT_UNDERSTOOD: u32 = 32768;
pub const BLE_L2CAP_CH_STATUS_CODE_TIMEOUT: u32 = 49152;
pub const BLE_GATT_ATT_MTU_DEFAULT: u32 = 23;
pub const BLE_GATT_HANDLE_INVALID: u32 = 0;
pub const BLE_GATT_HANDLE_START: u32 = 1;
pub const BLE_GATT_HANDLE_END: u32 = 65535;
pub const BLE_GATT_TIMEOUT_SRC_PROTOCOL: u32 = 0;
pub const BLE_GATT_OP_INVALID: u32 = 0;
pub const BLE_GATT_OP_WRITE_REQ: u32 = 1;
pub const BLE_GATT_OP_WRITE_CMD: u32 = 2;
pub const BLE_GATT_OP_SIGN_WRITE_CMD: u32 = 3;
pub const BLE_GATT_OP_PREP_WRITE_REQ: u32 = 4;
pub const BLE_GATT_OP_EXEC_WRITE_REQ: u32 = 5;
pub const BLE_GATT_EXEC_WRITE_FLAG_PREPARED_CANCEL: u32 = 0;
pub const BLE_GATT_EXEC_WRITE_FLAG_PREPARED_WRITE: u32 = 1;
pub const BLE_GATT_HVX_INVALID: u32 = 0;
pub const BLE_GATT_HVX_NOTIFICATION: u32 = 1;
pub const BLE_GATT_HVX_INDICATION: u32 = 2;
pub const BLE_GATT_STATUS_SUCCESS: u32 = 0;
pub const BLE_GATT_STATUS_UNKNOWN: u32 = 1;
pub const BLE_GATT_STATUS_ATTERR_INVALID: u32 = 256;
pub const BLE_GATT_STATUS_ATTERR_INVALID_HANDLE: u32 = 257;
pub const BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED: u32 = 258;
pub const BLE_GATT_STATUS_ATTERR_WRITE_NOT_PERMITTED: u32 = 259;
pub const BLE_GATT_STATUS_ATTERR_INVALID_PDU: u32 = 260;
pub const BLE_GATT_STATUS_ATTERR_INSUF_AUTHENTICATION: u32 = 261;
pub const BLE_GATT_STATUS_ATTERR_REQUEST_NOT_SUPPORTED: u32 = 262;
pub const BLE_GATT_STATUS_ATTERR_INVALID_OFFSET: u32 = 263;
pub const BLE_GATT_STATUS_ATTERR_INSUF_AUTHORIZATION: u32 = 264;
pub const BLE_GATT_STATUS_ATTERR_PREPARE_QUEUE_FULL: u32 = 265;
pub const BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_FOUND: u32 = 266;
pub const BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG: u32 = 267;
pub const BLE_GATT_STATUS_ATTERR_INSUF_ENC_KEY_SIZE: u32 = 268;
pub const BLE_GATT_STATUS_ATTERR_INVALID_ATT_VAL_LENGTH: u32 = 269;
pub const BLE_GATT_STATUS_ATTERR_UNLIKELY_ERROR: u32 = 270;
pub const BLE_GATT_STATUS_ATTERR_INSUF_ENCRYPTION: u32 = 271;
pub const BLE_GATT_STATUS_ATTERR_UNSUPPORTED_GROUP_TYPE: u32 = 272;
pub const BLE_GATT_STATUS_ATTERR_INSUF_RESOURCES: u32 = 273;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE1_BEGIN: u32 = 274;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE1_END: u32 = 383;
pub const BLE_GATT_STATUS_ATTERR_APP_BEGIN: u32 = 384;
pub const BLE_GATT_STATUS_ATTERR_APP_END: u32 = 415;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE2_BEGIN: u32 = 416;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE2_END: u32 = 479;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE3_BEGIN: u32 = 480;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE3_END: u32 = 508;
pub const BLE_GATT_STATUS_ATTERR_CPS_WRITE_REQ_REJECTED: u32 = 508;
pub const BLE_GATT_STATUS_ATTERR_CPS_CCCD_CONFIG_ERROR: u32 = 509;
pub const BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG: u32 = 510;
pub const BLE_GATT_STATUS_ATTERR_CPS_OUT_OF_RANGE: u32 = 511;
pub const BLE_GATT_CPF_FORMAT_RFU: u32 = 0;
pub const BLE_GATT_CPF_FORMAT_BOOLEAN: u32 = 1;
pub const BLE_GATT_CPF_FORMAT_2BIT: u32 = 2;
pub const BLE_GATT_CPF_FORMAT_NIBBLE: u32 = 3;
pub const BLE_GATT_CPF_FORMAT_UINT8: u32 = 4;
pub const BLE_GATT_CPF_FORMAT_UINT12: u32 = 5;
pub const BLE_GATT_CPF_FORMAT_UINT16: u32 = 6;
pub const BLE_GATT_CPF_FORMAT_UINT24: u32 = 7;
pub const BLE_GATT_CPF_FORMAT_UINT32: u32 = 8;
pub const BLE_GATT_CPF_FORMAT_UINT48: u32 = 9;
pub const BLE_GATT_CPF_FORMAT_UINT64: u32 = 10;
pub const BLE_GATT_CPF_FORMAT_UINT128: u32 = 11;
pub const BLE_GATT_CPF_FORMAT_SINT8: u32 = 12;
pub const BLE_GATT_CPF_FORMAT_SINT12: u32 = 13;
pub const BLE_GATT_CPF_FORMAT_SINT16: u32 = 14;
pub const BLE_GATT_CPF_FORMAT_SINT24: u32 = 15;
pub const BLE_GATT_CPF_FORMAT_SINT32: u32 = 16;
pub const BLE_GATT_CPF_FORMAT_SINT48: u32 = 17;
pub const BLE_GATT_CPF_FORMAT_SINT64: u32 = 18;
pub const BLE_GATT_CPF_FORMAT_SINT128: u32 = 19;
pub const BLE_GATT_CPF_FORMAT_FLOAT32: u32 = 20;
pub const BLE_GATT_CPF_FORMAT_FLOAT64: u32 = 21;
pub const BLE_GATT_CPF_FORMAT_SFLOAT: u32 = 22;
pub const BLE_GATT_CPF_FORMAT_FLOAT: u32 = 23;
pub const BLE_GATT_CPF_FORMAT_DUINT16: u32 = 24;
pub const BLE_GATT_CPF_FORMAT_UTF8S: u32 = 25;
pub const BLE_GATT_CPF_FORMAT_UTF16S: u32 = 26;
pub const BLE_GATT_CPF_FORMAT_STRUCT: u32 = 27;
pub const BLE_GATT_CPF_NAMESPACE_BTSIG: u32 = 1;
pub const BLE_GATT_CPF_NAMESPACE_DESCRIPTION_UNKNOWN: u32 = 0;
pub const BLE_ERROR_GATTC_PROC_NOT_PERMITTED: u32 = 13056;
pub const BLE_GATTC_ATTR_INFO_FORMAT_16BIT: u32 = 1;
pub const BLE_GATTC_ATTR_INFO_FORMAT_128BIT: u32 = 2;
pub const BLE_GATTC_WRITE_CMD_TX_QUEUE_SIZE_DEFAULT: u32 = 1;
pub const BLE_ERROR_GATTS_INVALID_ATTR_TYPE: u32 = 13312;
pub const BLE_ERROR_GATTS_SYS_ATTR_MISSING: u32 = 13313;
pub const BLE_GATTS_FIX_ATTR_LEN_MAX: u32 = 510;
pub const BLE_GATTS_VAR_ATTR_LEN_MAX: u32 = 512;
pub const BLE_GATTS_SRVC_TYPE_INVALID: u32 = 0;
pub const BLE_GATTS_SRVC_TYPE_PRIMARY: u32 = 1;
pub const BLE_GATTS_SRVC_TYPE_SECONDARY: u32 = 2;
pub const BLE_GATTS_ATTR_TYPE_INVALID: u32 = 0;
pub const BLE_GATTS_ATTR_TYPE_PRIM_SRVC_DECL: u32 = 1;
pub const BLE_GATTS_ATTR_TYPE_SEC_SRVC_DECL: u32 = 2;
pub const BLE_GATTS_ATTR_TYPE_INC_DECL: u32 = 3;
pub const BLE_GATTS_ATTR_TYPE_CHAR_DECL: u32 = 4;
pub const BLE_GATTS_ATTR_TYPE_CHAR_VAL: u32 = 5;
pub const BLE_GATTS_ATTR_TYPE_DESC: u32 = 6;
pub const BLE_GATTS_ATTR_TYPE_OTHER: u32 = 7;
pub const BLE_GATTS_OP_INVALID: u32 = 0;
pub const BLE_GATTS_OP_WRITE_REQ: u32 = 1;
pub const BLE_GATTS_OP_WRITE_CMD: u32 = 2;
pub const BLE_GATTS_OP_SIGN_WRITE_CMD: u32 = 3;
pub const BLE_GATTS_OP_PREP_WRITE_REQ: u32 = 4;
pub const BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL: u32 = 5;
pub const BLE_GATTS_OP_EXEC_WRITE_REQ_NOW: u32 = 6;
pub const BLE_GATTS_VLOC_INVALID: u32 = 0;
pub const BLE_GATTS_VLOC_STACK: u32 = 1;
pub const BLE_GATTS_VLOC_USER: u32 = 2;
pub const BLE_GATTS_AUTHORIZE_TYPE_INVALID: u32 = 0;
pub const BLE_GATTS_AUTHORIZE_TYPE_READ: u32 = 1;
pub const BLE_GATTS_AUTHORIZE_TYPE_WRITE: u32 = 2;
pub const BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS: u32 = 1;
pub const BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS: u32 = 2;
pub const BLE_GATTS_SERVICE_CHANGED_DEFAULT: u32 = 1;
pub const BLE_GATTS_ATTR_TAB_SIZE_MIN: u32 = 248;
pub const BLE_GATTS_ATTR_TAB_SIZE_DEFAULT: u32 = 1408;
pub const BLE_GATTS_HVN_TX_QUEUE_SIZE_DEFAULT: u32 = 1;
pub const BLE_EVT_PTR_ALIGNMENT: u32 = 4;
pub const BLE_USER_MEM_TYPE_INVALID: u32 = 0;
pub const BLE_USER_MEM_TYPE_GATTS_QUEUED_WRITES: u32 = 1;
pub const BLE_UUID_VS_COUNT_DEFAULT: u32 = 10;
pub const BLE_UUID_VS_COUNT_MAX: u32 = 254;
pub const BLE_CONN_CFG_TAG_DEFAULT: u32 = 0;
pub const NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN: u32 = 8192;
pub const NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE: u32 = 8193;
pub const NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED: u32 = 8194;
pub const NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN: u32 = 8195;
pub const NRF_ERROR_SOC_POWER_MODE_UNKNOWN: u32 = 8196;
pub const NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN: u32 = 8197;
pub const NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN: u32 = 8198;
pub const NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES: u32 = 8199;
pub const NRF_ERROR_SOC_PPI_INVALID_CHANNEL: u32 = 8200;
pub const NRF_ERROR_SOC_PPI_INVALID_GROUP: u32 = 8201;
pub const SOC_SVC_BASE: u32 = 32;
pub const SOC_SVC_BASE_NOT_AVAILABLE: u32 = 44;
pub const NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US: u32 = 62;
pub const NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US: u32 = 200;
pub const NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US: u32 = 20;
pub const NRF_RADIO_MIN_EXTENSION_MARGIN_US: u32 = 82;
pub const SOC_ECB_KEY_LENGTH: u32 = 16;
pub const SOC_ECB_CLEARTEXT_LENGTH: u32 = 16;
pub const SOC_ECB_CIPHERTEXT_LENGTH: u32 = 16;
pub const NRF_RADIO_LENGTH_MIN_US: u32 = 100;
pub const NRF_RADIO_LENGTH_MAX_US: u32 = 100000;
pub const NRF_RADIO_DISTANCE_MAX_US: u32 = 127999999;
pub const NRF_RADIO_EARLIEST_TIMEOUT_MAX_US: u32 = 127999999;
pub const NRF_RADIO_START_JITTER_US: u32 = 2;
pub const SD_TIMERS_USED: u32 = 1;
pub const SD_SWI_USED: u32 = 54;
pub const MBR_SVC_BASE: u32 = 24;
pub const MBR_PAGE_SIZE_IN_WORDS: u32 = 1024;
pub const MBR_SIZE: u32 = 4096;
pub const MBR_BOOTLOADER_ADDR: u32 = 4088;
pub const MBR_PARAM_PAGE_ADDR: u32 = 4092;
pub const NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN: u32 = 4096;
pub const NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION: u32 = 4097;
pub const NRF_ERROR_SDM_INCORRECT_CLENR0: u32 = 4098;
pub const SD_MAJOR_VERSION: u32 = 7;
pub const SD_MINOR_VERSION: u32 = 0;
pub const SD_BUGFIX_VERSION: u32 = 1;
pub const SD_VARIANT_ID: u32 = 140;
pub const SD_VERSION: u32 = 7000001;
pub const SDM_SVC_BASE: u32 = 16;
pub const SD_UNIQUE_STR_SIZE: u32 = 20;
pub const SDM_INFO_FIELD_INVALID: u32 = 0;
pub const SOFTDEVICE_INFO_STRUCT_OFFSET: u32 = 8192;
pub const SOFTDEVICE_INFO_STRUCT_ADDRESS: u32 = 12288;
pub const SD_INFO_STRUCT_SIZE_OFFSET: u32 = 8192;
pub const SD_SIZE_OFFSET: u32 = 8200;
pub const SD_FWID_OFFSET: u32 = 8204;
pub const SD_ID_OFFSET: u32 = 8208;
pub const SD_VERSION_OFFSET: u32 = 8212;
pub const SD_UNIQUE_STR_OFFSET: u32 = 8216;
pub const SD_FLASH_SIZE: u32 = 155648;
pub const NRF_FAULT_ID_SD_RANGE_START: u32 = 0;
pub const NRF_FAULT_ID_APP_RANGE_START: u32 = 4096;
pub const NRF_FAULT_ID_SD_ASSERT: u32 = 1;
pub const NRF_FAULT_ID_APP_MEMACC: u32 = 4097;
pub const NRF_CLOCK_LF_ACCURACY_250_PPM: u32 = 0;
pub const NRF_CLOCK_LF_ACCURACY_500_PPM: u32 = 1;
pub const NRF_CLOCK_LF_ACCURACY_150_PPM: u32 = 2;
pub const NRF_CLOCK_LF_ACCURACY_100_PPM: u32 = 3;
pub const NRF_CLOCK_LF_ACCURACY_75_PPM: u32 = 4;
pub const NRF_CLOCK_LF_ACCURACY_50_PPM: u32 = 5;
pub const NRF_CLOCK_LF_ACCURACY_30_PPM: u32 = 6;
pub const NRF_CLOCK_LF_ACCURACY_20_PPM: u32 = 7;
pub const NRF_CLOCK_LF_ACCURACY_10_PPM: u32 = 8;
pub const NRF_CLOCK_LF_ACCURACY_5_PPM: u32 = 9;
pub const NRF_CLOCK_LF_ACCURACY_2_PPM: u32 = 10;
pub const NRF_CLOCK_LF_ACCURACY_1_PPM: u32 = 11;
pub const NRF_CLOCK_LF_SRC_RC: u32 = 0;
pub const NRF_CLOCK_LF_SRC_XTAL: u32 = 1;
pub const NRF_CLOCK_LF_SRC_SYNTH: u32 = 2;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = self::c_longlong;
pub type uintmax_t = self::c_ulonglong;
#[doc = " @brief 128 bit UUID values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid128_t {
    #[doc = "< Little-Endian UUID bytes."]
    pub uuid128: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ble_uuid128_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_uuid128_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_uuid128_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_uuid128_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_uuid128_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_uuid128_t>())).uuid128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_uuid128_t),
            "::",
            stringify!(uuid128)
        )
    );
}
#[doc = " @brief  Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid_t {
    #[doc = "< 16-bit UUID value or octets 12-13 of 128-bit UUID."]
    pub uuid: u16,
    #[doc = "< UUID type, see @ref BLE_UUID_TYPES. If type is @ref BLE_UUID_TYPE_UNKNOWN, the value of uuid is undefined."]
    pub type_: u8,
}
#[test]
fn bindgen_test_layout_ble_uuid_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_uuid_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_uuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_uuid_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_uuid_t>())).uuid as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_uuid_t), "::", stringify!(uuid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_uuid_t>())).type_ as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(ble_uuid_t), "::", stringify!(type_))
    );
}
#[doc = "@brief Data structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_data_t {
    #[doc = "< Pointer to the data buffer provided to/from the application."]
    pub p_data: *mut u8,
    #[doc = "< Length of the data buffer, in bytes."]
    pub len: u16,
}
#[test]
fn bindgen_test_layout_ble_data_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_data_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_data_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_data_t>())).p_data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_data_t), "::", stringify!(p_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_data_t>())).len as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ble_data_t), "::", stringify!(len))
    );
}
#[doc = "< Set own Bluetooth Address."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADDR_SET: BLE_GAP_SVCS = 108;
#[doc = "< Get own Bluetooth Address."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADDR_GET: BLE_GAP_SVCS = 109;
#[doc = "< Set active whitelist."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_WHITELIST_SET: BLE_GAP_SVCS = 110;
#[doc = "< Set device identity list."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DEVICE_IDENTITIES_SET: BLE_GAP_SVCS = 111;
#[doc = "< Set Privacy settings"]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PRIVACY_SET: BLE_GAP_SVCS = 112;
#[doc = "< Get Privacy settings"]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PRIVACY_GET: BLE_GAP_SVCS = 113;
#[doc = "< Configure an advertising set."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_SET_CONFIGURE: BLE_GAP_SVCS = 114;
#[doc = "< Start Advertising."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_START: BLE_GAP_SVCS = 115;
#[doc = "< Stop Advertising."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_STOP: BLE_GAP_SVCS = 116;
#[doc = "< Connection Parameter Update."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_PARAM_UPDATE: BLE_GAP_SVCS = 117;
#[doc = "< Disconnect."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DISCONNECT: BLE_GAP_SVCS = 118;
#[doc = "< Set TX Power."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_TX_POWER_SET: BLE_GAP_SVCS = 119;
#[doc = "< Set Appearance."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_APPEARANCE_SET: BLE_GAP_SVCS = 120;
#[doc = "< Get Appearance."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_APPEARANCE_GET: BLE_GAP_SVCS = 121;
#[doc = "< Set PPCP."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PPCP_SET: BLE_GAP_SVCS = 122;
#[doc = "< Get PPCP."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PPCP_GET: BLE_GAP_SVCS = 123;
#[doc = "< Set Device Name."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DEVICE_NAME_SET: BLE_GAP_SVCS = 124;
#[doc = "< Get Device Name."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DEVICE_NAME_GET: BLE_GAP_SVCS = 125;
#[doc = "< Initiate Pairing/Bonding."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_AUTHENTICATE: BLE_GAP_SVCS = 126;
#[doc = "< Reply with Security Parameters."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SEC_PARAMS_REPLY: BLE_GAP_SVCS = 127;
#[doc = "< Reply with an authentication key."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_AUTH_KEY_REPLY: BLE_GAP_SVCS = 128;
#[doc = "< Reply with an LE Secure Connections DHKey."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_LESC_DHKEY_REPLY: BLE_GAP_SVCS = 129;
#[doc = "< Notify of a keypress during an authentication procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_KEYPRESS_NOTIFY: BLE_GAP_SVCS = 130;
#[doc = "< Get the local LE Secure Connections OOB data."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_LESC_OOB_DATA_GET: BLE_GAP_SVCS = 131;
#[doc = "< Set the remote LE Secure Connections OOB data."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_LESC_OOB_DATA_SET: BLE_GAP_SVCS = 132;
#[doc = "< Initiate encryption procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ENCRYPT: BLE_GAP_SVCS = 133;
#[doc = "< Reply with Security Information."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SEC_INFO_REPLY: BLE_GAP_SVCS = 134;
#[doc = "< Obtain connection security level."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_SEC_GET: BLE_GAP_SVCS = 135;
#[doc = "< Start reporting of changes in RSSI."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_RSSI_START: BLE_GAP_SVCS = 136;
#[doc = "< Stop reporting of changes in RSSI."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_RSSI_STOP: BLE_GAP_SVCS = 137;
#[doc = "< Start Scanning."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SCAN_START: BLE_GAP_SVCS = 138;
#[doc = "< Stop Scanning."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SCAN_STOP: BLE_GAP_SVCS = 139;
#[doc = "< Connect."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONNECT: BLE_GAP_SVCS = 140;
#[doc = "< Cancel ongoing connection procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONNECT_CANCEL: BLE_GAP_SVCS = 141;
#[doc = "< Get the last RSSI sample."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_RSSI_GET: BLE_GAP_SVCS = 142;
#[doc = "< Initiate or respond to a PHY Update Procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PHY_UPDATE: BLE_GAP_SVCS = 143;
#[doc = "< Initiate or respond to a Data Length Update Procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DATA_LENGTH_UPDATE: BLE_GAP_SVCS = 144;
#[doc = "< Start Quality of Service (QoS) channel survey module."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_QOS_CHANNEL_SURVEY_START: BLE_GAP_SVCS = 145;
#[doc = "< Stop Quality of Service (QoS) channel survey module."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_QOS_CHANNEL_SURVEY_STOP: BLE_GAP_SVCS = 146;
#[doc = "< Get the Address used on air while Advertising."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_ADDR_GET: BLE_GAP_SVCS = 147;
#[doc = "< Get the next connection event counter."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_NEXT_CONN_EVT_COUNTER_GET: BLE_GAP_SVCS = 148;
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_EVT_TRIGGER_START: BLE_GAP_SVCS = 149;
#[doc = " Start triggering a given task on connection event start."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_EVT_TRIGGER_STOP: BLE_GAP_SVCS = 150;
#[doc = "@brief GAP API SVC numbers."]
pub type BLE_GAP_SVCS = self::c_uint;
#[doc = "< Connected to peer.                              \\n See @ref ble_gap_evt_connected_t"]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONNECTED: BLE_GAP_EVTS = 16;
#[doc = "< Disconnected from peer.                         \\n See @ref ble_gap_evt_disconnected_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_DISCONNECTED: BLE_GAP_EVTS = 17;
#[doc = "< Connection Parameters updated.                  \\n See @ref ble_gap_evt_conn_param_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONN_PARAM_UPDATE: BLE_GAP_EVTS = 18;
#[doc = "< Request to provide security parameters.         \\n Reply with @ref sd_ble_gap_sec_params_reply.  \\n See @ref ble_gap_evt_sec_params_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SEC_PARAMS_REQUEST: BLE_GAP_EVTS = 19;
#[doc = "< Request to provide security information.        \\n Reply with @ref sd_ble_gap_sec_info_reply.    \\n See @ref ble_gap_evt_sec_info_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SEC_INFO_REQUEST: BLE_GAP_EVTS = 20;
#[doc = "< Request to display a passkey to the user.       \\n In LESC Numeric Comparison, reply with @ref sd_ble_gap_auth_key_reply. \\n See @ref ble_gap_evt_passkey_display_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_PASSKEY_DISPLAY: BLE_GAP_EVTS = 21;
#[doc = "< Notification of a keypress on the remote device.\\n See @ref ble_gap_evt_key_pressed_t"]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_KEY_PRESSED: BLE_GAP_EVTS = 22;
#[doc = "< Request to provide an authentication key.       \\n Reply with @ref sd_ble_gap_auth_key_reply.    \\n See @ref ble_gap_evt_auth_key_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_AUTH_KEY_REQUEST: BLE_GAP_EVTS = 23;
#[doc = "< Request to calculate an LE Secure Connections DHKey. \\n Reply with @ref sd_ble_gap_lesc_dhkey_reply.  \\n See @ref ble_gap_evt_lesc_dhkey_request_t"]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_LESC_DHKEY_REQUEST: BLE_GAP_EVTS = 24;
#[doc = "< Authentication procedure completed with status. \\n See @ref ble_gap_evt_auth_status_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_AUTH_STATUS: BLE_GAP_EVTS = 25;
#[doc = "< Connection security updated.                    \\n See @ref ble_gap_evt_conn_sec_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONN_SEC_UPDATE: BLE_GAP_EVTS = 26;
#[doc = "< Timeout expired.                                \\n See @ref ble_gap_evt_timeout_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_TIMEOUT: BLE_GAP_EVTS = 27;
#[doc = "< RSSI report.                                    \\n See @ref ble_gap_evt_rssi_changed_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_RSSI_CHANGED: BLE_GAP_EVTS = 28;
#[doc = "< Advertising report.                             \\n See @ref ble_gap_evt_adv_report_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_ADV_REPORT: BLE_GAP_EVTS = 29;
#[doc = "< Security Request.                               \\n See @ref ble_gap_evt_sec_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SEC_REQUEST: BLE_GAP_EVTS = 30;
#[doc = "< Connection Parameter Update Request.            \\n Reply with @ref sd_ble_gap_conn_param_update. \\n See @ref ble_gap_evt_conn_param_update_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST: BLE_GAP_EVTS = 31;
#[doc = "< Scan request report.                            \\n See @ref ble_gap_evt_scan_req_report_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SCAN_REQ_REPORT: BLE_GAP_EVTS = 32;
#[doc = "< PHY Update Request.                             \\n Reply with @ref sd_ble_gap_phy_update. \\n See @ref ble_gap_evt_phy_update_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_PHY_UPDATE_REQUEST: BLE_GAP_EVTS = 33;
#[doc = "< PHY Update Procedure is complete.               \\n See @ref ble_gap_evt_phy_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_PHY_UPDATE: BLE_GAP_EVTS = 34;
#[doc = "< Data Length Update Request.                     \\n Reply with @ref sd_ble_gap_data_length_update. \\n See @ref ble_gap_evt_data_length_update_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST: BLE_GAP_EVTS = 35;
#[doc = "< LL Data Channel PDU payload length updated.     \\n See @ref ble_gap_evt_data_length_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_DATA_LENGTH_UPDATE: BLE_GAP_EVTS = 36;
#[doc = "< Channel survey report.                          \\n See @ref ble_gap_evt_qos_channel_survey_report_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT: BLE_GAP_EVTS = 37;
#[doc = "< Advertising set terminated.                     \\n See @ref ble_gap_evt_adv_set_terminated_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_ADV_SET_TERMINATED: BLE_GAP_EVTS = 38;
#[doc = "@brief GAP Event IDs."]
#[doc = " IDs that uniquely identify an event coming from the stack to the application."]
pub type BLE_GAP_EVTS = self::c_uint;
#[doc = "< Channel Map. @ref ble_gap_opt_ch_map_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_CH_MAP: BLE_GAP_OPTS = 32;
#[doc = "< Local connection latency. @ref ble_gap_opt_local_conn_latency_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_LOCAL_CONN_LATENCY: BLE_GAP_OPTS = 33;
#[doc = "< Set passkey. @ref ble_gap_opt_passkey_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_PASSKEY: BLE_GAP_OPTS = 34;
#[doc = "< Compatibility mode. @ref ble_gap_opt_compat_mode_1_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_COMPAT_MODE_1: BLE_GAP_OPTS = 35;
#[doc = "< Set Authenticated payload timeout. @ref ble_gap_opt_auth_payload_timeout_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT: BLE_GAP_OPTS = 36;
#[doc = "< Disable slave latency. @ref ble_gap_opt_slave_latency_disable_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_SLAVE_LATENCY_DISABLE: BLE_GAP_OPTS = 37;
#[doc = "@brief GAP Option IDs."]
#[doc = " IDs that uniquely identify a GAP option."]
pub type BLE_GAP_OPTS = self::c_uint;
#[doc = "< Role count configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_ROLE_COUNT: BLE_GAP_CFGS = 64;
#[doc = "< Device name configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_DEVICE_NAME: BLE_GAP_CFGS = 65;
#[doc = "< Peripheral Preferred Connection Parameters characteristic"]
#[doc = "inclusion configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_PPCP_INCL_CONFIG: BLE_GAP_CFGS = 66;
#[doc = "< Central Address Resolution characteristic"]
#[doc = "inclusion configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_CAR_INCL_CONFIG: BLE_GAP_CFGS = 67;
#[doc = "@brief GAP Configuration IDs."]
#[doc = ""]
#[doc = " IDs that uniquely identify a GAP configuration."]
pub type BLE_GAP_CFGS = self::c_uint;
#[doc = "< Advertiser role."]
pub const BLE_GAP_TX_POWER_ROLES_BLE_GAP_TX_POWER_ROLE_ADV: BLE_GAP_TX_POWER_ROLES = 1;
#[doc = "< Scanner and initiator role."]
pub const BLE_GAP_TX_POWER_ROLES_BLE_GAP_TX_POWER_ROLE_SCAN_INIT: BLE_GAP_TX_POWER_ROLES = 2;
#[doc = "< Connection role."]
pub const BLE_GAP_TX_POWER_ROLES_BLE_GAP_TX_POWER_ROLE_CONN: BLE_GAP_TX_POWER_ROLES = 3;
#[doc = "@brief GAP TX Power roles."]
pub type BLE_GAP_TX_POWER_ROLES = self::c_uint;
#[doc = "@brief Advertising event properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_properties_t {
    #[doc = "< Advertising type. See @ref BLE_GAP_ADV_TYPES."]
    pub type_: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_adv_properties_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_adv_properties_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gap_adv_properties_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_adv_properties_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_adv_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_properties_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_properties_t),
            "::",
            stringify!(type_)
        )
    );
}
impl ble_gap_adv_properties_t {
    #[inline]
    pub fn anonymous(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_anonymous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn include_tx_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_include_tx_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(anonymous: u8, include_tx_power: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let anonymous: u8 = unsafe { ::core::mem::transmute(anonymous) };
            anonymous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let include_tx_power: u8 = unsafe { ::core::mem::transmute(include_tx_power) };
            include_tx_power as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Advertising report type."]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_report_type_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_ble_gap_adv_report_type_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_adv_report_type_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gap_adv_report_type_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_adv_report_type_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_adv_report_type_t))
    );
}
impl ble_gap_adv_report_type_t {
    #[inline]
    pub fn connectable(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_connectable(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scannable(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scannable(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directed(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_directed(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_response(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scan_response(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_pdu(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_extended_pdu(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn status(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connectable: u16,
        scannable: u16,
        directed: u16,
        scan_response: u16,
        extended_pdu: u16,
        status: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connectable: u16 = unsafe { ::core::mem::transmute(connectable) };
            connectable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scannable: u16 = unsafe { ::core::mem::transmute(scannable) };
            scannable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let directed: u16 = unsafe { ::core::mem::transmute(directed) };
            directed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_response: u16 = unsafe { ::core::mem::transmute(scan_response) };
            scan_response as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let extended_pdu: u16 = unsafe { ::core::mem::transmute(extended_pdu) };
            extended_pdu as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let status: u16 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Advertising Auxiliary Pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_aux_pointer_t {
    #[doc = "< Time offset from the beginning of advertising packet to the auxiliary packet in 100 us units."]
    pub aux_offset: u16,
    #[doc = "< Indicates the PHY on which the auxiliary advertising packet is sent. See @ref BLE_GAP_PHYS."]
    pub aux_phy: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_aux_pointer_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_aux_pointer_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gap_aux_pointer_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_aux_pointer_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_aux_pointer_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_aux_pointer_t>())).aux_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_aux_pointer_t),
            "::",
            stringify!(aux_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_aux_pointer_t>())).aux_phy as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_aux_pointer_t),
            "::",
            stringify!(aux_phy)
        )
    );
}
#[doc = "@brief Bluetooth Low Energy address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_addr_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< 48-bit address, LSB format."]
    #[doc = "@ref addr is not used if @ref addr_type is @ref BLE_GAP_ADDR_TYPE_ANONYMOUS."]
    pub addr: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ble_gap_addr_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_addr_t>(),
        7usize,
        concat!("Size of: ", stringify!(ble_gap_addr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_addr_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_addr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_addr_t>())).addr as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(ble_gap_addr_t), "::", stringify!(addr))
    );
}
impl ble_gap_addr_t {
    #[inline]
    pub fn addr_id_peer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_addr_id_peer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn addr_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_addr_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(addr_id_peer: u8, addr_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let addr_id_peer: u8 = unsafe { ::core::mem::transmute(addr_id_peer) };
            addr_id_peer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let addr_type: u8 = unsafe { ::core::mem::transmute(addr_type) };
            addr_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP connection parameters."]
#[doc = ""]
#[doc = " @note  When ble_conn_params_t is received in an event, both min_conn_interval and"]
#[doc = "        max_conn_interval will be equal to the connection interval set by the central."]
#[doc = ""]
#[doc = " @note  If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:"]
#[doc = "        conn_sup_timeout * 4 > (1 + slave_latency) * max_conn_interval"]
#[doc = "        that corresponds to the following Bluetooth Spec requirement:"]
#[doc = "        The Supervision_Timeout in milliseconds shall be larger than"]
#[doc = "        (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_params_t {
    #[doc = "< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS."]
    pub min_conn_interval: u16,
    #[doc = "< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS."]
    pub max_conn_interval: u16,
    #[doc = "< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS."]
    pub slave_latency: u16,
    #[doc = "< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS."]
    pub conn_sup_timeout: u16,
}
#[test]
fn bindgen_test_layout_ble_gap_conn_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_conn_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_conn_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_conn_params_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_conn_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_params_t>())).min_conn_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_params_t),
            "::",
            stringify!(min_conn_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_params_t>())).max_conn_interval as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_params_t),
            "::",
            stringify!(max_conn_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_params_t>())).slave_latency as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_params_t),
            "::",
            stringify!(slave_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_params_t>())).conn_sup_timeout as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_params_t),
            "::",
            stringify!(conn_sup_timeout)
        )
    );
}
#[doc = "@brief GAP connection security modes."]
#[doc = ""]
#[doc = " Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).\\n"]
#[doc = " Security Mode 1 Level 1: No security is needed (aka open link).\\n"]
#[doc = " Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.\\n"]
#[doc = " Security Mode 1 Level 3: MITM protected encrypted link required.\\n"]
#[doc = " Security Mode 1 Level 4: LESC MITM protected encrypted link using a 128-bit strength encryption key required.\\n"]
#[doc = " Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.\\n"]
#[doc = " Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.\\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_sec_mode_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_conn_sec_mode_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_conn_sec_mode_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_conn_sec_mode_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_conn_sec_mode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_conn_sec_mode_t))
    );
}
impl ble_gap_conn_sec_mode_t {
    #[inline]
    pub fn sm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn lv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_lv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sm: u8, lv: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sm: u8 = unsafe { ::core::mem::transmute(sm) };
            sm as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let lv: u8 = unsafe { ::core::mem::transmute(lv) };
            lv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP connection security status."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_sec_t {
    #[doc = "< Currently active security mode for this connection."]
    pub sec_mode: ble_gap_conn_sec_mode_t,
    #[doc = "< Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures)."]
    pub encr_key_size: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_conn_sec_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_conn_sec_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gap_conn_sec_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_conn_sec_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_conn_sec_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_sec_t>())).sec_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_sec_t),
            "::",
            stringify!(sec_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_sec_t>())).encr_key_size as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_sec_t),
            "::",
            stringify!(encr_key_size)
        )
    );
}
#[doc = "@brief Identity Resolving Key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_irk_t {
    #[doc = "< Array containing IRK."]
    pub irk: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ble_gap_irk_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_irk_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_gap_irk_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_irk_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_irk_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_irk_t>())).irk as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_gap_irk_t), "::", stringify!(irk))
    );
}
#[doc = "@brief Channel mask (40 bits)."]
#[doc = " Every channel is represented with a bit positioned as per channel index defined in Bluetooth Core Specification v5.0,"]
#[doc = " Vol 6, Part B, Section 1.4.1. The LSB contained in array element 0 represents channel index 0, and bit 39 represents"]
#[doc = " channel index 39. If a bit is set to 1, the channel is not used."]
pub type ble_gap_ch_mask_t = [u8; 5usize];
#[doc = "@brief GAP advertising parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_params_t {
    #[doc = "< The properties of the advertising events."]
    pub properties: ble_gap_adv_properties_t,
    #[doc = "< Address of a known peer."]
    #[doc = "@note ble_gap_addr_t::addr_type cannot be"]
    #[doc = "@ref BLE_GAP_ADDR_TYPE_ANONYMOUS."]
    #[doc = "- When privacy is enabled and the local device uses"]
    #[doc = "@ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE addresses,"]
    #[doc = "the device identity list is searched for a matching entry. If"]
    #[doc = "the local IRK for that device identity is set, the local IRK"]
    #[doc = "for that device will be used to generate the advertiser address"]
    #[doc = "field in the advertising packet."]
    #[doc = "- If @ref ble_gap_adv_properties_t::type is directed, this must be"]
    #[doc = "set to the targeted scanner or initiator. If the peer address is"]
    #[doc = "in the device identity list, the peer IRK for that device will be"]
    #[doc = "used to generate @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE"]
    #[doc = "target addresses used in the advertising event PDUs."]
    pub p_peer_addr: *const ble_gap_addr_t,
    #[doc = "< Advertising interval in 625 us units. @sa BLE_GAP_ADV_INTERVALS."]
    #[doc = "@note If @ref ble_gap_adv_properties_t::type is set to"]
    #[doc = "@ref BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE"]
    #[doc = "advertising, this parameter is ignored."]
    pub interval: u32,
    #[doc = "< Advertising duration in 10 ms units. When timeout is reached,"]
    #[doc = "an event of type @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised."]
    #[doc = "@sa BLE_GAP_ADV_TIMEOUT_VALUES."]
    #[doc = "@note The SoftDevice will always complete at least one advertising"]
    #[doc = "event even if the duration is set too low."]
    pub duration: u16,
    #[doc = "< Maximum advertising events that shall be sent prior to disabling"]
    #[doc = "advertising. Setting the value to 0 disables the limitation. When"]
    #[doc = "the count of advertising events specified by this parameter"]
    #[doc = "(if not 0) is reached, advertising will be automatically stopped"]
    #[doc = "and an event of type @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised"]
    #[doc = "@note If @ref ble_gap_adv_properties_t::type is set to"]
    #[doc = "@ref BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE,"]
    #[doc = "this parameter is ignored."]
    pub max_adv_evts: u8,
    #[doc = "< Channel mask for primary and secondary advertising channels."]
    #[doc = "At least one of the primary channels, that is channel index 37-39, must be used."]
    #[doc = "Masking away secondary advertising channels is not supported."]
    pub channel_mask: ble_gap_ch_mask_t,
    #[doc = "< Filter Policy. @sa BLE_GAP_ADV_FILTER_POLICIES."]
    pub filter_policy: u8,
    #[doc = "< Indicates the PHY on which the primary advertising channel packets"]
    #[doc = "are transmitted. If set to @ref BLE_GAP_PHY_AUTO, @ref BLE_GAP_PHY_1MBPS"]
    #[doc = "will be used."]
    #[doc = "Valid values are @ref BLE_GAP_PHY_1MBPS and @ref BLE_GAP_PHY_CODED."]
    #[doc = "@note The primary_phy shall indicate @ref BLE_GAP_PHY_1MBPS if"]
    #[doc = "@ref ble_gap_adv_properties_t::type is not an extended advertising type."]
    pub primary_phy: u8,
    #[doc = "< Indicates the PHY on which the secondary advertising channel packets"]
    #[doc = "are transmitted."]
    #[doc = "If set to @ref BLE_GAP_PHY_AUTO, @ref BLE_GAP_PHY_1MBPS will be used."]
    #[doc = "Valid values are"]
    #[doc = "@ref BLE_GAP_PHY_1MBPS, @ref BLE_GAP_PHY_2MBPS, and @ref BLE_GAP_PHY_CODED."]
    #[doc = "If @ref ble_gap_adv_properties_t::type is an extended advertising type"]
    #[doc = "and connectable, this is the PHY that will be used to establish a"]
    #[doc = "connection and send AUX_ADV_IND packets on."]
    #[doc = "@note This parameter will be ignored when"]
    #[doc = "@ref ble_gap_adv_properties_t::type is not an extended advertising type."]
    pub secondary_phy: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_adv_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_adv_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(ble_gap_adv_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_adv_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_adv_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).properties as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).p_peer_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(p_peer_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).interval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).duration as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).max_adv_evts as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(max_adv_evts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).channel_mask as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(channel_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).filter_policy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(filter_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).primary_phy as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(primary_phy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_params_t>())).secondary_phy as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_params_t),
            "::",
            stringify!(secondary_phy)
        )
    );
}
impl ble_gap_adv_params_t {
    #[inline]
    pub fn set_id(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_set_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_req_notification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scan_req_notification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(set_id: u8, scan_req_notification: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let set_id: u8 = unsafe { ::core::mem::transmute(set_id) };
            set_id as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_req_notification: u8 = unsafe { ::core::mem::transmute(scan_req_notification) };
            scan_req_notification as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP advertising data buffers."]
#[doc = ""]
#[doc = " The application must provide the buffers for advertisement. The memory shall reside in application RAM, and"]
#[doc = " shall never be modified while advertising. The data shall be kept alive until either:"]
#[doc = "  - @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised."]
#[doc = "  - @ref BLE_GAP_EVT_CONNECTED is raised with @ref ble_gap_evt_connected_t::adv_handle set to the corresponding"]
#[doc = "    advertising handle."]
#[doc = "  - Advertising is stopped."]
#[doc = "  - Advertising data is changed."]
#[doc = " To update advertising data while advertising, provide new buffers to @ref sd_ble_gap_adv_set_configure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_data_t {
    #[doc = "< Advertising data."]
    #[doc = "@note"]
    #[doc = "Advertising data can only be specified for a @ref ble_gap_adv_properties_t::type"]
    #[doc = "that is allowed to contain advertising data."]
    pub adv_data: ble_data_t,
    #[doc = "< Scan response data."]
    #[doc = "@note"]
    #[doc = "Scan response data can only be specified for a @ref ble_gap_adv_properties_t::type"]
    #[doc = "that is scannable."]
    pub scan_rsp_data: ble_data_t,
}
#[test]
fn bindgen_test_layout_ble_gap_adv_data_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_adv_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_gap_adv_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_adv_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_adv_data_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_data_t>())).adv_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_data_t),
            "::",
            stringify!(adv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_adv_data_t>())).scan_rsp_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_adv_data_t),
            "::",
            stringify!(scan_rsp_data)
        )
    );
}
#[doc = "@brief GAP scanning parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_scan_params_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Bitfield of PHYs to scan on. If set to @ref BLE_GAP_PHY_AUTO,"]
    #[doc = "scan_phys will default to @ref BLE_GAP_PHY_1MBPS."]
    #[doc = "- If @ref ble_gap_scan_params_t::extended is set to 0, the only"]
    #[doc = "supported PHY is @ref BLE_GAP_PHY_1MBPS."]
    #[doc = "- When used with @ref sd_ble_gap_scan_start,"]
    #[doc = "the bitfield indicates the PHYs the scanner will use for scanning"]
    #[doc = "on primary advertising channels. The scanner will accept"]
    #[doc = "@ref BLE_GAP_PHYS_SUPPORTED as secondary advertising channel PHYs."]
    #[doc = "- When used with @ref sd_ble_gap_connect, the bitfield indicates"]
    #[doc = "the PHYs the initiator will use for scanning on primary advertising"]
    #[doc = "channels. The initiator will accept connections initiated on either"]
    #[doc = "of the @ref BLE_GAP_PHYS_SUPPORTED PHYs."]
    #[doc = "If scan_phys contains @ref BLE_GAP_PHY_1MBPS and/or @ref BLE_GAP_PHY_2MBPS,"]
    #[doc = "the primary scan PHY is @ref BLE_GAP_PHY_1MBPS."]
    #[doc = "If scan_phys also contains @ref BLE_GAP_PHY_CODED, the primary scan"]
    #[doc = "PHY will also contain @ref BLE_GAP_PHY_CODED. If the only scan PHY is"]
    #[doc = "@ref BLE_GAP_PHY_CODED, the primary scan PHY is"]
    #[doc = "@ref BLE_GAP_PHY_CODED only."]
    pub scan_phys: u8,
    #[doc = "< Scan interval in 625 us units. @sa BLE_GAP_SCAN_INTERVALS."]
    pub interval: u16,
    #[doc = "< Scan window in 625 us units. @sa BLE_GAP_SCAN_WINDOW."]
    #[doc = "If scan_phys contains both @ref BLE_GAP_PHY_1MBPS and"]
    #[doc = "@ref BLE_GAP_PHY_CODED interval shall be larger than or"]
    #[doc = "equal to twice the scan window."]
    pub window: u16,
    #[doc = "< Scan timeout in 10 ms units. @sa BLE_GAP_SCAN_TIMEOUT."]
    pub timeout: u16,
    #[doc = "< Channel mask for primary and secondary advertising channels."]
    #[doc = "At least one of the primary channels, that is channel index 37-39, must be"]
    #[doc = "set to 0."]
    #[doc = "Masking away secondary channels is not supported."]
    pub channel_mask: ble_gap_ch_mask_t,
}
#[test]
fn bindgen_test_layout_ble_gap_scan_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_scan_params_t>(),
        14usize,
        concat!("Size of: ", stringify!(ble_gap_scan_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_scan_params_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_scan_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_scan_params_t>())).scan_phys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_scan_params_t),
            "::",
            stringify!(scan_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_scan_params_t>())).interval as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_scan_params_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_scan_params_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_scan_params_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_scan_params_t>())).timeout as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_scan_params_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_scan_params_t>())).channel_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_scan_params_t),
            "::",
            stringify!(channel_mask)
        )
    );
}
impl ble_gap_scan_params_t {
    #[inline]
    pub fn extended(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn report_incomplete_evts(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_report_incomplete_evts(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_policy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_filter_policy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        extended: u8,
        report_incomplete_evts: u8,
        active: u8,
        filter_policy: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let extended: u8 = unsafe { ::core::mem::transmute(extended) };
            extended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let report_incomplete_evts: u8 = unsafe { ::core::mem::transmute(report_incomplete_evts) };
            report_incomplete_evts as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let filter_policy: u8 = unsafe { ::core::mem::transmute(filter_policy) };
            filter_policy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Privacy."]
#[doc = ""]
#[doc = "        The privacy feature provides a way for the device to avoid being tracked over a period of time."]
#[doc = "        The privacy feature, when enabled, hides the local device identity and replaces it with a private address"]
#[doc = "        that is automatically refreshed at a specified interval."]
#[doc = ""]
#[doc = "        If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK)."]
#[doc = "        With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,"]
#[doc = "        and devices can establish connections without revealing their real identities."]
#[doc = ""]
#[doc = "        Both network privacy (@ref BLE_GAP_PRIVACY_MODE_NETWORK_PRIVACY) and device privacy (@ref BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY)"]
#[doc = "        are supported."]
#[doc = ""]
#[doc = " @note  If the device IRK is updated, the new IRK becomes the one to be distributed in all"]
#[doc = "        bonding procedures performed after @ref sd_ble_gap_privacy_set returns."]
#[doc = "        The IRK distributed during bonding procedure is the device IRK that is active when @ref sd_ble_gap_sec_params_reply is called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_privacy_params_t {
    #[doc = "< Privacy mode, see @ref BLE_GAP_PRIVACY_MODES. Default is @ref BLE_GAP_PRIVACY_MODE_OFF."]
    pub privacy_mode: u8,
    #[doc = "< The private address type must be either @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE or @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE."]
    pub private_addr_type: u8,
    #[doc = "< Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by @ref BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S."]
    pub private_addr_cycle_s: u16,
    #[doc = "< When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used."]
    #[doc = "When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored."]
    #[doc = "By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise."]
    pub p_device_irk: *mut ble_gap_irk_t,
}
#[test]
fn bindgen_test_layout_ble_gap_privacy_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_privacy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_privacy_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_privacy_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_privacy_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_privacy_params_t>())).privacy_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_privacy_params_t),
            "::",
            stringify!(privacy_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_privacy_params_t>())).private_addr_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_privacy_params_t),
            "::",
            stringify!(private_addr_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_privacy_params_t>())).private_addr_cycle_s as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_privacy_params_t),
            "::",
            stringify!(private_addr_cycle_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_privacy_params_t>())).p_device_irk as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_privacy_params_t),
            "::",
            stringify!(p_device_irk)
        )
    );
}
#[doc = "@brief PHY preferences for TX and RX"]
#[doc = " @note  tx_phys and rx_phys are bit fields. Multiple bits can be set in them to indicate multiple preferred PHYs for each direction."]
#[doc = " @code"]
#[doc = " p_gap_phys->tx_phys = BLE_GAP_PHY_1MBPS | BLE_GAP_PHY_2MBPS;"]
#[doc = " p_gap_phys->rx_phys = BLE_GAP_PHY_1MBPS | BLE_GAP_PHY_2MBPS;"]
#[doc = " @endcode"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_phys_t {
    #[doc = "< Preferred transmit PHYs, see @ref BLE_GAP_PHYS."]
    pub tx_phys: u8,
    #[doc = "< Preferred receive PHYs, see @ref BLE_GAP_PHYS."]
    pub rx_phys: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_phys_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_phys_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gap_phys_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_phys_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_phys_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_phys_t>())).tx_phys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_phys_t),
            "::",
            stringify!(tx_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_phys_t>())).rx_phys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_phys_t),
            "::",
            stringify!(rx_phys)
        )
    );
}
#[doc = " @brief Keys that can be exchanged during a bonding procedure."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_kdist_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_sec_kdist_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_sec_kdist_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_sec_kdist_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_sec_kdist_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_sec_kdist_t))
    );
}
impl ble_gap_sec_kdist_t {
    #[inline]
    pub fn enc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn id(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enc: u8, id: u8, sign: u8, link: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enc: u8 = unsafe { ::core::mem::transmute(enc) };
            enc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let id: u8 = unsafe { ::core::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sign: u8 = unsafe { ::core::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let link: u8 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP security parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_params_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance."]
    pub min_key_size: u8,
    #[doc = "< Maximum encryption key size in octets between min_key_size and 16."]
    pub max_key_size: u8,
    #[doc = "< Key distribution bitmap: keys that the local device will distribute."]
    pub kdist_own: ble_gap_sec_kdist_t,
    #[doc = "< Key distribution bitmap: keys that the remote device will distribute."]
    pub kdist_peer: ble_gap_sec_kdist_t,
}
#[test]
fn bindgen_test_layout_ble_gap_sec_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_sec_params_t>(),
        5usize,
        concat!("Size of: ", stringify!(ble_gap_sec_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_sec_params_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_sec_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_params_t>())).min_key_size as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_params_t),
            "::",
            stringify!(min_key_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_params_t>())).max_key_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_params_t),
            "::",
            stringify!(max_key_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_params_t>())).kdist_own as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_params_t),
            "::",
            stringify!(kdist_own)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_params_t>())).kdist_peer as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_params_t),
            "::",
            stringify!(kdist_peer)
        )
    );
}
impl ble_gap_sec_params_t {
    #[inline]
    pub fn bond(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bond(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mitm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mitm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keypress(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keypress(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_caps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_io_caps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn oob(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oob(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bond: u8,
        mitm: u8,
        lesc: u8,
        keypress: u8,
        io_caps: u8,
        oob: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bond: u8 = unsafe { ::core::mem::transmute(bond) };
            bond as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mitm: u8 = unsafe { ::core::mem::transmute(mitm) };
            mitm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keypress: u8 = unsafe { ::core::mem::transmute(keypress) };
            keypress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let io_caps: u8 = unsafe { ::core::mem::transmute(io_caps) };
            io_caps as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let oob: u8 = unsafe { ::core::mem::transmute(oob) };
            oob as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP Encryption Information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_enc_info_t {
    #[doc = "< Long Term Key."]
    pub ltk: [u8; 16usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_enc_info_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_enc_info_t>(),
        17usize,
        concat!("Size of: ", stringify!(ble_gap_enc_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_enc_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_enc_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_enc_info_t>())).ltk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_enc_info_t),
            "::",
            stringify!(ltk)
        )
    );
}
impl ble_gap_enc_info_t {
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltk_len(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ltk_len(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lesc: u8, auth: u8, ltk_len: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let auth: u8 = unsafe { ::core::mem::transmute(auth) };
            auth as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let ltk_len: u8 = unsafe { ::core::mem::transmute(ltk_len) };
            ltk_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP Master Identification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_master_id_t {
    #[doc = "< Encrypted Diversifier."]
    pub ediv: u16,
    #[doc = "< Random Number."]
    pub rand: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_ble_gap_master_id_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_master_id_t>(),
        10usize,
        concat!("Size of: ", stringify!(ble_gap_master_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_master_id_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_master_id_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_master_id_t>())).ediv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_master_id_t),
            "::",
            stringify!(ediv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_master_id_t>())).rand as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_master_id_t),
            "::",
            stringify!(rand)
        )
    );
}
#[doc = "@brief GAP Signing Information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sign_info_t {
    #[doc = "< Connection Signature Resolving Key."]
    pub csrk: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ble_gap_sign_info_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_sign_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_gap_sign_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_sign_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_sign_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sign_info_t>())).csrk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sign_info_t),
            "::",
            stringify!(csrk)
        )
    );
}
#[doc = "@brief GAP LE Secure Connections P-256 Public Key."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gap_lesc_p256_pk_t {
    #[doc = "< LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian."]
    pub pk: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_ble_gap_lesc_p256_pk_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_lesc_p256_pk_t>(),
        64usize,
        concat!("Size of: ", stringify!(ble_gap_lesc_p256_pk_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_lesc_p256_pk_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_lesc_p256_pk_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_lesc_p256_pk_t>())).pk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_lesc_p256_pk_t),
            "::",
            stringify!(pk)
        )
    );
}
#[doc = "@brief GAP LE Secure Connections DHKey."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_lesc_dhkey_t {
    #[doc = "< LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian."]
    pub key: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_ble_gap_lesc_dhkey_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_lesc_dhkey_t>(),
        32usize,
        concat!("Size of: ", stringify!(ble_gap_lesc_dhkey_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_lesc_dhkey_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_lesc_dhkey_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_lesc_dhkey_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_lesc_dhkey_t),
            "::",
            stringify!(key)
        )
    );
}
#[doc = "@brief GAP LE Secure Connections OOB data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_lesc_oob_data_t {
    #[doc = "< Bluetooth address of the device."]
    pub addr: ble_gap_addr_t,
    #[doc = "< Random Number."]
    pub r: [u8; 16usize],
    #[doc = "< Confirm Value."]
    pub c: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ble_gap_lesc_oob_data_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_lesc_oob_data_t>(),
        39usize,
        concat!("Size of: ", stringify!(ble_gap_lesc_oob_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_lesc_oob_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_lesc_oob_data_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_lesc_oob_data_t>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_lesc_oob_data_t),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_lesc_oob_data_t>())).r as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_lesc_oob_data_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_lesc_oob_data_t>())).c as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_lesc_oob_data_t),
            "::",
            stringify!(c)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONNECTED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_connected_t {
    #[doc = "< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1"]
    #[doc = "and the address is the device's identity address."]
    pub peer_addr: ble_gap_addr_t,
    #[doc = "< BLE role for this connection, see @ref BLE_GAP_ROLES"]
    pub role: u8,
    #[doc = "< GAP Connection Parameters."]
    pub conn_params: ble_gap_conn_params_t,
    #[doc = "< Advertising handle in which advertising has ended."]
    #[doc = "This variable is only set if role is set to @ref BLE_GAP_ROLE_PERIPH."]
    pub adv_handle: u8,
    #[doc = "< Advertising buffers corresponding to the terminated"]
    #[doc = "advertising set. The advertising buffers provided in"]
    #[doc = "@ref sd_ble_gap_adv_set_configure are now released."]
    #[doc = "This variable is only set if role is set to @ref BLE_GAP_ROLE_PERIPH."]
    pub adv_data: ble_gap_adv_data_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_connected_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_connected_t>(),
        36usize,
        concat!("Size of: ", stringify!(ble_gap_evt_connected_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_connected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_connected_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_connected_t>())).peer_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_connected_t),
            "::",
            stringify!(peer_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_connected_t>())).role as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_connected_t),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_connected_t>())).conn_params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_connected_t),
            "::",
            stringify!(conn_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_connected_t>())).adv_handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_connected_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_connected_t>())).adv_data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_connected_t),
            "::",
            stringify!(adv_data)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_DISCONNECTED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_disconnected_t {
    #[doc = "< HCI error code, see @ref BLE_HCI_STATUS_CODES."]
    pub reason: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_disconnected_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_disconnected_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_evt_disconnected_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_disconnected_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_disconnected_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_disconnected_t>())).reason as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_disconnected_t),
            "::",
            stringify!(reason)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_conn_param_update_t {
    #[doc = "<  GAP Connection Parameters."]
    pub conn_params: ble_gap_conn_params_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_conn_param_update_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_conn_param_update_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_evt_conn_param_update_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_conn_param_update_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_conn_param_update_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_conn_param_update_t>())).conn_params as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_conn_param_update_t),
            "::",
            stringify!(conn_params)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_PHY_UPDATE_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_phy_update_request_t {
    #[doc = "< The PHYs the peer prefers to use."]
    pub peer_preferred_phys: ble_gap_phys_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_phy_update_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_phy_update_request_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gap_evt_phy_update_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_phy_update_request_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_phy_update_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_phy_update_request_t>())).peer_preferred_phys as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_phy_update_request_t),
            "::",
            stringify!(peer_preferred_phys)
        )
    );
}
#[doc = "@brief Event Structure for @ref BLE_GAP_EVT_PHY_UPDATE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_phy_update_t {
    #[doc = "< Status of the procedure, see @ref BLE_HCI_STATUS_CODES."]
    pub status: u8,
    #[doc = "< TX PHY for this connection, see @ref BLE_GAP_PHYS."]
    pub tx_phy: u8,
    #[doc = "< RX PHY for this connection, see @ref BLE_GAP_PHYS."]
    pub rx_phy: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_phy_update_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_phy_update_t>(),
        3usize,
        concat!("Size of: ", stringify!(ble_gap_evt_phy_update_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_phy_update_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_phy_update_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_phy_update_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_phy_update_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_phy_update_t>())).tx_phy as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_phy_update_t),
            "::",
            stringify!(tx_phy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_phy_update_t>())).rx_phy as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_phy_update_t),
            "::",
            stringify!(rx_phy)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_sec_params_request_t {
    #[doc = "< Initiator Security Parameters."]
    pub peer_params: ble_gap_sec_params_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_sec_params_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_sec_params_request_t>(),
        5usize,
        concat!("Size of: ", stringify!(ble_gap_evt_sec_params_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_sec_params_request_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_sec_params_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_sec_params_request_t>())).peer_params as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_sec_params_request_t),
            "::",
            stringify!(peer_params)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SEC_INFO_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_sec_info_request_t {
    #[doc = "< Bluetooth address of the peer device."]
    pub peer_addr: ble_gap_addr_t,
    #[doc = "< Master Identification for LTK lookup."]
    pub master_id: ble_gap_master_id_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_sec_info_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_sec_info_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(ble_gap_evt_sec_info_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_sec_info_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_sec_info_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_sec_info_request_t>())).peer_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_sec_info_request_t),
            "::",
            stringify!(peer_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_sec_info_request_t>())).master_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_sec_info_request_t),
            "::",
            stringify!(master_id)
        )
    );
}
impl ble_gap_evt_sec_info_request_t {
    #[inline]
    pub fn enc_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enc_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn id_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_id_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sign_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enc_info: u8, id_info: u8, sign_info: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enc_info: u8 = unsafe { ::core::mem::transmute(enc_info) };
            enc_info as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let id_info: u8 = unsafe { ::core::mem::transmute(id_info) };
            id_info as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sign_info: u8 = unsafe { ::core::mem::transmute(sign_info) };
            sign_info as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_PASSKEY_DISPLAY."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_passkey_display_t {
    #[doc = "< 6-digit passkey in ASCII ('0'-'9' digits only)."]
    pub passkey: [u8; 6usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_passkey_display_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_passkey_display_t>(),
        7usize,
        concat!("Size of: ", stringify!(ble_gap_evt_passkey_display_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_passkey_display_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_passkey_display_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_passkey_display_t>())).passkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_passkey_display_t),
            "::",
            stringify!(passkey)
        )
    );
}
impl ble_gap_evt_passkey_display_t {
    #[inline]
    pub fn match_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_match_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(match_request: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let match_request: u8 = unsafe { ::core::mem::transmute(match_request) };
            match_request as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_KEY_PRESSED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_key_pressed_t {
    #[doc = "< Keypress notification type, see @ref BLE_GAP_KP_NOT_TYPES."]
    pub kp_not: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_key_pressed_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_key_pressed_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_evt_key_pressed_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_key_pressed_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_key_pressed_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_key_pressed_t>())).kp_not as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_key_pressed_t),
            "::",
            stringify!(kp_not)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_AUTH_KEY_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_auth_key_request_t {
    #[doc = "< See @ref BLE_GAP_AUTH_KEY_TYPES."]
    pub key_type: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_auth_key_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_auth_key_request_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_evt_auth_key_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_auth_key_request_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_auth_key_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_auth_key_request_t>())).key_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_auth_key_request_t),
            "::",
            stringify!(key_type)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_lesc_dhkey_request_t {
    #[doc = "< LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory"]
    #[doc = "inside the keyset during the call to @ref sd_ble_gap_sec_params_reply."]
    pub p_pk_peer: *mut ble_gap_lesc_p256_pk_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_ble_gap_evt_lesc_dhkey_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_lesc_dhkey_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_evt_lesc_dhkey_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_lesc_dhkey_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_lesc_dhkey_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_lesc_dhkey_request_t>())).p_pk_peer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_lesc_dhkey_request_t),
            "::",
            stringify!(p_pk_peer)
        )
    );
}
impl ble_gap_evt_lesc_dhkey_request_t {
    #[inline]
    pub fn oobd_req(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oobd_req(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(oobd_req: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let oobd_req: u8 = unsafe { ::core::mem::transmute(oobd_req) };
            oobd_req as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Security levels supported."]
#[doc = " @note  See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_levels_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_sec_levels_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_sec_levels_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_sec_levels_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_sec_levels_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_sec_levels_t))
    );
}
impl ble_gap_sec_levels_t {
    #[inline]
    pub fn lv1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lv2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lv3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lv4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lv1: u8, lv2: u8, lv3: u8, lv4: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lv1: u8 = unsafe { ::core::mem::transmute(lv1) };
            lv1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lv2: u8 = unsafe { ::core::mem::transmute(lv2) };
            lv2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lv3: u8 = unsafe { ::core::mem::transmute(lv3) };
            lv3 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lv4: u8 = unsafe { ::core::mem::transmute(lv4) };
            lv4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Encryption Key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_enc_key_t {
    #[doc = "< Encryption Information."]
    pub enc_info: ble_gap_enc_info_t,
    #[doc = "< Master Identification."]
    pub master_id: ble_gap_master_id_t,
}
#[test]
fn bindgen_test_layout_ble_gap_enc_key_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_enc_key_t>(),
        28usize,
        concat!("Size of: ", stringify!(ble_gap_enc_key_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_enc_key_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_enc_key_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_enc_key_t>())).enc_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_enc_key_t),
            "::",
            stringify!(enc_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_enc_key_t>())).master_id as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_enc_key_t),
            "::",
            stringify!(master_id)
        )
    );
}
#[doc = "@brief Identity Key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_id_key_t {
    #[doc = "< Identity Resolving Key."]
    pub id_info: ble_gap_irk_t,
    #[doc = "< Identity Address."]
    pub id_addr_info: ble_gap_addr_t,
}
#[test]
fn bindgen_test_layout_ble_gap_id_key_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_id_key_t>(),
        23usize,
        concat!("Size of: ", stringify!(ble_gap_id_key_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_id_key_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_id_key_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_id_key_t>())).id_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_id_key_t),
            "::",
            stringify!(id_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_id_key_t>())).id_addr_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_id_key_t),
            "::",
            stringify!(id_addr_info)
        )
    );
}
#[doc = "@brief Security Keys."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_keys_t {
    #[doc = "< Encryption Key, or NULL."]
    pub p_enc_key: *mut ble_gap_enc_key_t,
    #[doc = "< Identity Key, or NULL."]
    pub p_id_key: *mut ble_gap_id_key_t,
    #[doc = "< Signing Key, or NULL."]
    pub p_sign_key: *mut ble_gap_sign_info_t,
    #[doc = "< LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined"]
    #[doc = "in the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1"]
    pub p_pk: *mut ble_gap_lesc_p256_pk_t,
}
#[test]
fn bindgen_test_layout_ble_gap_sec_keys_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_sec_keys_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_gap_sec_keys_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_sec_keys_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_sec_keys_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_keys_t>())).p_enc_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_keys_t),
            "::",
            stringify!(p_enc_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_keys_t>())).p_id_key as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_keys_t),
            "::",
            stringify!(p_id_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_keys_t>())).p_sign_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_keys_t),
            "::",
            stringify!(p_sign_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_keys_t>())).p_pk as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_keys_t),
            "::",
            stringify!(p_pk)
        )
    );
}
#[doc = "@brief Security key set for both local and peer keys."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_keyset_t {
    #[doc = "< Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding."]
    pub keys_own: ble_gap_sec_keys_t,
    #[doc = "< Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL."]
    pub keys_peer: ble_gap_sec_keys_t,
}
#[test]
fn bindgen_test_layout_ble_gap_sec_keyset_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_sec_keyset_t>(),
        32usize,
        concat!("Size of: ", stringify!(ble_gap_sec_keyset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_sec_keyset_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_sec_keyset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_keyset_t>())).keys_own as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_keyset_t),
            "::",
            stringify!(keys_own)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_sec_keyset_t>())).keys_peer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_sec_keyset_t),
            "::",
            stringify!(keys_peer)
        )
    );
}
#[doc = "@brief Data Length Update Procedure parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_data_length_params_t {
    #[doc = "< Maximum number of payload octets that a Controller supports for transmission of a single Link Layer Data Channel PDU."]
    pub max_tx_octets: u16,
    #[doc = "< Maximum number of payload octets that a Controller supports for reception of a single Link Layer Data Channel PDU."]
    pub max_rx_octets: u16,
    #[doc = "< Maximum time, in microseconds, that a Controller supports for transmission of a single Link Layer Data Channel PDU."]
    pub max_tx_time_us: u16,
    #[doc = "< Maximum time, in microseconds, that a Controller supports for reception of a single Link Layer Data Channel PDU."]
    pub max_rx_time_us: u16,
}
#[test]
fn bindgen_test_layout_ble_gap_data_length_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_data_length_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_data_length_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_data_length_params_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_data_length_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_data_length_params_t>())).max_tx_octets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_data_length_params_t),
            "::",
            stringify!(max_tx_octets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_data_length_params_t>())).max_rx_octets as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_data_length_params_t),
            "::",
            stringify!(max_rx_octets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_data_length_params_t>())).max_tx_time_us as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_data_length_params_t),
            "::",
            stringify!(max_tx_time_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_data_length_params_t>())).max_rx_time_us as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_data_length_params_t),
            "::",
            stringify!(max_rx_time_us)
        )
    );
}
#[doc = "@brief Data Length Update Procedure local limitation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_data_length_limitation_t {
    #[doc = "< If > 0, the requested TX packet length is too long by this many octets."]
    pub tx_payload_limited_octets: u16,
    #[doc = "< If > 0, the requested RX packet length is too long by this many octets."]
    pub rx_payload_limited_octets: u16,
    #[doc = "< If > 0, the requested combination of TX and RX packet lengths is too long by this many microseconds."]
    pub tx_rx_time_limited_us: u16,
}
#[test]
fn bindgen_test_layout_ble_gap_data_length_limitation_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_data_length_limitation_t>(),
        6usize,
        concat!("Size of: ", stringify!(ble_gap_data_length_limitation_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_data_length_limitation_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_data_length_limitation_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_data_length_limitation_t>())).tx_payload_limited_octets as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_data_length_limitation_t),
            "::",
            stringify!(tx_payload_limited_octets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_data_length_limitation_t>())).rx_payload_limited_octets as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_data_length_limitation_t),
            "::",
            stringify!(rx_payload_limited_octets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_data_length_limitation_t>())).tx_rx_time_limited_us as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_data_length_limitation_t),
            "::",
            stringify!(tx_rx_time_limited_us)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_AUTH_STATUS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_auth_status_t {
    #[doc = "< Authentication status, see @ref BLE_GAP_SEC_STATUS."]
    pub auth_status: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Levels supported in Security Mode 1."]
    pub sm1_levels: ble_gap_sec_levels_t,
    #[doc = "< Levels supported in Security Mode 2."]
    pub sm2_levels: ble_gap_sec_levels_t,
    #[doc = "< Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set."]
    pub kdist_own: ble_gap_sec_kdist_t,
    #[doc = "< Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set."]
    pub kdist_peer: ble_gap_sec_kdist_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_auth_status_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_auth_status_t>(),
        6usize,
        concat!("Size of: ", stringify!(ble_gap_evt_auth_status_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_auth_status_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_auth_status_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_auth_status_t>())).auth_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_auth_status_t),
            "::",
            stringify!(auth_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_auth_status_t>())).sm1_levels as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_auth_status_t),
            "::",
            stringify!(sm1_levels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_auth_status_t>())).sm2_levels as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_auth_status_t),
            "::",
            stringify!(sm2_levels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_auth_status_t>())).kdist_own as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_auth_status_t),
            "::",
            stringify!(kdist_own)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_auth_status_t>())).kdist_peer as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_auth_status_t),
            "::",
            stringify!(kdist_peer)
        )
    );
}
impl ble_gap_evt_auth_status_t {
    #[inline]
    pub fn error_src(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_error_src(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn bonded(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bonded(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(error_src: u8, bonded: u8, lesc: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let error_src: u8 = unsafe { ::core::mem::transmute(error_src) };
            error_src as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bonded: u8 = unsafe { ::core::mem::transmute(bonded) };
            bonded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONN_SEC_UPDATE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_conn_sec_update_t {
    #[doc = "< Connection security level."]
    pub conn_sec: ble_gap_conn_sec_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_conn_sec_update_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_conn_sec_update_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gap_evt_conn_sec_update_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_conn_sec_update_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_conn_sec_update_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_conn_sec_update_t>())).conn_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_conn_sec_update_t),
            "::",
            stringify!(conn_sec)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_TIMEOUT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gap_evt_timeout_t {
    #[doc = "< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES."]
    pub src: u8,
    #[doc = "< Event Parameters."]
    pub params: ble_gap_evt_timeout_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_evt_timeout_t__bindgen_ty_1 {
    #[doc = "< If source is set to @ref BLE_GAP_TIMEOUT_SRC_SCAN, the released"]
    #[doc = "scan buffer is contained in this field."]
    pub adv_report_buffer: ble_data_t,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_ble_gap_evt_timeout_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_timeout_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_evt_timeout_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_timeout_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_timeout_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_timeout_t__bindgen_ty_1>())).adv_report_buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_timeout_t__bindgen_ty_1),
            "::",
            stringify!(adv_report_buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_gap_evt_timeout_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_timeout_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_gap_evt_timeout_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_timeout_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_timeout_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_timeout_t>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_timeout_t),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_timeout_t>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_timeout_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_RSSI_CHANGED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_rssi_changed_t {
    #[doc = "< Received Signal Strength Indication in dBm."]
    #[doc = "@note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement."]
    pub rssi: i8,
    #[doc = "< Data Channel Index on which the Signal Strength is measured (0-36)."]
    pub ch_index: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_rssi_changed_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_rssi_changed_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gap_evt_rssi_changed_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_rssi_changed_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_rssi_changed_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_rssi_changed_t>())).rssi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_rssi_changed_t),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_rssi_changed_t>())).ch_index as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_rssi_changed_t),
            "::",
            stringify!(ch_index)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_ADV_SET_TERMINATED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_adv_set_terminated_t {
    #[doc = "< Reason for why the advertising set terminated. See"]
    #[doc = "@ref BLE_GAP_EVT_ADV_SET_TERMINATED_REASON."]
    pub reason: u8,
    #[doc = "< Advertising handle in which advertising has ended."]
    pub adv_handle: u8,
    #[doc = "< If @ref ble_gap_adv_params_t::max_adv_evts was not set to 0,"]
    #[doc = "this field indicates the number of completed advertising events."]
    pub num_completed_adv_events: u8,
    #[doc = "< Advertising buffers corresponding to the terminated"]
    #[doc = "advertising set. The advertising buffers provided in"]
    #[doc = "@ref sd_ble_gap_adv_set_configure are now released."]
    pub adv_data: ble_gap_adv_data_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_adv_set_terminated_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_adv_set_terminated_t>(),
        20usize,
        concat!("Size of: ", stringify!(ble_gap_evt_adv_set_terminated_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_adv_set_terminated_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_adv_set_terminated_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_set_terminated_t>())).reason as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_set_terminated_t),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_set_terminated_t>())).adv_handle as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_set_terminated_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_adv_set_terminated_t>())).num_completed_adv_events as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_set_terminated_t),
            "::",
            stringify!(num_completed_adv_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_set_terminated_t>())).adv_data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_set_terminated_t),
            "::",
            stringify!(adv_data)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_ADV_REPORT."]
#[doc = ""]
#[doc = " @note If @ref ble_gap_adv_report_type_t::status is set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA,"]
#[doc = "       not all fields in the advertising report may be available."]
#[doc = ""]
#[doc = " @note When ble_gap_adv_report_type_t::status is not set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA,"]
#[doc = "       scanning will be paused. To continue scanning, call @ref sd_ble_gap_scan_start."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_adv_report_t {
    #[doc = "< Advertising report type. See @ref ble_gap_adv_report_type_t."]
    pub type_: ble_gap_adv_report_type_t,
    #[doc = "< Bluetooth address of the peer device. If the peer_addr is resolved:"]
    #[doc = "@ref ble_gap_addr_t::addr_id_peer is set to 1 and the address is the"]
    #[doc = "peer's identity address."]
    pub peer_addr: ble_gap_addr_t,
    #[doc = "< Contains the target address of the advertising event if"]
    #[doc = "@ref ble_gap_adv_report_type_t::directed is set to 1. If the"]
    #[doc = "SoftDevice was able to resolve the address,"]
    #[doc = "@ref ble_gap_addr_t::addr_id_peer is set to 1 and the direct_addr"]
    #[doc = "contains the local identity address. If the target address of the"]
    #[doc = "advertising event is @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE,"]
    #[doc = "and the SoftDevice was unable to resolve it, the application may try"]
    #[doc = "to resolve this address to find out if the advertising event was"]
    #[doc = "directed to us."]
    pub direct_addr: ble_gap_addr_t,
    #[doc = "< Indicates the PHY on which the primary advertising packet was received."]
    #[doc = "See @ref BLE_GAP_PHYS."]
    pub primary_phy: u8,
    #[doc = "< Indicates the PHY on which the secondary advertising packet was received."]
    #[doc = "See @ref BLE_GAP_PHYS. This field is set to @ref BLE_GAP_PHY_NOT_SET if no packets"]
    #[doc = "were received on a secondary advertising channel."]
    pub secondary_phy: u8,
    #[doc = "< TX Power reported by the advertiser in the last packet header received."]
    #[doc = "This field is set to @ref BLE_GAP_POWER_LEVEL_INVALID if the"]
    #[doc = "last received packet did not contain the Tx Power field."]
    #[doc = "@note TX Power is only included in extended advertising packets."]
    pub tx_power: i8,
    #[doc = "< Received Signal Strength Indication in dBm of the last packet received."]
    #[doc = "@note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement."]
    pub rssi: i8,
    #[doc = "< Channel Index on which the last advertising packet is received (0-39)."]
    pub ch_index: u8,
    #[doc = "< Set ID of the received advertising data. Set ID is not present"]
    #[doc = "if set to @ref BLE_GAP_ADV_REPORT_SET_ID_NOT_AVAILABLE."]
    pub set_id: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = "< Received advertising or scan response data. If"]
    #[doc = "@ref ble_gap_adv_report_type_t::status is not set to"]
    #[doc = "@ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA, the data buffer provided"]
    #[doc = "in @ref sd_ble_gap_scan_start is now released."]
    pub data: ble_data_t,
    #[doc = "< The offset and PHY of the next advertising packet in this extended advertising"]
    #[doc = "event. @note This field is only set if @ref ble_gap_adv_report_type_t::status"]
    #[doc = "is set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA."]
    pub aux_pointer: ble_gap_aux_pointer_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_adv_report_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_adv_report_t>(),
        36usize,
        concat!("Size of: ", stringify!(ble_gap_evt_adv_report_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_adv_report_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_adv_report_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).peer_addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(peer_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).direct_addr as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(direct_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).primary_phy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(primary_phy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).secondary_phy as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(secondary_phy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).tx_power as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(tx_power)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).rssi as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).ch_index as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(ch_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).set_id as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(set_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_adv_report_t>())).aux_pointer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_adv_report_t),
            "::",
            stringify!(aux_pointer)
        )
    );
}
impl ble_gap_evt_adv_report_t {
    #[inline]
    pub fn data_id(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_data_id(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data_id: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let data_id: u16 = unsafe { ::core::mem::transmute(data_id) };
            data_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SEC_REQUEST."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_sec_request_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_sec_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_sec_request_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_evt_sec_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_sec_request_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_sec_request_t))
    );
}
impl ble_gap_evt_sec_request_t {
    #[inline]
    pub fn bond(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bond(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mitm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mitm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keypress(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keypress(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bond: u8, mitm: u8, lesc: u8, keypress: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bond: u8 = unsafe { ::core::mem::transmute(bond) };
            bond as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mitm: u8 = unsafe { ::core::mem::transmute(mitm) };
            mitm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keypress: u8 = unsafe { ::core::mem::transmute(keypress) };
            keypress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_conn_param_update_request_t {
    #[doc = "<  GAP Connection Parameters."]
    pub conn_params: ble_gap_conn_params_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_conn_param_update_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_conn_param_update_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_evt_conn_param_update_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_conn_param_update_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_conn_param_update_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_conn_param_update_request_t>())).conn_params as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_conn_param_update_request_t),
            "::",
            stringify!(conn_params)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SCAN_REQ_REPORT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_scan_req_report_t {
    #[doc = "< Advertising handle for the advertising set which received the Scan Request"]
    pub adv_handle: u8,
    #[doc = "< Received Signal Strength Indication in dBm."]
    #[doc = "@note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement."]
    pub rssi: i8,
    #[doc = "< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1"]
    #[doc = "and the address is the device's identity address."]
    pub peer_addr: ble_gap_addr_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_scan_req_report_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_scan_req_report_t>(),
        9usize,
        concat!("Size of: ", stringify!(ble_gap_evt_scan_req_report_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_scan_req_report_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_scan_req_report_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_scan_req_report_t>())).adv_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_scan_req_report_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_scan_req_report_t>())).rssi as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_scan_req_report_t),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_scan_req_report_t>())).peer_addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_scan_req_report_t),
            "::",
            stringify!(peer_addr)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_data_length_update_request_t {
    #[doc = "< Peer data length parameters."]
    pub peer_params: ble_gap_data_length_params_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_data_length_update_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_data_length_update_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_evt_data_length_update_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_data_length_update_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_data_length_update_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_data_length_update_request_t>())).peer_params as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_data_length_update_request_t),
            "::",
            stringify!(peer_params)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE."]
#[doc = ""]
#[doc = " @note This event may also be raised after a PHY Update procedure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_data_length_update_t {
    #[doc = "< The effective data length parameters."]
    pub effective_params: ble_gap_data_length_params_t,
}
#[test]
fn bindgen_test_layout_ble_gap_evt_data_length_update_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_data_length_update_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_evt_data_length_update_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_data_length_update_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_data_length_update_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_data_length_update_t>())).effective_params as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_data_length_update_t),
            "::",
            stringify!(effective_params)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gap_evt_qos_channel_survey_report_t {
    #[doc = "< The measured energy on the Bluetooth Low Energy"]
    #[doc = "channels, in dBm, indexed by Channel Index."]
    #[doc = "If no measurement is available for the given channel, channel_energy is set to"]
    #[doc = "@ref BLE_GAP_POWER_LEVEL_INVALID."]
    pub channel_energy: [i8; 40usize],
}
#[test]
fn bindgen_test_layout_ble_gap_evt_qos_channel_survey_report_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_qos_channel_survey_report_t>(),
        40usize,
        concat!("Size of: ", stringify!(ble_gap_evt_qos_channel_survey_report_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_qos_channel_survey_report_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_qos_channel_survey_report_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_qos_channel_survey_report_t>())).channel_energy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_qos_channel_survey_report_t),
            "::",
            stringify!(channel_energy)
        )
    );
}
#[doc = "@brief GAP event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gap_evt_t {
    #[doc = "< Connection Handle on which event occurred."]
    pub conn_handle: u16,
    #[doc = "< Event Parameters."]
    pub params: ble_gap_evt_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_evt_t__bindgen_ty_1 {
    #[doc = "< Connected Event Parameters."]
    pub connected: ble_gap_evt_connected_t,
    #[doc = "< Disconnected Event Parameters."]
    pub disconnected: ble_gap_evt_disconnected_t,
    #[doc = "< Connection Parameter Update Parameters."]
    pub conn_param_update: ble_gap_evt_conn_param_update_t,
    #[doc = "< Security Parameters Request Event Parameters."]
    pub sec_params_request: ble_gap_evt_sec_params_request_t,
    #[doc = "< Security Information Request Event Parameters."]
    pub sec_info_request: ble_gap_evt_sec_info_request_t,
    #[doc = "< Passkey Display Event Parameters."]
    pub passkey_display: ble_gap_evt_passkey_display_t,
    #[doc = "< Key Pressed Event Parameters."]
    pub key_pressed: ble_gap_evt_key_pressed_t,
    #[doc = "< Authentication Key Request Event Parameters."]
    pub auth_key_request: ble_gap_evt_auth_key_request_t,
    #[doc = "< LE Secure Connections DHKey calculation request."]
    pub lesc_dhkey_request: ble_gap_evt_lesc_dhkey_request_t,
    #[doc = "< Authentication Status Event Parameters."]
    pub auth_status: ble_gap_evt_auth_status_t,
    #[doc = "< Connection Security Update Event Parameters."]
    pub conn_sec_update: ble_gap_evt_conn_sec_update_t,
    #[doc = "< Timeout Event Parameters."]
    pub timeout: ble_gap_evt_timeout_t,
    #[doc = "< RSSI Event Parameters."]
    pub rssi_changed: ble_gap_evt_rssi_changed_t,
    #[doc = "< Advertising Report Event Parameters."]
    pub adv_report: ble_gap_evt_adv_report_t,
    #[doc = "< Advertising Set Terminated Event Parameters."]
    pub adv_set_terminated: ble_gap_evt_adv_set_terminated_t,
    #[doc = "< Security Request Event Parameters."]
    pub sec_request: ble_gap_evt_sec_request_t,
    #[doc = "< Connection Parameter Update Parameters."]
    pub conn_param_update_request: ble_gap_evt_conn_param_update_request_t,
    #[doc = "< Scan Request Report Parameters."]
    pub scan_req_report: ble_gap_evt_scan_req_report_t,
    #[doc = "< PHY Update Request Event Parameters."]
    pub phy_update_request: ble_gap_evt_phy_update_request_t,
    #[doc = "< PHY Update Parameters."]
    pub phy_update: ble_gap_evt_phy_update_t,
    #[doc = "< Data Length Update Request Event Parameters."]
    pub data_length_update_request: ble_gap_evt_data_length_update_request_t,
    #[doc = "< Data Length Update Event Parameters."]
    pub data_length_update: ble_gap_evt_data_length_update_t,
    #[doc = "< Quality of Service (QoS) Channel Survey Report Parameters."]
    pub qos_channel_survey_report: ble_gap_evt_qos_channel_survey_report_t,
    _bindgen_union_align: [u32; 10usize],
}
#[test]
fn bindgen_test_layout_ble_gap_evt_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_t__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(ble_gap_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).connected as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).disconnected as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(disconnected)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).conn_param_update as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(conn_param_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).sec_params_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(sec_params_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).sec_info_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(sec_info_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).passkey_display as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(passkey_display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).key_pressed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(key_pressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).auth_key_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(auth_key_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).lesc_dhkey_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(lesc_dhkey_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).auth_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(auth_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).conn_sec_update as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(conn_sec_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).rssi_changed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(rssi_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).adv_report as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(adv_report)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).adv_set_terminated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(adv_set_terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).sec_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(sec_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).conn_param_update_request as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(conn_param_update_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).scan_req_report as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(scan_req_report)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).phy_update_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(phy_update_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).phy_update as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(phy_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).data_length_update_request as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(data_length_update_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).data_length_update as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(data_length_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_evt_t__bindgen_ty_1>())).qos_channel_survey_report as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t__bindgen_ty_1),
            "::",
            stringify!(qos_channel_survey_report)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_gap_evt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_evt_t>(),
        44usize,
        concat!("Size of: ", stringify!(ble_gap_evt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_evt_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_evt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_evt_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_evt_t>())).params as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ble_gap_evt_t), "::", stringify!(params))
    );
}
#[doc = " @brief BLE GAP connection configuration parameters, set with @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_CONN_COUNT     The connection count for the connection configurations is zero."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:"]
#[doc = "                                    - The sum of conn_count for all connection configurations combined exceeds UINT8_MAX."]
#[doc = "                                    - The event length is smaller than @ref BLE_GAP_EVENT_LENGTH_MIN."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_cfg_t {
    #[doc = "< The number of concurrent connections the application can create with this configuration."]
    #[doc = "The default and minimum value is @ref BLE_GAP_CONN_COUNT_DEFAULT."]
    pub conn_count: u8,
    #[doc = "< The time set aside for this connection on every connection interval in 1.25 ms units."]
    #[doc = "The default value is @ref BLE_GAP_EVENT_LENGTH_DEFAULT, the minimum value is @ref BLE_GAP_EVENT_LENGTH_MIN."]
    #[doc = "The event length and the connection interval are the primary parameters"]
    #[doc = "for setting the throughput of a connection."]
    #[doc = "See the SoftDevice Specification for details on throughput."]
    pub event_length: u16,
}
#[test]
fn bindgen_test_layout_ble_gap_conn_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_conn_cfg_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gap_conn_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_conn_cfg_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_conn_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_cfg_t>())).conn_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_cfg_t),
            "::",
            stringify!(conn_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_cfg_t>())).event_length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_cfg_t),
            "::",
            stringify!(event_length)
        )
    );
}
#[doc = " @brief Configuration of maximum concurrent connections in the different connected roles, set with"]
#[doc = " @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_CONN_COUNT     The sum of periph_role_count and central_role_count is too"]
#[doc = "                                    large. The maximum supported sum of concurrent connections is"]
#[doc = "                                    @ref BLE_GAP_ROLE_COUNT_COMBINED_MAX."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM  central_sec_count is larger than central_role_count."]
#[doc = " @retval ::NRF_ERROR_RESOURCES      The adv_set_count is too large. The maximum"]
#[doc = "                                    supported advertising handles is"]
#[doc = "                                    @ref BLE_GAP_ADV_SET_COUNT_MAX."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_role_count_t {
    #[doc = "< Maximum number of advertising sets. Default value is @ref BLE_GAP_ADV_SET_COUNT_DEFAULT."]
    pub adv_set_count: u8,
    #[doc = "< Maximum number of connections concurrently acting as a peripheral. Default value is @ref BLE_GAP_ROLE_COUNT_PERIPH_DEFAULT."]
    pub periph_role_count: u8,
    #[doc = "< Maximum number of connections concurrently acting as a central. Default value is @ref BLE_GAP_ROLE_COUNT_CENTRAL_DEFAULT."]
    pub central_role_count: u8,
    #[doc = "< Number of SMP instances shared between all connections acting as a central. Default value is @ref BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT."]
    pub central_sec_count: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_cfg_role_count_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_cfg_role_count_t>(),
        5usize,
        concat!("Size of: ", stringify!(ble_gap_cfg_role_count_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_cfg_role_count_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_cfg_role_count_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_role_count_t>())).adv_set_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_role_count_t),
            "::",
            stringify!(adv_set_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_role_count_t>())).periph_role_count as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_role_count_t),
            "::",
            stringify!(periph_role_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_role_count_t>())).central_role_count as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_role_count_t),
            "::",
            stringify!(central_role_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_role_count_t>())).central_sec_count as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_role_count_t),
            "::",
            stringify!(central_sec_count)
        )
    );
}
impl ble_gap_cfg_role_count_t {
    #[inline]
    pub fn qos_channel_survey_role_available(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qos_channel_survey_role_available(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(qos_channel_survey_role_available: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let qos_channel_survey_role_available: u8 =
                unsafe { ::core::mem::transmute(qos_channel_survey_role_available) };
            qos_channel_survey_role_available as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Device name and its properties, set with @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @note  If the device name is not configured, the default device name will be"]
#[doc = "        @ref BLE_GAP_DEVNAME_DEFAULT, the maximum device name length will be"]
#[doc = "        @ref BLE_GAP_DEVNAME_DEFAULT_LEN, vloc will be set to @ref BLE_GATTS_VLOC_STACK and the device name"]
#[doc = "        will have no write access."]
#[doc = ""]
#[doc = " @note  If @ref max_len is more than @ref BLE_GAP_DEVNAME_DEFAULT_LEN and vloc is set to @ref BLE_GATTS_VLOC_STACK,"]
#[doc = "        the attribute table size must be increased to have room for the longer device name (see"]
#[doc = "        @ref sd_ble_cfg_set and @ref ble_gatts_cfg_attr_tab_size_t)."]
#[doc = ""]
#[doc = " @note  If vloc is @ref BLE_GATTS_VLOC_STACK :"]
#[doc = "        - p_value must point to non-volatile memory (flash) or be NULL."]
#[doc = "        - If p_value is NULL, the device name will initially be empty."]
#[doc = ""]
#[doc = " @note  If vloc is @ref BLE_GATTS_VLOC_USER :"]
#[doc = "        - p_value cannot be NULL."]
#[doc = "        - If the device name is writable, p_value must point to volatile memory (RAM)."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:"]
#[doc = "                                    - Invalid device name location (vloc)."]
#[doc = "                                    - Invalid device name security mode."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH One or more of the following is true:"]
#[doc = "                                    - The device name length is invalid (must be between 0 and @ref BLE_GAP_DEVNAME_MAX_LEN)."]
#[doc = "                                    - The device name length is too long for the given Attribute Table."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_device_name_t {
    #[doc = "< Write permissions."]
    pub write_perm: ble_gap_conn_sec_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Pointer to where the value (device name) is stored or will be stored."]
    pub p_value: *mut u8,
    #[doc = "< Current length in bytes of the memory pointed to by p_value."]
    pub current_len: u16,
    #[doc = "< Maximum length in bytes of the memory pointed to by p_value."]
    pub max_len: u16,
}
#[test]
fn bindgen_test_layout_ble_gap_cfg_device_name_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_cfg_device_name_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_gap_cfg_device_name_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_cfg_device_name_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_cfg_device_name_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_device_name_t>())).write_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_device_name_t),
            "::",
            stringify!(write_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_device_name_t>())).p_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_device_name_t),
            "::",
            stringify!(p_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_device_name_t>())).current_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_device_name_t),
            "::",
            stringify!(current_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_device_name_t>())).max_len as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_device_name_t),
            "::",
            stringify!(max_len)
        )
    );
}
impl ble_gap_cfg_device_name_t {
    #[inline]
    pub fn vloc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_vloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vloc: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let vloc: u8 = unsafe { ::core::mem::transmute(vloc) };
            vloc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Peripheral Preferred Connection Parameters include configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_ppcp_incl_cfg_t {
    #[doc = "< Inclusion configuration of the Peripheral Preferred Connection Parameters characteristic."]
    #[doc = "See @ref BLE_GAP_CHAR_INCL_CONFIG. Default is @ref BLE_GAP_PPCP_INCL_CONFIG_DEFAULT."]
    pub include_cfg: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_cfg_ppcp_incl_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_cfg_ppcp_incl_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_cfg_ppcp_incl_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_cfg_ppcp_incl_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_cfg_ppcp_incl_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_ppcp_incl_cfg_t>())).include_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_ppcp_incl_cfg_t),
            "::",
            stringify!(include_cfg)
        )
    );
}
#[doc = "@brief Central Address Resolution include configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_car_incl_cfg_t {
    #[doc = "< Inclusion configuration of the Central Address Resolution characteristic."]
    #[doc = "See @ref BLE_GAP_CHAR_INCL_CONFIG. Default is @ref BLE_GAP_CAR_INCL_CONFIG_DEFAULT."]
    pub include_cfg: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_cfg_car_incl_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_cfg_car_incl_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_cfg_car_incl_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_cfg_car_incl_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_cfg_car_incl_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_car_incl_cfg_t>())).include_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_car_incl_cfg_t),
            "::",
            stringify!(include_cfg)
        )
    );
}
#[doc = "@brief Configuration structure for GAP configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_cfg_t {
    #[doc = "< Role count configuration, cfg_id is @ref BLE_GAP_CFG_ROLE_COUNT."]
    pub role_count_cfg: ble_gap_cfg_role_count_t,
    #[doc = "< Device name configuration, cfg_id is @ref BLE_GAP_CFG_DEVICE_NAME."]
    pub device_name_cfg: ble_gap_cfg_device_name_t,
    #[doc = "< Peripheral Preferred Connection Parameters characteristic include"]
    #[doc = "configuration, cfg_id is @ref BLE_GAP_CFG_PPCP_INCL_CONFIG."]
    pub ppcp_include_cfg: ble_gap_cfg_ppcp_incl_cfg_t,
    #[doc = "< Central Address Resolution characteristic include configuration,"]
    #[doc = "cfg_id is @ref BLE_GAP_CFG_CAR_INCL_CONFIG."]
    pub car_include_cfg: ble_gap_cfg_car_incl_cfg_t,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ble_gap_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_cfg_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_gap_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_cfg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_t>())).role_count_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_t),
            "::",
            stringify!(role_count_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_t>())).device_name_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_t),
            "::",
            stringify!(device_name_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_t>())).ppcp_include_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_t),
            "::",
            stringify!(ppcp_include_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_cfg_t>())).car_include_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_cfg_t),
            "::",
            stringify!(car_include_cfg)
        )
    );
}
#[doc = "@brief Channel Map option."]
#[doc = ""]
#[doc = " @details Used with @ref sd_ble_opt_get to get the current channel map"]
#[doc = "          or @ref sd_ble_opt_set to set a new channel map. When setting the"]
#[doc = "          channel map, it applies to all current and future connections. When getting the"]
#[doc = "          current channel map, it applies to a single connection and the connection handle"]
#[doc = "          must be supplied."]
#[doc = ""]
#[doc = " @note Setting the channel map may take some time, depending on connection parameters."]
#[doc = "       The time taken may be different for each connection and the get operation will"]
#[doc = "       return the previous channel map until the new one has taken effect."]
#[doc = ""]
#[doc = " @note After setting the channel map, by spec it can not be set again until at least 1 s has passed."]
#[doc = "       See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Get or set successful."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM One or more of the following is true:"]
#[doc = "                                   - Less then two bits in @ref ch_map are set."]
#[doc = "                                   - Bits for primary advertising channels (37-39) are set."]
#[doc = " @retval ::NRF_ERROR_BUSY Channel map was set again before enough time had passed."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_ch_map_t {
    #[doc = "< Connection Handle (only applicable for get)"]
    pub conn_handle: u16,
    #[doc = "< Channel Map (37-bit)."]
    pub ch_map: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_ble_gap_opt_ch_map_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_opt_ch_map_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_opt_ch_map_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_opt_ch_map_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_opt_ch_map_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_ch_map_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_ch_map_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_ch_map_t>())).ch_map as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_ch_map_t),
            "::",
            stringify!(ch_map)
        )
    );
}
#[doc = "@brief Local connection latency option."]
#[doc = ""]
#[doc = " @details Local connection latency is a feature which enables the slave to improve"]
#[doc = "          current consumption by ignoring the slave latency set by the peer. The"]
#[doc = "          local connection latency can only be set to a multiple of the slave latency,"]
#[doc = "          and cannot be longer than half of the supervision timeout."]
#[doc = ""]
#[doc = " @details Used with @ref sd_ble_opt_set to set the local connection latency. The"]
#[doc = "          @ref sd_ble_opt_get is not supported for this option, but the actual"]
#[doc = "          local connection latency (unless set to NULL) is set as a return parameter"]
#[doc = "          when setting the option."]
#[doc = ""]
#[doc = " @note The latency set will be truncated down to the closest slave latency event"]
#[doc = "       multiple, or the nearest multiple before half of the supervision timeout."]
#[doc = ""]
#[doc = " @note The local connection latency is disabled by default, and needs to be enabled for new"]
#[doc = "       connections and whenever the connection is updated."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Set successfully."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED Get is not supported."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_local_conn_latency_t {
    #[doc = "< Connection Handle"]
    pub conn_handle: u16,
    #[doc = "< Requested local connection latency."]
    pub requested_latency: u16,
    #[doc = "< Pointer to storage for the actual local connection latency (can be set to NULL to skip return value)."]
    pub p_actual_latency: *mut u16,
}
#[test]
fn bindgen_test_layout_ble_gap_opt_local_conn_latency_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_opt_local_conn_latency_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_opt_local_conn_latency_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_opt_local_conn_latency_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_opt_local_conn_latency_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_local_conn_latency_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_local_conn_latency_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_local_conn_latency_t>())).requested_latency as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_local_conn_latency_t),
            "::",
            stringify!(requested_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_local_conn_latency_t>())).p_actual_latency as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_local_conn_latency_t),
            "::",
            stringify!(p_actual_latency)
        )
    );
}
#[doc = "@brief Disable slave latency"]
#[doc = ""]
#[doc = " @details Used with @ref sd_ble_opt_set to temporarily disable slave latency of a peripheral connection"]
#[doc = "          (see @ref ble_gap_conn_params_t::slave_latency). And to re-enable it again. When disabled, the"]
#[doc = "          peripheral will ignore the slave_latency set by the central."]
#[doc = ""]
#[doc = " @note  Shall only be called on peripheral links."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Set successfully."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED Get is not supported."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_slave_latency_disable_t {
    #[doc = "< Connection Handle"]
    pub conn_handle: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_ble_gap_opt_slave_latency_disable_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_opt_slave_latency_disable_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gap_opt_slave_latency_disable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_opt_slave_latency_disable_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_opt_slave_latency_disable_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_slave_latency_disable_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_slave_latency_disable_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
impl ble_gap_opt_slave_latency_disable_t {
    #[inline]
    pub fn disable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(disable: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable: u8 = unsafe { ::core::mem::transmute(disable) };
            disable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Passkey Option."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @details Structure containing the passkey to be used during pairing. This can be used with @ref"]
#[doc = "          sd_ble_opt_set to make the SoftDevice use a preprogrammed passkey for authentication"]
#[doc = "          instead of generating a random one."]
#[doc = ""]
#[doc = " @note Repeated pairing attempts using the same preprogrammed passkey makes pairing vulnerable to MITM attacks."]
#[doc = ""]
#[doc = " @note @ref sd_ble_opt_get is not supported for this option."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_passkey_t {
    #[doc = "< Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required."]
    pub p_passkey: *const u8,
}
#[test]
fn bindgen_test_layout_ble_gap_opt_passkey_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_opt_passkey_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gap_opt_passkey_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_opt_passkey_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_opt_passkey_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_passkey_t>())).p_passkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_passkey_t),
            "::",
            stringify!(p_passkey)
        )
    );
}
#[doc = "@brief Compatibility mode 1 option."]
#[doc = ""]
#[doc = " @details This can be used with @ref sd_ble_opt_set to enable and disable"]
#[doc = "          compatibility mode 1. Compatibility mode 1 is disabled by default."]
#[doc = ""]
#[doc = " @note Compatibility mode 1 enables interoperability with devices that do not support a value of"]
#[doc = "       0 for the WinOffset parameter in the Link Layer CONNECT_IND packet. This applies to a"]
#[doc = "       limited set of legacy peripheral devices from another vendor. Enabling this compatibility"]
#[doc = "       mode will only have an effect if the local device will act as a central device and"]
#[doc = "       initiate a connection to a peripheral device. In that case it may lead to the connection"]
#[doc = "       creation taking up to one connection interval longer to complete for all connections."]
#[doc = ""]
#[doc = "  @retval ::NRF_SUCCESS Set successfully."]
#[doc = "  @retval ::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_compat_mode_1_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gap_opt_compat_mode_1_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_opt_compat_mode_1_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gap_opt_compat_mode_1_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_opt_compat_mode_1_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gap_opt_compat_mode_1_t))
    );
}
impl ble_gap_opt_compat_mode_1_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Authenticated payload timeout option."]
#[doc = ""]
#[doc = " @details This can be used with @ref sd_ble_opt_set to change the Authenticated payload timeout to a value other"]
#[doc = "          than the default of @ref BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MAX."]
#[doc = ""]
#[doc = " @note The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated"]
#[doc = "       if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted"]
#[doc = "       link."]
#[doc = ""]
#[doc = " @note The LE ping procedure will be initiated before the timer expires to give the peer a chance"]
#[doc = "       to reset the timer. In addition the stack will try to prioritize running of LE ping over other"]
#[doc = "       activities to increase chances of finishing LE ping before timer expires. To avoid side-effects"]
#[doc = "       on other activities, it is recommended to use high timeout values."]
#[doc = "       Recommended timeout > 2*(connInterval * (6 + connSlaveLatency))."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Set successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_auth_payload_timeout_t {
    #[doc = "< Connection Handle"]
    pub conn_handle: u16,
    #[doc = "< Requested timeout in 10 ms unit, see @ref BLE_GAP_AUTH_PAYLOAD_TIMEOUT."]
    pub auth_payload_timeout: u16,
}
#[test]
fn bindgen_test_layout_ble_gap_opt_auth_payload_timeout_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_opt_auth_payload_timeout_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gap_opt_auth_payload_timeout_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_opt_auth_payload_timeout_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gap_opt_auth_payload_timeout_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_auth_payload_timeout_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_auth_payload_timeout_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_opt_auth_payload_timeout_t>())).auth_payload_timeout as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_auth_payload_timeout_t),
            "::",
            stringify!(auth_payload_timeout)
        )
    );
}
#[doc = "@brief Option structure for GAP options."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_opt_t {
    #[doc = "< Parameters for the Channel Map option."]
    pub ch_map: ble_gap_opt_ch_map_t,
    #[doc = "< Parameters for the Local connection latency option"]
    pub local_conn_latency: ble_gap_opt_local_conn_latency_t,
    #[doc = "< Parameters for the Passkey option."]
    pub passkey: ble_gap_opt_passkey_t,
    #[doc = "< Parameters for the compatibility mode 1 option."]
    pub compat_mode_1: ble_gap_opt_compat_mode_1_t,
    #[doc = "< Parameters for the authenticated payload timeout option."]
    pub auth_payload_timeout: ble_gap_opt_auth_payload_timeout_t,
    #[doc = "< Parameters for the Disable slave latency option"]
    pub slave_latency_disable: ble_gap_opt_slave_latency_disable_t,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_ble_gap_opt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_opt_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gap_opt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_opt_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_opt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_t>())).ch_map as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_gap_opt_t), "::", stringify!(ch_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_t>())).local_conn_latency as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_t),
            "::",
            stringify!(local_conn_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_t>())).passkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_t),
            "::",
            stringify!(passkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_t>())).compat_mode_1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_t),
            "::",
            stringify!(compat_mode_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_t>())).auth_payload_timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_t),
            "::",
            stringify!(auth_payload_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_opt_t>())).slave_latency_disable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_opt_t),
            "::",
            stringify!(slave_latency_disable)
        )
    );
}
#[doc = "@brief  Connection event triggering parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_event_trigger_t {
    #[doc = "< PPI channel to use. This channel should be regarded as reserved until"]
    #[doc = "connection event PPI task triggering is stopped."]
    #[doc = "The PPI channel ID can not be one of the PPI channels reserved by"]
    #[doc = "the SoftDevice. See @ref NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK."]
    pub ppi_ch_id: u8,
    #[doc = "< Task Endpoint to trigger."]
    pub task_endpoint: u32,
    #[doc = "< The connection event on which the task triggering should start."]
    pub conn_evt_counter_start: u16,
    #[doc = "< Trigger period. Valid range is [1, 32767]."]
    #[doc = "If the device is in slave role and slave latency is enabled,"]
    #[doc = "this parameter should be set to a multiple of (slave latency + 1)"]
    #[doc = "to ensure low power operation."]
    pub period_in_events: u16,
}
#[test]
fn bindgen_test_layout_ble_gap_conn_event_trigger_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gap_conn_event_trigger_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_gap_conn_event_trigger_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gap_conn_event_trigger_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gap_conn_event_trigger_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_event_trigger_t>())).ppi_ch_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_event_trigger_t),
            "::",
            stringify!(ppi_ch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_event_trigger_t>())).task_endpoint as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_event_trigger_t),
            "::",
            stringify!(task_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gap_conn_event_trigger_t>())).conn_evt_counter_start as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_event_trigger_t),
            "::",
            stringify!(conn_evt_counter_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gap_conn_event_trigger_t>())).period_in_events as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gap_conn_event_trigger_t),
            "::",
            stringify!(period_in_events)
        )
    );
}

#[doc = "@brief Set the local Bluetooth identity address."]
#[doc = ""]
#[doc = "        The local Bluetooth identity address is the address that identifies this device to other peers."]
#[doc = "        The address type must be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC."]
#[doc = ""]
#[doc = " @note  The identity address cannot be changed while advertising, scanning or creating a connection."]
#[doc = ""]
#[doc = " @note  This address will be distributed to the peer during bonding."]
#[doc = "        If the address changes, the address stored in the peer device will not be valid and the ability to"]
#[doc = "        reconnect using the old address will be lost."]
#[doc = ""]
#[doc = " @note  By default the SoftDevice will set an address of type @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC upon being"]
#[doc = "        enabled. The address is a random number populated during the IC manufacturing process and remains unchanged"]
#[doc = "        for the lifetime of each IC."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_ADV_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] p_addr Pointer to address structure."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Address successfully set."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address."]
#[doc = " @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE The identity address cannot be changed while advertising,"]
#[doc = "                                   scanning or creating a connection."]
#[inline(always)]
pub unsafe fn sd_ble_gap_addr_set(p_addr: *const ble_gap_addr_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 108",
        inout("r0") to_asm(p_addr) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get local Bluetooth identity address."]
#[doc = ""]
#[doc = " @note  This will always return the identity address irrespective of the privacy settings,"]
#[doc = "        i.e. the address type will always be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC."]
#[doc = ""]
#[doc = " @param[out] p_addr Pointer to address structure to be filled in."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Address successfully retrieved."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid or NULL pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_addr_get(p_addr: *mut ble_gap_addr_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 109",
        inout("r0") to_asm(p_addr) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the Bluetooth device address used by the advertiser."]
#[doc = ""]
#[doc = " @note  This function will return the local Bluetooth address used in advertising PDUs. When"]
#[doc = "        using privacy, the SoftDevice will generate a new private address every"]
#[doc = "        @ref ble_gap_privacy_params_t::private_addr_cycle_s configured using"]
#[doc = "        @ref sd_ble_gap_privacy_set. Hence depending on when the application calls this API, the"]
#[doc = "        address returned may not be the latest address that is used in the advertising PDUs."]
#[doc = ""]
#[doc = " @param[in]  adv_handle The advertising handle to get the address from."]
#[doc = " @param[out] p_addr     Pointer to address structure to be filled in."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                  Address successfully retrieved."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR       Invalid or NULL pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_ADV_HANDLE The provided advertising handle was not found."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE      The advertising set is currently not advertising."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_addr_get(adv_handle: u8, p_addr: *mut ble_gap_addr_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 147",
        inout("r0") to_asm(adv_handle) => ret,
        inout("r1") to_asm(p_addr) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set the active whitelist in the SoftDevice."]
#[doc = ""]
#[doc = " @note  Only one whitelist can be used at a time and the whitelist is shared between the BLE roles."]
#[doc = "        The whitelist cannot be set if a BLE role is using the whitelist."]
#[doc = ""]
#[doc = " @note  If an address is resolved using the information in the device identity list, then the whitelist"]
#[doc = "        filter policy applies to the peer identity address and not the resolvable address sent on air."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_WL_SHARE_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] pp_wl_addrs Pointer to a whitelist of peer addresses, if NULL the whitelist will be cleared."]
#[doc = " @param[in] len         Length of the whitelist, maximum @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The whitelist is successfully set/cleared."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR The whitelist (or one of its entries) provided is invalid."]
#[doc = " @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE The whitelist is in use by a BLE role and cannot be set or cleared."]
#[doc = " @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE The given whitelist size is invalid (zero or too large); this can only return when"]
#[doc = "                               pp_wl_addrs is not NULL."]
#[inline(always)]
pub unsafe fn sd_ble_gap_whitelist_set(pp_wl_addrs: *const *const ble_gap_addr_t, len: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 110",
        inout("r0") to_asm(pp_wl_addrs) => ret,
        inout("r1") to_asm(len) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set device identity list."]
#[doc = ""]
#[doc = " @note  Only one device identity list can be used at a time and the list is shared between the BLE roles."]
#[doc = "        The device identity list cannot be set if a BLE role is using the list."]
#[doc = ""]
#[doc = " @param[in] pp_id_keys     Pointer to an array of peer identity addresses and peer IRKs, if NULL the device identity list will be cleared."]
#[doc = " @param[in] pp_local_irks  Pointer to an array of local IRKs. Each entry in the array maps to the entry in pp_id_keys at the same index."]
#[doc = "                           To fill in the list with the currently set device IRK for all peers, set to NULL."]
#[doc = " @param[in] len            Length of the device identity list, maximum @ref BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The device identity list successfully set/cleared."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR The device identity list (or one of its entries) provided is invalid."]
#[doc = "                                  This code may be returned if the local IRK list also has an invalid entry."]
#[doc = " @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE The device identity list is in use and cannot be set or cleared."]
#[doc = " @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE The device identity list contains multiple entries with the same identity address."]
#[doc = " @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE The given device identity list size invalid (zero or too large); this can"]
#[doc = "                               only return when pp_id_keys is not NULL."]
#[inline(always)]
pub unsafe fn sd_ble_gap_device_identities_set(
    pp_id_keys: *const *const ble_gap_id_key_t,
    pp_local_irks: *const *const ble_gap_irk_t,
    len: u8,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 111",
        inout("r0") to_asm(pp_id_keys) => ret,
        inout("r1") to_asm(pp_local_irks) => _,
        inout("r2") to_asm(len) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set privacy settings."]
#[doc = ""]
#[doc = " @note  Privacy settings cannot be changed while advertising, scanning or creating a connection."]
#[doc = ""]
#[doc = " @param[in] p_privacy_params Privacy settings."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Set successfully."]
#[doc = " @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry."]
#[doc = " @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR The pointer to privacy settings is NULL or invalid."]
#[doc = "                                  Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Out of range parameters are provided."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED The SoftDevice does not support privacy if the Central Address Resolution"]
#[doc = "characteristic is not configured to be included and the SoftDevice is configured"]
#[doc = "to support central roles."]
#[doc = "See @ref ble_gap_cfg_car_incl_cfg_t and @ref ble_gap_cfg_role_count_t."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Privacy settings cannot be changed while advertising, scanning"]
#[doc = "                                   or creating a connection."]
#[inline(always)]
pub unsafe fn sd_ble_gap_privacy_set(p_privacy_params: *const ble_gap_privacy_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 112",
        inout("r0") to_asm(p_privacy_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get privacy settings."]
#[doc = ""]
#[doc = " @note ::ble_gap_privacy_params_t::p_device_irk must be initialized to NULL or a valid address before this function is called."]
#[doc = "       If it is initialized to a valid address, the address pointed to will contain the current device IRK on return."]
#[doc = ""]
#[doc = " @param[in,out] p_privacy_params Privacy settings."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS            Privacy settings read."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR The pointer given for returning the privacy settings may be NULL or invalid."]
#[doc = "                                  Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer."]
#[inline(always)]
pub unsafe fn sd_ble_gap_privacy_get(p_privacy_params: *mut ble_gap_privacy_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 113",
        inout("r0") to_asm(p_privacy_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Configure an advertising set. Set, clear or update advertising and scan response data."]
#[doc = ""]
#[doc = " @note  The format of the advertising data will be checked by this call to ensure interoperability."]
#[doc = "        Limitations imposed by this API call to the data provided include having a flags data type in the scan response data and"]
#[doc = "        duplicating the local name in the advertising data and scan response data."]
#[doc = ""]
#[doc = " @note In order to update advertising data while advertising, new advertising buffers must be provided."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_ADV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_WL_SHARE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in,out] p_adv_handle                         Provide a pointer to a handle containing @ref BLE_GAP_ADV_SET_HANDLE_NOT_SET to configure"]
#[doc = "                                                     a new advertising set. On success, a new handle is then returned through the pointer."]
#[doc = "                                                     Provide a pointer to an existing advertising handle to configure an existing advertising set."]
#[doc = " @param[in]     p_adv_data                           Advertising data. If set to NULL, no advertising data will be used. See @ref ble_gap_adv_data_t."]
#[doc = " @param[in]     p_adv_params                         Advertising parameters. When this function is used to update advertising data while advertising,"]
#[doc = "                                                     this parameter must be NULL. See @ref ble_gap_adv_params_t."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                               Advertising set successfully configured."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM                   Invalid parameter(s) supplied:"]
#[doc = "                                                      - Invalid advertising data configuration specified. See @ref ble_gap_adv_data_t."]
#[doc = "                                                      - Invalid configuration of p_adv_params. See @ref ble_gap_adv_params_t."]
#[doc = "                                                      - Use of whitelist requested but whitelist has not been set,"]
#[doc = "                                                        see @ref sd_ble_gap_whitelist_set."]
#[doc = " @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR            ble_gap_adv_params_t::p_peer_addr is invalid."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE                   Invalid state to perform operation. Either:"]
#[doc = "                                                     - It is invalid to provide non-NULL advertising set parameters while advertising."]
#[doc = "                                                     - It is invalid to provide the same data buffers while advertising. To update"]
#[doc = "                                                       advertising data, provide new advertising buffers."]
#[doc = " @retval ::BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible."]
#[doc = " @retval ::BLE_ERROR_INVALID_ADV_HANDLE              The provided advertising handle was not found. Use @ref BLE_GAP_ADV_SET_HANDLE_NOT_SET to"]
#[doc = "                                                     configure a new advertising handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR                    Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_FLAGS                   Invalid combination of advertising flags supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_DATA                    Invalid data type(s) supplied. Check the advertising data format specification"]
#[doc = "                                                     given in Bluetooth Specification Version 5.0, Volume 3, Part C, Chapter 11."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH                  Invalid data length(s) supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED                   Unsupported data length or advertising parameter configuration."]
#[doc = " @retval ::NRF_ERROR_NO_MEM                          Not enough memory to configure a new advertising handle. Update an"]
#[doc = "                                                     existing advertising handle instead."]
#[doc = " @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_set_configure(
    p_adv_handle: *mut u8,
    p_adv_data: *const ble_gap_adv_data_t,
    p_adv_params: *const ble_gap_adv_params_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 114",
        inout("r0") to_asm(p_adv_handle) => ret,
        inout("r1") to_asm(p_adv_data) => _,
        inout("r2") to_asm(p_adv_params) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure)."]
#[doc = ""]
#[doc = " @note Only one advertiser may be active at any time."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_CONNECTED, Generated after connection has been established through connectable advertising.}"]
#[doc = " @event{@ref BLE_GAP_EVT_ADV_SET_TERMINATED, Advertising set has terminated.}"]
#[doc = " @event{@ref BLE_GAP_EVT_SCAN_REQ_REPORT, A scan request was received.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_ADV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_WL_SHARE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] adv_handle   Advertising handle to advertise on, received from @ref sd_ble_gap_adv_set_configure."]
#[doc = " @param[in] conn_cfg_tag Tag identifying a configuration set by @ref sd_ble_cfg_set or"]
#[doc = "                         @ref BLE_CONN_CFG_TAG_DEFAULT to use the default connection configuration. For non-connectable"]
#[doc = "                         advertising, this is ignored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                  The BLE stack has started advertising."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE      adv_handle is not configured or already advertising."]
#[doc = " @retval ::NRF_ERROR_CONN_COUNT         The limit of available connections for this connection configuration"]
#[doc = "                                        tag has been reached; connectable advertiser cannot be started."]
#[doc = "                                        To increase the number of available connections,"]
#[doc = "                                        use @ref sd_ble_cfg_set with @ref BLE_GAP_CFG_ROLE_COUNT or @ref BLE_CONN_CFG_GAP."]
#[doc = " @retval ::BLE_ERROR_INVALID_ADV_HANDLE Advertising handle not found. Configure a new adveriting handle with @ref sd_ble_gap_adv_set_configure."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND          conn_cfg_tag not found."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM      Invalid parameter(s) supplied:"]
#[doc = "                                        - Invalid configuration of p_adv_params. See @ref ble_gap_adv_params_t."]
#[doc = "                                        - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set."]
#[doc = " @retval ::NRF_ERROR_RESOURCES          Either:"]
#[doc = "                                        - adv_handle is configured with connectable advertising, but the event_length parameter"]
#[doc = "                                          associated with conn_cfg_tag is too small to be able to establish a connection on"]
#[doc = "                                          the selected advertising phys. Use @ref sd_ble_cfg_set to increase the event length."]
#[doc = "                                        - Not enough BLE role slots available."]
#[doc = "Stop one or more currently active roles (Central, Peripheral, Broadcaster or Observer) and try again."]
#[doc = "                                        - p_adv_params is configured with connectable advertising, but the event_length parameter"]
#[doc = "                                          associated with conn_cfg_tag is too small to be able to establish a connection on"]
#[doc = "                                          the selected advertising phys. Use @ref sd_ble_cfg_set to increase the event length."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_start(adv_handle: u8, conn_cfg_tag: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 115",
        inout("r0") to_asm(adv_handle) => ret,
        inout("r1") to_asm(conn_cfg_tag) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure)."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_ADV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_WL_SHARE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] adv_handle The advertising handle that should stop advertising."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The BLE stack has stopped advertising."]
#[doc = " @retval ::BLE_ERROR_INVALID_ADV_HANDLE Invalid advertising handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE The advertising handle is not advertising."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_stop(adv_handle: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 116",
        inout("r0") to_asm(adv_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Update connection parameters."]
#[doc = ""]
#[doc = " @details In the central role this will initiate a Link Layer connection parameter update procedure,"]
#[doc = "          otherwise in the peripheral role, this will send the corresponding L2CAP request and wait for"]
#[doc = "          the central to perform the procedure. In both cases, and regardless of success or failure, the application"]
#[doc = "          will be informed of the result with a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE event."]
#[doc = ""]
#[doc = " @details This function can be used as a central both to reply to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST or to start the procedure unrequested."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_CONN_PARAM_UPDATE, Result of the connection parameter update procedure.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CPU_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_MULTILINK_CPU_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_CPU_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] p_conn_params  Pointer to desired connection parameters. If NULL is provided on a peripheral role,"]
#[doc = "                           the parameters in the PPCP characteristic of the GAP service will be used instead."]
#[doc = "                           If NULL is provided on a central role and in response to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST, the peripheral request will be rejected"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The Connection Update procedure has been started successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Disconnection in progress or link has not been established."]
#[doc = " @retval ::NRF_ERROR_BUSY Procedure already in progress, wait for pending procedures to complete and retry."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_param_update(conn_handle: u16, p_conn_params: *const ble_gap_conn_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 117",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_conn_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Disconnect (GAP Link Termination)."]
#[doc = ""]
#[doc = " @details This call initiates the disconnection procedure, and its completion will be communicated to the application"]
#[doc = "          with a @ref BLE_GAP_EVT_DISCONNECTED event."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_DISCONNECTED, Generated when disconnection procedure is complete.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CONN_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] hci_status_code HCI status code, see @ref BLE_HCI_STATUS_CODES (accepted values are @ref BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION and @ref BLE_HCI_CONN_INTERVAL_UNACCEPTABLE)."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The disconnection procedure has been started successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Disconnection in progress or link has not been established."]
#[inline(always)]
pub unsafe fn sd_ble_gap_disconnect(conn_handle: u16, hci_status_code: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 118",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(hci_status_code) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set the radio's transmit power."]
#[doc = ""]
#[doc = " @param[in] role The role to set the transmit power for, see @ref BLE_GAP_TX_POWER_ROLES for"]
#[doc = "                 possible roles."]
#[doc = " @param[in] handle   The handle parameter is interpreted depending on role:"]
#[doc = "                     - If role is @ref BLE_GAP_TX_POWER_ROLE_CONN, this value is the specific connection handle."]
#[doc = "                     - If role is @ref BLE_GAP_TX_POWER_ROLE_ADV, the advertising set identified with the advertising handle,"]
#[doc = "                       will use the specified transmit power, and include it in the advertising packet headers if"]
#[doc = "                       @ref ble_gap_adv_properties_t::include_tx_power set."]
#[doc = "                     - For all other roles handle is ignored."]
#[doc = " @param[in] tx_power Radio transmit power in dBm (see note for accepted values)."]
#[doc = ""]
#[doc = " @note Supported tx_power values: -40dBm, -20dBm, -16dBm, -12dBm, -8dBm, -4dBm, 0dBm, +2dBm, +3dBm, +4dBm, +5dBm, +6dBm, +7dBm and +8dBm."]
#[doc = " @note The initiator will have the same transmit power as the scanner."]
#[doc = " @note When a connection is created it will inherit the transmit power from the initiator or"]
#[doc = "       advertiser leading to the connection."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully changed the transmit power."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_ADV_HANDLE Advertising handle not found."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_tx_power_set(role: u8, handle: u16, tx_power: i8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 119",
        inout("r0") to_asm(role) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(tx_power) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set GAP Appearance value."]
#[doc = ""]
#[doc = " @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS  Appearance value set successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_appearance_set(appearance: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 120",
        inout("r0") to_asm(appearance) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get GAP Appearance value."]
#[doc = ""]
#[doc = " @param[out] p_appearance Pointer to appearance (16-bit) to be filled in, see @ref BLE_APPEARANCES."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Appearance value retrieved successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_appearance_get(p_appearance: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 121",
        inout("r0") to_asm(p_appearance) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set GAP Peripheral Preferred Connection Parameters."]
#[doc = ""]
#[doc = " @param[in] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure with the desired parameters."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED The characteristic is not included in the Attribute Table,"]
#[doc = "see @ref ble_gap_cfg_ppcp_incl_cfg_t."]
#[inline(always)]
pub unsafe fn sd_ble_gap_ppcp_set(p_conn_params: *const ble_gap_conn_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 122",
        inout("r0") to_asm(p_conn_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get GAP Peripheral Preferred Connection Parameters."]
#[doc = ""]
#[doc = " @param[out] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure where the parameters will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters retrieved successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED The characteristic is not included in the Attribute Table,"]
#[doc = "see @ref ble_gap_cfg_ppcp_incl_cfg_t."]
#[inline(always)]
pub unsafe fn sd_ble_gap_ppcp_get(p_conn_params: *mut ble_gap_conn_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 123",
        inout("r0") to_asm(p_conn_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set GAP device name."]
#[doc = ""]
#[doc = " @note  If the device name is located in application flash memory (see @ref ble_gap_cfg_device_name_t),"]
#[doc = "        it cannot be changed. Then @ref NRF_ERROR_FORBIDDEN will be returned."]
#[doc = ""]
#[doc = " @param[in] p_write_perm Write permissions for the Device Name characteristic, see @ref ble_gap_conn_sec_mode_t."]
#[doc = " @param[in] p_dev_name Pointer to a UTF-8 encoded, <b>non NULL-terminated</b> string."]
#[doc = " @param[in] len Length of the UTF-8, <b>non NULL-terminated</b> string pointed to by p_dev_name in octets (must be smaller or equal than @ref BLE_GAP_DEVNAME_MAX_LEN)."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS GAP device name and permissions set successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN Device name is not writable."]
#[inline(always)]
pub unsafe fn sd_ble_gap_device_name_set(
    p_write_perm: *const ble_gap_conn_sec_mode_t,
    p_dev_name: *const u8,
    len: u16,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 124",
        inout("r0") to_asm(p_write_perm) => ret,
        inout("r1") to_asm(p_dev_name) => _,
        inout("r2") to_asm(len) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get GAP device name."]
#[doc = ""]
#[doc = " @note  If the device name is longer than the size of the supplied buffer,"]
#[doc = "        p_len will return the complete device name length,"]
#[doc = "        and not the number of bytes actually returned in p_dev_name."]
#[doc = "        The application may use this information to allocate a suitable buffer size."]
#[doc = ""]
#[doc = " @param[out]    p_dev_name Pointer to an empty buffer where the UTF-8 <b>non NULL-terminated</b> string will be placed. Set to NULL to obtain the complete device name length."]
#[doc = " @param[in,out] p_len      Length of the buffer pointed by p_dev_name, complete device name length on output."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS GAP device name retrieved successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_device_name_get(p_dev_name: *mut u8, p_len: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 125",
        inout("r0") to_asm(p_dev_name) => ret,
        inout("r1") to_asm(p_len) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate the GAP Authentication procedure."]
#[doc = ""]
#[doc = " @details In the central role, this function will send an SMP Pairing Request (or an SMP Pairing Failed if rejected),"]
#[doc = "          otherwise in the peripheral role, an SMP Security Request will be sent."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{Depending on the security parameters set and the packet exchanges with the peer\\, the following events may be generated:}"]
#[doc = " @event{@ref BLE_GAP_EVT_SEC_PARAMS_REQUEST}"]
#[doc = " @event{@ref BLE_GAP_EVT_SEC_INFO_REQUEST}"]
#[doc = " @event{@ref BLE_GAP_EVT_PASSKEY_DISPLAY}"]
#[doc = " @event{@ref BLE_GAP_EVT_KEY_PRESSED}"]
#[doc = " @event{@ref BLE_GAP_EVT_AUTH_KEY_REQUEST}"]
#[doc = " @event{@ref BLE_GAP_EVT_LESC_DHKEY_REQUEST}"]
#[doc = " @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE}"]
#[doc = " @event{@ref BLE_GAP_EVT_AUTH_STATUS}"]
#[doc = " @event{@ref BLE_GAP_EVT_TIMEOUT}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_SEC_REQ_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing or bonding procedure."]
#[doc = "                         In the peripheral role, only the bond, mitm, lesc and keypress fields of this structure are used."]
#[doc = "                         In the central role, this pointer may be NULL to reject a Security Request."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully initiated authentication procedure."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:"]
#[doc = "                                   - No link has been established."]
#[doc = "                                   - An encryption is already executing or queued."]
#[doc = " @retval ::NRF_ERROR_NO_MEM The maximum number of authentication procedures that can run in parallel for the given role is reached."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported."]
#[doc = "                                   Distribution of own Identity Information is only supported if the Central"]
#[doc = "                                   Address Resolution characteristic is configured to be included or"]
#[doc = "                                   the Softdevice is configured to support peripheral roles only."]
#[doc = "                                   See @ref ble_gap_cfg_car_incl_cfg_t and @ref ble_gap_cfg_role_count_t."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT A SMP timeout has occurred, and further SMP operations on this link is prohibited."]
#[inline(always)]
pub unsafe fn sd_ble_gap_authenticate(conn_handle: u16, p_sec_params: *const ble_gap_sec_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 126",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_sec_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with GAP security parameters."]
#[doc = ""]
#[doc = " @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE."]
#[doc = " @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{This function is used during authentication procedures, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_BONDING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_PERIPH_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_PAIRING_CONFIRM_FAIL_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_PAIRING_KS_TOO_SMALL_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_PAIRING_APP_ERROR_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_PAIRING_REMOTE_PAIRING_FAIL_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_PAIRING_TIMEOUT_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] sec_status Security status, see @ref BLE_GAP_SEC_STATUS."]
#[doc = " @param[in] p_sec_params Pointer to a @ref ble_gap_sec_params_t security parameters structure. In the central role this must be set to NULL, as the parameters have"]
#[doc = "                         already been provided during a previous call to @ref sd_ble_gap_authenticate."]
#[doc = " @param[in,out] p_sec_keyset Pointer to a @ref ble_gap_sec_keyset_t security keyset structure. Any keys generated and/or distributed as a result of the ongoing security procedure"]
#[doc = "                         will be stored into the memory referenced by the pointers inside this structure. The keys will be stored and available to the application"]
#[doc = "                         upon reception of a @ref BLE_GAP_EVT_AUTH_STATUS event."]
#[doc = "                         Note that the SoftDevice expects the application to provide memory for storing the"]
#[doc = "                         peer's keys. So it must be ensured that the relevant pointers inside this structure are not NULL. The pointers to the local key"]
#[doc = "                         can, however, be NULL, in which case, the local key data will not be available to the application upon reception of the"]
#[doc = "                         @ref BLE_GAP_EVT_AUTH_STATUS event."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully accepted security parameter from the application."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Security parameters has not been requested."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported."]
#[doc = "                                   Distribution of own Identity Information is only supported if the Central"]
#[doc = "                                   Address Resolution characteristic is configured to be included or"]
#[doc = "                                   the Softdevice is configured to support peripheral roles only."]
#[doc = "                                   See @ref ble_gap_cfg_car_incl_cfg_t and @ref ble_gap_cfg_role_count_t."]
#[inline(always)]
pub unsafe fn sd_ble_gap_sec_params_reply(
    conn_handle: u16,
    sec_status: u8,
    p_sec_params: *const ble_gap_sec_params_t,
    p_sec_keyset: *const ble_gap_sec_keyset_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 127",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(sec_status) => _,
        inout("r2") to_asm(p_sec_params) => _,
        inout("r3") to_asm(p_sec_keyset) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with an authentication key."]
#[doc = ""]
#[doc = " @details This function is only used to reply to a @ref BLE_GAP_EVT_AUTH_KEY_REQUEST or a @ref BLE_GAP_EVT_PASSKEY_DISPLAY, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE."]
#[doc = " @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{This function is used during authentication procedures\\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] key_type See @ref BLE_GAP_AUTH_KEY_TYPES."]
#[doc = " @param[in] p_key If key type is @ref BLE_GAP_AUTH_KEY_TYPE_NONE, then NULL."]
#[doc = "                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY, then a 6-byte ASCII string (digit 0..9 only, no NULL termination)"]
#[doc = "                     or NULL when confirming LE Secure Connections Numeric Comparison."]
#[doc = "                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_OOB, then a 16-byte OOB key value in little-endian format."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Authentication key successfully set."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Authentication key has not been requested."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_auth_key_reply(conn_handle: u16, key_type: u8, p_key: *const u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 128",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(key_type) => _,
        inout("r2") to_asm(p_key) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with an LE Secure connections DHKey."]
#[doc = ""]
#[doc = " @details This function is only used to reply to a @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE."]
#[doc = " @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{This function is used during authentication procedures\\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] p_dhkey LE Secure Connections DHKey."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS DHKey successfully set."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:"]
#[doc = "                                   - The peer is not authenticated."]
#[doc = "                                   - The application has not pulled a @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST event."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_lesc_dhkey_reply(conn_handle: u16, p_dhkey: *const ble_gap_lesc_dhkey_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 129",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_dhkey) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Notify the peer of a local keypress."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] kp_not See @ref BLE_GAP_KP_NOT_TYPES."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Keypress notification successfully queued for transmission."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:"]
#[doc = "                                   - Authentication key not requested."]
#[doc = "                                   - Passkey has not been entered."]
#[doc = "                                   - Keypresses have not been enabled by both peers."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY The BLE stack is busy. Retry at later time."]
#[inline(always)]
pub unsafe fn sd_ble_gap_keypress_notify(conn_handle: u16, kp_not: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 130",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(kp_not) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Generate a set of OOB data to send to a peer out of band."]
#[doc = ""]
#[doc = " @note  The @ref ble_gap_addr_t included in the OOB data returned will be the currently active one (or, if a connection has already been established,"]
#[doc = "        the one used during connection setup). The application may manually overwrite it with an updated value."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle. Can be @ref BLE_CONN_HANDLE_INVALID if a BLE connection has not been established yet."]
#[doc = " @param[in] p_pk_own LE Secure Connections local P-256 Public Key."]
#[doc = " @param[out] p_oobd_own The OOB data to be sent out of band to a peer."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS OOB data successfully generated."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_lesc_oob_data_get(
    conn_handle: u16,
    p_pk_own: *const ble_gap_lesc_p256_pk_t,
    p_oobd_own: *mut ble_gap_lesc_oob_data_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 131",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_pk_own) => _,
        inout("r2") to_asm(p_oobd_own) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Provide the OOB data sent/received out of band."]
#[doc = ""]
#[doc = " @note  An authentication procedure with OOB selected as an algorithm must be in progress when calling this function."]
#[doc = " @note  A @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST event with the oobd_req set to 1 must have been received prior to calling this function."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{This function is used during authentication procedures\\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] p_oobd_own The OOB data sent out of band to a peer or NULL if the peer has not received OOB data."]
#[doc = "                       Must correspond to @ref ble_gap_sec_params_t::oob flag in @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST."]
#[doc = " @param[in] p_oobd_peer The OOB data received out of band from a peer or NULL if none received."]
#[doc = "                        Must correspond to @ref ble_gap_sec_params_t::oob flag"]
#[doc = "                        in @ref sd_ble_gap_authenticate in the central role or"]
#[doc = "                        in @ref sd_ble_gap_sec_params_reply in the peripheral role."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS OOB data accepted."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:"]
#[doc = "                                   - Authentication key not requested"]
#[doc = "                                   - Not expecting LESC OOB data"]
#[doc = "                                   - Have not actually exchanged passkeys."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_lesc_oob_data_set(
    conn_handle: u16,
    p_oobd_own: *const ble_gap_lesc_oob_data_t,
    p_oobd_peer: *const ble_gap_lesc_oob_data_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 132",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_oobd_own) => _,
        inout("r2") to_asm(p_oobd_peer) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate GAP Encryption procedure."]
#[doc = ""]
#[doc = " @details In the central role, this function will initiate the encryption procedure using the encryption information provided."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE, The connection security has been updated.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_ENC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] p_master_id Pointer to a @ref ble_gap_master_id_t master identification structure."]
#[doc = " @param[in] p_enc_info  Pointer to a @ref ble_gap_enc_info_t encryption information structure."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully initiated authentication procedure."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE No link has been established."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_ROLE Operation is not supported in the Peripheral role."]
#[doc = " @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, wait for pending procedures to complete and retry."]
#[inline(always)]
pub unsafe fn sd_ble_gap_encrypt(
    conn_handle: u16,
    p_master_id: *const ble_gap_master_id_t,
    p_enc_info: *const ble_gap_enc_info_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 133",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_master_id) => _,
        inout("r2") to_asm(p_enc_info) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with GAP security information."]
#[doc = ""]
#[doc = " @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_INFO_REQUEST, calling it at other times will result in @ref NRF_ERROR_INVALID_STATE."]
#[doc = " @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters."]
#[doc = " @note    Data signing is not yet supported, and p_sign_info must therefore be NULL."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPH_ENC_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] p_enc_info Pointer to a @ref ble_gap_enc_info_t encryption information structure. May be NULL to signal none is available."]
#[doc = " @param[in] p_id_info Pointer to a @ref ble_gap_irk_t identity information structure. May be NULL to signal none is available."]
#[doc = " @param[in] p_sign_info Pointer to a @ref ble_gap_sign_info_t signing information structure. May be NULL to signal none is available."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully accepted security information."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:"]
#[doc = "                                   - No link has been established."]
#[doc = "                                   - No @ref BLE_GAP_EVT_SEC_REQUEST pending."]
#[doc = "                                   - Encryption information provided by the app without being requested. See @ref ble_gap_evt_sec_info_request_t::enc_info."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_sec_info_reply(
    conn_handle: u16,
    p_enc_info: *const ble_gap_enc_info_t,
    p_id_info: *const ble_gap_irk_t,
    p_sign_info: *const ble_gap_sign_info_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 134",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_enc_info) => _,
        inout("r2") to_asm(p_id_info) => _,
        inout("r3") to_asm(p_sign_info) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the current connection security."]
#[doc = ""]
#[doc = " @param[in]  conn_handle Connection handle."]
#[doc = " @param[out] p_conn_sec  Pointer to a @ref ble_gap_conn_sec_t structure to be filled in."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Current connection security successfully retrieved."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_sec_get(conn_handle: u16, p_conn_sec: *mut ble_gap_conn_sec_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 135",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_conn_sec) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start reporting the received signal strength to the application."]
#[doc = ""]
#[doc = "        A new event is reported whenever the RSSI value changes, until @ref sd_ble_gap_rssi_stop is called."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_RSSI_CHANGED, New RSSI data available. How often the event is generated is"]
#[doc = "                                       dependent on the settings of the <code>threshold_dbm</code>"]
#[doc = "                                       and <code>skip_count</code> input parameters.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle        Connection handle."]
#[doc = " @param[in] threshold_dbm      Minimum change in dBm before triggering the @ref BLE_GAP_EVT_RSSI_CHANGED event. Events are disabled if threshold_dbm equals @ref BLE_GAP_RSSI_THRESHOLD_INVALID."]
#[doc = " @param[in] skip_count         Number of RSSI samples with a change of threshold_dbm or more before sending a new @ref BLE_GAP_EVT_RSSI_CHANGED event."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                   Successfully activated RSSI reporting."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is already ongoing."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_rssi_start(conn_handle: u16, threshold_dbm: u8, skip_count: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 136",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(threshold_dbm) => _,
        inout("r2") to_asm(skip_count) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Stop reporting the received signal strength."]
#[doc = ""]
#[doc = " @note  An RSSI change detected before the call but not yet received by the application"]
#[doc = "        may be reported after @ref sd_ble_gap_rssi_stop has been called."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                   Successfully deactivated RSSI reporting."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is not ongoing."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_rssi_stop(conn_handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 137",
        inout("r0") to_asm(conn_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the received signal strength for the last connection event."]
#[doc = ""]
#[doc = "        @ref sd_ble_gap_rssi_start must be called to start reporting RSSI before using this function. @ref NRF_ERROR_NOT_FOUND"]
#[doc = "        will be returned until RSSI was sampled for the first time after calling @ref sd_ble_gap_rssi_start."]
#[doc = " @note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement."]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in]  conn_handle Connection handle."]
#[doc = " @param[out] p_rssi      Pointer to the location where the RSSI measurement shall be stored."]
#[doc = " @param[out] p_ch_index  Pointer to the location where Channel Index for the RSSI measurement shall be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                   Successfully read the RSSI."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND           No sample is available."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is not ongoing."]
#[inline(always)]
pub unsafe fn sd_ble_gap_rssi_get(conn_handle: u16, p_rssi: *mut i8, p_ch_index: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 142",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_rssi) => _,
        inout("r2") to_asm(p_ch_index) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start or continue scanning (GAP Discovery procedure, Observer Procedure)."]
#[doc = ""]
#[doc = " @note    A call to this function will require the application to keep the memory pointed by"]
#[doc = "          p_adv_report_buffer alive until the buffer is released. The buffer is released when the scanner is stopped"]
#[doc = "          or when this function is called with another buffer."]
#[doc = ""]
#[doc = " @note    The scanner will automatically stop in the following cases:"]
#[doc = "           - @ref sd_ble_gap_scan_stop is called."]
#[doc = "           - @ref sd_ble_gap_connect is called."]
#[doc = "           - A @ref BLE_GAP_EVT_TIMEOUT with source set to @ref BLE_GAP_TIMEOUT_SRC_SCAN is received."]
#[doc = "           - When a @ref BLE_GAP_EVT_ADV_REPORT event is received and @ref ble_gap_adv_report_type_t::status is not set to"]
#[doc = "             @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA. In this case scanning is only paused to let the application"]
#[doc = "             access received data. The application must call this function to continue scanning, or call @ref sd_ble_gap_scan_stop"]
#[doc = "             to stop scanning."]
#[doc = ""]
#[doc = " @note    If a @ref BLE_GAP_EVT_ADV_REPORT event is received with @ref ble_gap_adv_report_type_t::status set to"]
#[doc = "          @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA, the scanner will continue scanning, and the application will"]
#[doc = "          receive more reports from this advertising event. The following reports will include the old and new received data."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_ADV_REPORT, An advertising or scan response packet has been received.}"]
#[doc = " @event{@ref BLE_GAP_EVT_TIMEOUT, Scanner has timed out.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_SCAN_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_WL_SHARE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] p_scan_params       Pointer to scan parameters structure. When this function is used to continue"]
#[doc = "                                scanning, this parameter must be NULL."]
#[doc = " @param[in] p_adv_report_buffer Pointer to buffer used to store incoming advertising data."]
#[doc = "                                The memory pointed to should be kept alive until the scanning is stopped."]
#[doc = "                                See @ref BLE_GAP_SCAN_BUFFER_SIZE for minimum and maximum buffer size."]
#[doc = "                                If the scanner receives advertising data larger than can be stored in the buffer,"]
#[doc = "                                a @ref BLE_GAP_EVT_ADV_REPORT will be raised with @ref ble_gap_adv_report_type_t::status"]
#[doc = "                                set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_TRUNCATED."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully initiated scanning procedure."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:"]
#[doc = "                                   - Scanning is already ongoing and p_scan_params was not NULL"]
#[doc = "                                   - Scanning is not running and p_scan_params was NULL."]
#[doc = "                                   - The scanner has timed out when this function is called to continue scanning."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. See @ref ble_gap_scan_params_t."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED Unsupported parameters supplied. See @ref ble_gap_scan_params_t."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH The provided buffer length is invalid. See @ref BLE_GAP_SCAN_BUFFER_MIN."]
#[doc = " @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available."]
#[doc = "                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again"]
#[inline(always)]
pub unsafe fn sd_ble_gap_scan_start(
    p_scan_params: *const ble_gap_scan_params_t,
    p_adv_report_buffer: *const ble_data_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 138",
        inout("r0") to_asm(p_scan_params) => ret,
        inout("r1") to_asm(p_adv_report_buffer) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Stop scanning (GAP Discovery procedure, Observer Procedure)."]
#[doc = ""]
#[doc = " @note The buffer provided in @ref sd_ble_gap_scan_start is released."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_SCAN_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_WL_SHARE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully stopped scanning procedure."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Not in the scanning state."]
#[inline(always)]
pub unsafe fn sd_ble_gap_scan_stop() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 139",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Create a connection (GAP Link Establishment)."]
#[doc = ""]
#[doc = " @note If a scanning procedure is currently in progress it will be automatically stopped when calling this function."]
#[doc = "       The scanning procedure will be stopped even if the function returns an error."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_CONNECTED, A connection was established.}"]
#[doc = " @event{@ref BLE_GAP_EVT_TIMEOUT, Failed to establish a connection.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_WL_SHARE_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] p_peer_addr   Pointer to peer identity address. If @ref ble_gap_scan_params_t::filter_policy is set to use"]
#[doc = "                          whitelist, then p_peer_addr is ignored."]
#[doc = " @param[in] p_scan_params Pointer to scan parameters structure."]
#[doc = " @param[in] p_conn_params Pointer to desired connection parameters."]
#[doc = " @param[in] conn_cfg_tag  Tag identifying a configuration set by @ref sd_ble_cfg_set or"]
#[doc = "                          @ref BLE_CONN_CFG_TAG_DEFAULT to use the default connection configuration."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully initiated connection procedure."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid parameter(s) pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = "                                   - Invalid parameter(s) in p_scan_params or p_conn_params."]
#[doc = "                                   - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set."]
#[doc = "                                   - Peer address was not present in the device identity list, see @ref sd_ble_gap_device_identities_set."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND conn_cfg_tag not found."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE The SoftDevice is in an invalid state to perform this operation. This may be due to an"]
#[doc = "                                   existing locally initiated connect procedure, which must complete before initiating again."]
#[doc = " @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Peer address."]
#[doc = " @retval ::NRF_ERROR_CONN_COUNT The limit of available connections for this connection configuration tag has been reached."]
#[doc = "                                To increase the number of available connections,"]
#[doc = "                                use @ref sd_ble_cfg_set with @ref BLE_GAP_CFG_ROLE_COUNT or @ref BLE_CONN_CFG_GAP."]
#[doc = " @retval ::NRF_ERROR_RESOURCES Either:"]
#[doc = "                                 - Not enough BLE role slots available."]
#[doc = "                                   Stop one or more currently active roles (Central, Peripheral or Observer) and try again."]
#[doc = "                                 - The event_length parameter associated with conn_cfg_tag is too small to be able to"]
#[doc = "                                   establish a connection on the selected @ref ble_gap_scan_params_t::scan_phys."]
#[doc = "                                   Use @ref sd_ble_cfg_set to increase the event length."]
#[inline(always)]
pub unsafe fn sd_ble_gap_connect(
    p_peer_addr: *const ble_gap_addr_t,
    p_scan_params: *const ble_gap_scan_params_t,
    p_conn_params: *const ble_gap_conn_params_t,
    conn_cfg_tag: u8,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 140",
        inout("r0") to_asm(p_peer_addr) => ret,
        inout("r1") to_asm(p_scan_params) => _,
        inout("r2") to_asm(p_conn_params) => _,
        inout("r3") to_asm(conn_cfg_tag) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Cancel a connection establishment."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully canceled an ongoing connection procedure."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE No locally initiated connect procedure started or connection"]
#[doc = "                                   completed occurred."]
#[inline(always)]
pub unsafe fn sd_ble_gap_connect_cancel() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 141",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or respond to a PHY Update Procedure"]
#[doc = ""]
#[doc = " @details   This function is used to initiate or respond to a PHY Update Procedure. It will always"]
#[doc = "            generate a @ref BLE_GAP_EVT_PHY_UPDATE event if successfully executed."]
#[doc = "            If this function is used to initiate a PHY Update procedure and the only option"]
#[doc = "            provided in @ref ble_gap_phys_t::tx_phys and @ref ble_gap_phys_t::rx_phys is the"]
#[doc = "            currently active PHYs in the respective directions, the SoftDevice will generate a"]
#[doc = "            @ref BLE_GAP_EVT_PHY_UPDATE with the current PHYs set and will not initiate the"]
#[doc = "            procedure in the Link Layer."]
#[doc = ""]
#[doc = "            If @ref ble_gap_phys_t::tx_phys or @ref ble_gap_phys_t::rx_phys is @ref BLE_GAP_PHY_AUTO,"]
#[doc = "            then the stack will select PHYs based on the peer's PHY preferences and the local link"]
#[doc = "            configuration. The PHY Update procedure will for this case result in a PHY combination"]
#[doc = "            that respects the time constraints configured with @ref sd_ble_cfg_set and the current"]
#[doc = "            link layer data length."]
#[doc = ""]
#[doc = "            When acting as a central, the SoftDevice will select the fastest common PHY in each direction."]
#[doc = ""]
#[doc = "            If the peer does not support the PHY Update Procedure, then the resulting"]
#[doc = "            @ref BLE_GAP_EVT_PHY_UPDATE event will have a status set to"]
#[doc = "            @ref BLE_HCI_UNSUPPORTED_REMOTE_FEATURE."]
#[doc = ""]
#[doc = "            If the PHY Update procedure was rejected by the peer due to a procedure collision, the status"]
#[doc = "            will be @ref BLE_HCI_STATUS_CODE_LMP_ERROR_TRANSACTION_COLLISION or"]
#[doc = "            @ref BLE_HCI_DIFFERENT_TRANSACTION_COLLISION."]
#[doc = "            If the peer responds to the PHY Update procedure with invalid parameters, the status"]
#[doc = "            will be @ref BLE_HCI_STATUS_CODE_INVALID_LMP_PARAMETERS."]
#[doc = "            If the PHY Update procedure was rejected by the peer for a different reason, the status will"]
#[doc = "            contain the reason as specified by the peer."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GAP_EVT_PHY_UPDATE, Result of the PHY Update Procedure.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_CENTRAL_PHY_UPDATE}"]
#[doc = " @mmsc{@ref BLE_GAP_PERIPHERAL_PHY_UPDATE}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle   Connection handle to indicate the connection for which the PHY Update is requested."]
#[doc = " @param[in] p_gap_phys    Pointer to PHY structure."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully requested a PHY Update."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE No link has been established."]
#[doc = " @retval ::NRF_ERROR_RESOURCES The connection event length configured for this link is not sufficient for the combination of"]
#[doc = "                               @ref ble_gap_phys_t::tx_phys, @ref ble_gap_phys_t::rx_phys, and @ref ble_gap_data_length_params_t."]
#[doc = "                               The connection event length is configured with @ref BLE_CONN_CFG_GAP using @ref sd_ble_cfg_set."]
#[doc = " @retval ::NRF_ERROR_BUSY Procedure is already in progress or not allowed at this time. Process pending events and wait for the pending procedure to complete and retry."]
#[doc = ""]
#[inline(always)]
pub unsafe fn sd_ble_gap_phy_update(conn_handle: u16, p_gap_phys: *const ble_gap_phys_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 143",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_gap_phys) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or respond to a Data Length Update Procedure."]
#[doc = ""]
#[doc = " @note If the application uses @ref BLE_GAP_DATA_LENGTH_AUTO for one or more members of"]
#[doc = "       p_dl_params, the SoftDevice will choose the highest value supported in current"]
#[doc = "       configuration and connection parameters."]
#[doc = " @note  If the link PHY is Coded, the SoftDevice will ensure that the MaxTxTime and/or MaxRxTime"]
#[doc = "        used in the Data Length Update procedure is at least 2704 us. Otherwise, MaxTxTime and"]
#[doc = "        MaxRxTime will be limited to maximum 2120 us."]
#[doc = ""]
#[doc = " @param[in]   conn_handle       Connection handle."]
#[doc = " @param[in]   p_dl_params       Pointer to local parameters to be used in Data Length Update"]
#[doc = "                                Procedure. Set any member to @ref BLE_GAP_DATA_LENGTH_AUTO to let"]
#[doc = "                                the SoftDevice automatically decide the value for that member."]
#[doc = "                                Set to NULL to use automatic values for all members."]
#[doc = " @param[out]  p_dl_limitation   Pointer to limitation to be written when local device does not"]
#[doc = "                                have enough resources or does not support the requested Data Length"]
#[doc = "                                Update parameters. Ignored if NULL."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GAP_DATA_LENGTH_UPDATE_PROCEDURE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully set Data Length Extension initiation/response parameters."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE No link has been established."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameters supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED The requested parameters are not supported by the SoftDevice. Inspect"]
#[doc = "                                   p_dl_limitation to see which parameter is not supported."]
#[doc = " @retval ::NRF_ERROR_RESOURCES The connection event length configured for this link is not sufficient for the requested parameters."]
#[doc = "                               Use @ref sd_ble_cfg_set with @ref BLE_CONN_CFG_GAP to increase the connection event length."]
#[doc = "                               Inspect p_dl_limitation to see where the limitation is."]
#[doc = " @retval ::NRF_ERROR_BUSY Peer has already initiated a Data Length Update Procedure. Process the"]
#[doc = "                          pending @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST event to respond."]
#[inline(always)]
pub unsafe fn sd_ble_gap_data_length_update(
    conn_handle: u16,
    p_dl_params: *const ble_gap_data_length_params_t,
    p_dl_limitation: *mut ble_gap_data_length_limitation_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 144",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_dl_params) => _,
        inout("r2") to_asm(p_dl_limitation) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Start the Quality of Service (QoS) channel survey module."]
#[doc = ""]
#[doc = " @details The channel survey module provides measurements of the energy levels on"]
#[doc = "          the Bluetooth Low Energy channels. When the module is enabled, @ref BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT"]
#[doc = "          events will periodically report the measured energy levels for each channel."]
#[doc = ""]
#[doc = " @note    The measurements are scheduled with lower priority than other Bluetooth Low Energy roles,"]
#[doc = "          Radio Timeslot API events and Flash API events."]
#[doc = ""]
#[doc = " @note    The channel survey module will attempt to do measurements so that the average interval"]
#[doc = "          between measurements will be interval_us. However due to the channel survey module"]
#[doc = "          having the lowest priority of all roles and modules, this may not be possible. In that"]
#[doc = "          case fewer than expected channel survey reports may be given."]
#[doc = ""]
#[doc = " @note    In order to use the channel survey module, @ref ble_gap_cfg_role_count_t::qos_channel_survey_role_available"]
#[doc = "          must be set. This is done using @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @param[in]   interval_us      Requested average interval for the measurements and reports. See"]
#[doc = "                               @ref BLE_GAP_QOS_CHANNEL_SURVEY_INTERVALS for valid ranges. If set"]
#[doc = "                               to @ref BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_CONTINUOUS, the channel"]
#[doc = "                               survey role will be scheduled at every available opportunity."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS             The module is successfully started."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter supplied. interval_us is out of the"]
#[doc = "                                   allowed range."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Trying to start the module when already running."]
#[doc = " @retval ::NRF_ERROR_RESOURCES     The channel survey module is not available to the application."]
#[doc = "                                   Set @ref ble_gap_cfg_role_count_t::qos_channel_survey_role_available using"]
#[doc = "                                   @ref sd_ble_cfg_set."]
#[inline(always)]
pub unsafe fn sd_ble_gap_qos_channel_survey_start(interval_us: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 145",
        inout("r0") to_asm(interval_us) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Stop the Quality of Service (QoS) channel survey module."]
#[doc = ""]
#[doc = " @note    The SoftDevice may generate one @ref BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT event after this"]
#[doc = "          function is called."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS             The module is successfully stopped."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Trying to stop the module when it is not running."]
#[inline(always)]
pub unsafe fn sd_ble_gap_qos_channel_survey_stop() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 146",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Obtain the next connection event counter value."]
#[doc = ""]
#[doc = " @details The connection event counter is initialized to zero on the first connection event. The value is incremented"]
#[doc = "          by one for each connection event. For more information see Bluetooth Core Specification v5.0, Vol 6, Part B,"]
#[doc = "          Section 4.5.1."]
#[doc = ""]
#[doc = " @note    The connection event counter obtained through this API will be outdated if this API is called"]
#[doc = "          at the same time as the connection event counter is incremented."]
#[doc = ""]
#[doc = " @note    This API will always return the last connection event counter + 1."]
#[doc = "          The actual connection event may be multiple connection events later if:"]
#[doc = "           - Slave latency is enabled and there is no data to transmit or receive."]
#[doc = "           - Another role is scheduled with a higher priority at the same time as the next connection event."]
#[doc = ""]
#[doc = " @param[in]   conn_handle       Connection handle."]
#[doc = " @param[out]  p_counter         Pointer to the variable where the next connection event counter will be written."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                   The connection event counter was successfully retrieved."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_next_conn_evt_counter_get(conn_handle: u16, p_counter: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 148",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_counter) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Start triggering a given task on connection event start."]
#[doc = ""]
#[doc = " @details When enabled, this feature will trigger a PPI task at the start of connection events."]
#[doc = "          The application can configure the SoftDevice to trigger every N connection events starting from"]
#[doc = "          a given connection event counter. See also @ref ble_gap_conn_event_trigger_t."]
#[doc = ""]
#[doc = " @param[in]   conn_handle   Connection handle."]
#[doc = " @param[in]   p_params      Connection event trigger parameters."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                   Success."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM       Invalid parameter supplied. See @ref ble_gap_conn_event_trigger_t."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE       Either:"]
#[doc = "                                         - Trying to start connection event triggering when it is already ongoing."]
#[doc = "                                         - @ref ble_gap_conn_event_trigger_t::conn_evt_counter_start is in the past."]
#[doc = "                                           Use @ref sd_ble_gap_next_conn_evt_counter_get to find a new value"]
#[doc = "to be used as ble_gap_conn_event_trigger_t::conn_evt_counter_start."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_evt_trigger_start(
    conn_handle: u16,
    p_params: *const ble_gap_conn_event_trigger_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 149",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Stop triggering the task configured using @ref sd_ble_gap_conn_evt_trigger_start."]
#[doc = ""]
#[doc = " @param[in]   conn_handle   Connection handle."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                   Success."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE       Trying to stop connection event triggering when it is not enabled."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_evt_trigger_stop(conn_handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 150",
        inout("r0") to_asm(conn_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< Set up an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_SETUP: BLE_L2CAP_SVCS = 184;
#[doc = "< Release an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_RELEASE: BLE_L2CAP_SVCS = 185;
#[doc = "< Receive an SDU on an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_RX: BLE_L2CAP_SVCS = 186;
#[doc = "< Transmit an SDU on an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_TX: BLE_L2CAP_SVCS = 187;
#[doc = "< Advanced SDU reception flow control."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_FLOW_CONTROL: BLE_L2CAP_SVCS = 188;
#[doc = "@brief L2CAP API SVC numbers."]
pub type BLE_L2CAP_SVCS = self::c_uint;
#[doc = "< L2CAP Channel Setup Request event."]
#[doc = "\\n See @ref ble_l2cap_evt_ch_setup_request_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SETUP_REQUEST: BLE_L2CAP_EVTS = 112;
#[doc = "< L2CAP Channel Setup Refused event."]
#[doc = "\\n See @ref ble_l2cap_evt_ch_setup_refused_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SETUP_REFUSED: BLE_L2CAP_EVTS = 113;
#[doc = "< L2CAP Channel Setup Completed event."]
#[doc = "\\n See @ref ble_l2cap_evt_ch_setup_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SETUP: BLE_L2CAP_EVTS = 114;
#[doc = "< L2CAP Channel Released event."]
#[doc = "\\n No additional event structure applies."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_RELEASED: BLE_L2CAP_EVTS = 115;
#[doc = "< L2CAP Channel SDU data buffer released event."]
#[doc = "\\n See @ref ble_l2cap_evt_ch_sdu_buf_released_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED: BLE_L2CAP_EVTS = 116;
#[doc = "< L2CAP Channel Credit received."]
#[doc = "\\n See @ref ble_l2cap_evt_ch_credit_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_CREDIT: BLE_L2CAP_EVTS = 117;
#[doc = "< L2CAP Channel SDU received."]
#[doc = "\\n See @ref ble_l2cap_evt_ch_rx_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_RX: BLE_L2CAP_EVTS = 118;
#[doc = "< L2CAP Channel SDU transmitted."]
#[doc = "\\n See @ref ble_l2cap_evt_ch_tx_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_TX: BLE_L2CAP_EVTS = 119;
#[doc = "@brief L2CAP Event IDs."]
pub type BLE_L2CAP_EVTS = self::c_uint;
#[doc = " @brief BLE L2CAP connection configuration parameters, set with @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @note  These parameters are set per connection, so all L2CAP channels created on this connection"]
#[doc = "        will have the same parameters."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:"]
#[doc = "                                    - rx_mps is smaller than @ref BLE_L2CAP_MPS_MIN."]
#[doc = "                                    - tx_mps is smaller than @ref BLE_L2CAP_MPS_MIN."]
#[doc = "                                    - ch_count is greater than @ref BLE_L2CAP_CH_COUNT_MAX."]
#[doc = " @retval ::NRF_ERROR_NO_MEM         rx_mps or tx_mps is set too high."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_conn_cfg_t {
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall"]
    #[doc = "be able to receive on L2CAP channels on connections with this"]
    #[doc = "configuration. The minimum value is @ref BLE_L2CAP_MPS_MIN."]
    pub rx_mps: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall"]
    #[doc = "be able to transmit on L2CAP channels on connections with this"]
    #[doc = "configuration. The minimum value is @ref BLE_L2CAP_MPS_MIN."]
    pub tx_mps: u16,
    #[doc = "< Number of SDU data buffers that can be queued for reception per"]
    #[doc = "L2CAP channel. The minimum value is one."]
    pub rx_queue_size: u8,
    #[doc = "< Number of SDU data buffers that can be queued for transmission"]
    #[doc = "per L2CAP channel. The minimum value is one."]
    pub tx_queue_size: u8,
    #[doc = "< Number of L2CAP channels the application can create per connection"]
    #[doc = "with this configuration. The default value is zero, the maximum"]
    #[doc = "value is @ref BLE_L2CAP_CH_COUNT_MAX."]
    #[doc = "@note if this parameter is set to zero, all other parameters in"]
    #[doc = "@ref ble_l2cap_conn_cfg_t are ignored."]
    pub ch_count: u8,
}
#[test]
fn bindgen_test_layout_ble_l2cap_conn_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_conn_cfg_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_l2cap_conn_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_conn_cfg_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_l2cap_conn_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_conn_cfg_t>())).rx_mps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_conn_cfg_t),
            "::",
            stringify!(rx_mps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_conn_cfg_t>())).tx_mps as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_conn_cfg_t),
            "::",
            stringify!(tx_mps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_conn_cfg_t>())).rx_queue_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_conn_cfg_t),
            "::",
            stringify!(rx_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_conn_cfg_t>())).tx_queue_size as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_conn_cfg_t),
            "::",
            stringify!(tx_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_conn_cfg_t>())).ch_count as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_conn_cfg_t),
            "::",
            stringify!(ch_count)
        )
    );
}
#[doc = "@brief L2CAP channel RX parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_ch_rx_params_t {
    #[doc = "< The maximum L2CAP SDU size, in bytes, that L2CAP shall be able to"]
    #[doc = "receive on this L2CAP channel."]
    #[doc = "- Must be equal to or greater than @ref BLE_L2CAP_MTU_MIN."]
    pub rx_mtu: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall be"]
    #[doc = "able to receive on this L2CAP channel."]
    #[doc = "- Must be equal to or greater than @ref BLE_L2CAP_MPS_MIN."]
    #[doc = "- Must be equal to or less than @ref ble_l2cap_conn_cfg_t::rx_mps."]
    pub rx_mps: u16,
    #[doc = "< SDU data buffer for reception."]
    #[doc = "- If @ref ble_data_t::p_data is non-NULL, initial credits are"]
    #[doc = "issued to the peer."]
    #[doc = "- If @ref ble_data_t::p_data is NULL, no initial credits are"]
    #[doc = "issued to the peer."]
    pub sdu_buf: ble_data_t,
}
#[test]
fn bindgen_test_layout_ble_l2cap_ch_rx_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_ch_rx_params_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_l2cap_ch_rx_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_ch_rx_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_l2cap_ch_rx_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_rx_params_t>())).rx_mtu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_rx_params_t),
            "::",
            stringify!(rx_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_rx_params_t>())).rx_mps as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_rx_params_t),
            "::",
            stringify!(rx_mps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_rx_params_t>())).sdu_buf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_rx_params_t),
            "::",
            stringify!(sdu_buf)
        )
    );
}
#[doc = "@brief L2CAP channel setup parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_ch_setup_params_t {
    #[doc = "< L2CAP channel RX parameters."]
    pub rx_params: ble_l2cap_ch_rx_params_t,
    #[doc = "< LE Protocol/Service Multiplexer. Used when requesting"]
    #[doc = "setup of an L2CAP channel, ignored otherwise."]
    pub le_psm: u16,
    #[doc = "< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES."]
    #[doc = "Used when replying to a setup request of an L2CAP"]
    #[doc = "channel, ignored otherwise."]
    pub status: u16,
}
#[test]
fn bindgen_test_layout_ble_l2cap_ch_setup_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_ch_setup_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_l2cap_ch_setup_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_ch_setup_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_l2cap_ch_setup_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_setup_params_t>())).rx_params as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_setup_params_t),
            "::",
            stringify!(rx_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_setup_params_t>())).le_psm as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_setup_params_t),
            "::",
            stringify!(le_psm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_setup_params_t>())).status as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_setup_params_t),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@brief L2CAP channel TX parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_ch_tx_params_t {
    #[doc = "< The maximum L2CAP SDU size, in bytes, that L2CAP is able to"]
    #[doc = "transmit on this L2CAP channel."]
    pub tx_mtu: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that the peer is"]
    #[doc = "able to receive on this L2CAP channel."]
    pub peer_mps: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP is able"]
    #[doc = "to transmit on this L2CAP channel. This is effective tx_mps,"]
    #[doc = "selected by the SoftDevice as"]
    #[doc = "MIN( @ref ble_l2cap_ch_tx_params_t::peer_mps, @ref ble_l2cap_conn_cfg_t::tx_mps )"]
    pub tx_mps: u16,
    #[doc = "< Initial credits given by the peer."]
    pub credits: u16,
}
#[test]
fn bindgen_test_layout_ble_l2cap_ch_tx_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_ch_tx_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_l2cap_ch_tx_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_ch_tx_params_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_l2cap_ch_tx_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_tx_params_t>())).tx_mtu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_tx_params_t),
            "::",
            stringify!(tx_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_tx_params_t>())).peer_mps as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_tx_params_t),
            "::",
            stringify!(peer_mps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_tx_params_t>())).tx_mps as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_tx_params_t),
            "::",
            stringify!(tx_mps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_ch_tx_params_t>())).credits as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_ch_tx_params_t),
            "::",
            stringify!(credits)
        )
    );
}
#[doc = "@brief L2CAP Channel Setup Request event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_setup_request_t {
    #[doc = "< L2CAP channel TX parameters."]
    pub tx_params: ble_l2cap_ch_tx_params_t,
    #[doc = "< LE Protocol/Service Multiplexer."]
    pub le_psm: u16,
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_ch_setup_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_ch_setup_request_t>(),
        10usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_ch_setup_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_ch_setup_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_ch_setup_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_setup_request_t>())).tx_params as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_setup_request_t),
            "::",
            stringify!(tx_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_setup_request_t>())).le_psm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_setup_request_t),
            "::",
            stringify!(le_psm)
        )
    );
}
#[doc = "@brief L2CAP Channel Setup Refused event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_setup_refused_t {
    #[doc = "< Source, see @ref BLE_L2CAP_CH_SETUP_REFUSED_SRCS"]
    pub source: u8,
    #[doc = "< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES"]
    pub status: u16,
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_ch_setup_refused_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_ch_setup_refused_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_ch_setup_refused_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_ch_setup_refused_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_ch_setup_refused_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_setup_refused_t>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_setup_refused_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_setup_refused_t>())).status as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_setup_refused_t),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "@brief L2CAP Channel Setup Completed event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_setup_t {
    #[doc = "< L2CAP channel TX parameters."]
    pub tx_params: ble_l2cap_ch_tx_params_t,
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_ch_setup_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_ch_setup_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_ch_setup_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_ch_setup_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_ch_setup_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_setup_t>())).tx_params as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_setup_t),
            "::",
            stringify!(tx_params)
        )
    );
}
#[doc = "@brief L2CAP Channel SDU Data Buffer Released event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_sdu_buf_released_t {
    #[doc = "< Returned reception or transmission SDU data buffer. The SoftDevice"]
    #[doc = "returns SDU data buffers supplied by the application, which have"]
    #[doc = "not yet been returned previously via a @ref BLE_L2CAP_EVT_CH_RX or"]
    #[doc = "@ref BLE_L2CAP_EVT_CH_TX event."]
    pub sdu_buf: ble_data_t,
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_ch_sdu_buf_released_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_ch_sdu_buf_released_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_ch_sdu_buf_released_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_ch_sdu_buf_released_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_ch_sdu_buf_released_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_sdu_buf_released_t>())).sdu_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_sdu_buf_released_t),
            "::",
            stringify!(sdu_buf)
        )
    );
}
#[doc = "@brief L2CAP Channel Credit received event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_credit_t {
    #[doc = "< Additional credits given by the peer."]
    pub credits: u16,
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_ch_credit_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_ch_credit_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_ch_credit_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_ch_credit_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_ch_credit_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_credit_t>())).credits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_credit_t),
            "::",
            stringify!(credits)
        )
    );
}
#[doc = "@brief L2CAP Channel received SDU event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_rx_t {
    #[doc = "< Total SDU length, in bytes."]
    pub sdu_len: u16,
    #[doc = "< SDU data buffer."]
    #[doc = "@note If there is not enough space in the buffer"]
    #[doc = "(sdu_buf.len < sdu_len) then the rest of the SDU will be"]
    #[doc = "silently discarded by the SoftDevice."]
    pub sdu_buf: ble_data_t,
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_ch_rx_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_ch_rx_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_ch_rx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_ch_rx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_ch_rx_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_rx_t>())).sdu_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_rx_t),
            "::",
            stringify!(sdu_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_rx_t>())).sdu_buf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_rx_t),
            "::",
            stringify!(sdu_buf)
        )
    );
}
#[doc = "@brief L2CAP Channel transmitted SDU event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_tx_t {
    #[doc = "< SDU data buffer."]
    pub sdu_buf: ble_data_t,
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_ch_tx_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_ch_tx_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_ch_tx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_ch_tx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_ch_tx_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_ch_tx_t>())).sdu_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_ch_tx_t),
            "::",
            stringify!(sdu_buf)
        )
    );
}
#[doc = "@brief L2CAP event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_l2cap_evt_t {
    #[doc = "< Connection Handle on which the event occured."]
    pub conn_handle: u16,
    #[doc = "< Local Channel ID of the L2CAP channel, or"]
    #[doc = "@ref BLE_L2CAP_CID_INVALID if not present."]
    pub local_cid: u16,
    #[doc = "< Event Parameters."]
    pub params: ble_l2cap_evt_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_l2cap_evt_t__bindgen_ty_1 {
    #[doc = "< L2CAP Channel Setup Request Event Parameters."]
    pub ch_setup_request: ble_l2cap_evt_ch_setup_request_t,
    #[doc = "< L2CAP Channel Setup Refused Event Parameters."]
    pub ch_setup_refused: ble_l2cap_evt_ch_setup_refused_t,
    #[doc = "< L2CAP Channel Setup Completed Event Parameters."]
    pub ch_setup: ble_l2cap_evt_ch_setup_t,
    #[doc = "< L2CAP Channel SDU Data Buffer Released Event Parameters."]
    pub ch_sdu_buf_released: ble_l2cap_evt_ch_sdu_buf_released_t,
    #[doc = "< L2CAP Channel Credit Received Event Parameters."]
    pub credit: ble_l2cap_evt_ch_credit_t,
    #[doc = "< L2CAP Channel SDU Received Event Parameters."]
    pub rx: ble_l2cap_evt_ch_rx_t,
    #[doc = "< L2CAP Channel SDU Transmitted Event Parameters."]
    pub tx: ble_l2cap_evt_ch_tx_t,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t__bindgen_ty_1>())).ch_setup_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t__bindgen_ty_1),
            "::",
            stringify!(ch_setup_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t__bindgen_ty_1>())).ch_setup_refused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t__bindgen_ty_1),
            "::",
            stringify!(ch_setup_refused)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t__bindgen_ty_1>())).ch_setup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t__bindgen_ty_1),
            "::",
            stringify!(ch_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t__bindgen_ty_1>())).ch_sdu_buf_released as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t__bindgen_ty_1),
            "::",
            stringify!(ch_sdu_buf_released)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t__bindgen_ty_1>())).credit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t__bindgen_ty_1),
            "::",
            stringify!(credit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t__bindgen_ty_1>())).rx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t__bindgen_ty_1),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t__bindgen_ty_1>())).tx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t__bindgen_ty_1),
            "::",
            stringify!(tx)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_l2cap_evt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_l2cap_evt_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_l2cap_evt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_l2cap_evt_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_l2cap_evt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t>())).local_cid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t),
            "::",
            stringify!(local_cid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_l2cap_evt_t>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_l2cap_evt_t),
            "::",
            stringify!(params)
        )
    );
}

#[doc = "@brief Set up an L2CAP channel."]
#[doc = ""]
#[doc = " @details This function is used to:"]
#[doc = "          - Request setup of an L2CAP channel: sends an LE Credit Based Connection Request packet to a peer."]
#[doc = "          - Reply to a setup request of an L2CAP channel (if called in response to a"]
#[doc = "            @ref BLE_L2CAP_EVT_CH_SETUP_REQUEST event): sends an LE Credit Based Connection"]
#[doc = "            Response packet to a peer."]
#[doc = ""]
#[doc = " @note    A call to this function will require the application to keep the SDU data buffer alive"]
#[doc = "          until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_RX or"]
#[doc = "          @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_L2CAP_EVT_CH_SETUP, Setup successful.}"]
#[doc = " @event{@ref BLE_L2CAP_EVT_CH_SETUP_REFUSED, Setup failed.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_L2CAP_CH_SETUP_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle      Connection Handle."]
#[doc = " @param[in,out] p_local_cid  Pointer to a uint16_t containing Local Channel ID of the L2CAP channel:"]
#[doc = "                             - As input: @ref BLE_L2CAP_CID_INVALID when requesting setup of an L2CAP"]
#[doc = "                               channel or local_cid provided in the @ref BLE_L2CAP_EVT_CH_SETUP_REQUEST"]
#[doc = "                               event when replying to a setup request of an L2CAP channel."]
#[doc = "                             - As output: local_cid for this channel."]
#[doc = " @param[in] p_params         L2CAP channel parameters."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                    Successfully queued request or response for transmission."]
#[doc = " @retval ::NRF_ERROR_BUSY                 The stack is busy, process pending events and retry."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM        Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH       Supplied higher rx_mps than has been configured on this link."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (L2CAP channel already set up)."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND            CID not found."]
#[doc = " @retval ::NRF_ERROR_RESOURCES            The limit has been reached for available L2CAP channels,"]
#[doc = "                                          see @ref ble_l2cap_conn_cfg_t::ch_count."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_setup(
    conn_handle: u16,
    p_local_cid: *mut u16,
    p_params: *const ble_l2cap_ch_setup_params_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 184",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_local_cid) => _,
        inout("r2") to_asm(p_params) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Release an L2CAP channel."]
#[doc = ""]
#[doc = " @details This sends a Disconnection Request packet to a peer."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_L2CAP_EVT_CH_RELEASED, Release complete.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_L2CAP_CH_RELEASE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle   Connection Handle."]
#[doc = " @param[in] local_cid     Local Channel ID of the L2CAP channel."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                    Successfully queued request for transmission."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is"]
#[doc = "                                          in progress for the L2CAP channel)."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND            CID not found."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_release(conn_handle: u16, local_cid: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 185",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Receive an SDU on an L2CAP channel."]
#[doc = ""]
#[doc = " @details This may issue additional credits to the peer using an LE Flow Control Credit packet."]
#[doc = ""]
#[doc = " @note    A call to this function will require the application to keep the memory pointed by"]
#[doc = "          @ref ble_data_t::p_data alive until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_RX"]
#[doc = "          or @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event."]
#[doc = ""]
#[doc = " @note    The SoftDevice can queue up to @ref ble_l2cap_conn_cfg_t::rx_queue_size SDU data buffers"]
#[doc = "          for reception per L2CAP channel."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_L2CAP_EVT_CH_RX, The SDU is received.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_L2CAP_CH_RX_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection Handle."]
#[doc = " @param[in] local_cid   Local Channel ID of the L2CAP channel."]
#[doc = " @param[in] p_sdu_buf   Pointer to the SDU data buffer."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                    Buffer accepted."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is"]
#[doc = "                                          in progress for an L2CAP channel)."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND            CID not found."]
#[doc = " @retval ::NRF_ERROR_RESOURCES            Too many SDU data buffers supplied. Wait for a"]
#[doc = "                                          @ref BLE_L2CAP_EVT_CH_RX event and retry."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_rx(conn_handle: u16, local_cid: u16, p_sdu_buf: *const ble_data_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 186",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        inout("r2") to_asm(p_sdu_buf) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Transmit an SDU on an L2CAP channel."]
#[doc = ""]
#[doc = " @note    A call to this function will require the application to keep the memory pointed by"]
#[doc = "          @ref ble_data_t::p_data alive until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_TX"]
#[doc = "          or @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event."]
#[doc = ""]
#[doc = " @note    The SoftDevice can queue up to @ref ble_l2cap_conn_cfg_t::tx_queue_size SDUs for"]
#[doc = "          transmission per L2CAP channel."]
#[doc = ""]
#[doc = " @note    The application can keep track of the available credits for transmission by following"]
#[doc = "          the procedure below:"]
#[doc = "          - Store initial credits given by the peer in a variable."]
#[doc = "            (Initial credits are provided in a @ref BLE_L2CAP_EVT_CH_SETUP event.)"]
#[doc = "          - Decrement the variable, which stores the currently available credits, by"]
#[doc = "            ceiling((@ref ble_data_t::len + 2) / tx_mps) when a call to this function returns"]
#[doc = "            @ref NRF_SUCCESS. (tx_mps is provided in a @ref BLE_L2CAP_EVT_CH_SETUP event.)"]
#[doc = "          - Increment the variable, which stores the currently available credits, by additional"]
#[doc = "            credits given by the peer in a @ref BLE_L2CAP_EVT_CH_CREDIT event."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_L2CAP_EVT_CH_TX, The SDU is transmitted.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_L2CAP_CH_TX_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection Handle."]
#[doc = " @param[in] local_cid   Local Channel ID of the L2CAP channel."]
#[doc = " @param[in] p_sdu_buf   Pointer to the SDU data buffer."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                    Successfully queued L2CAP SDU for transmission."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is"]
#[doc = "                                          in progress for the L2CAP channel)."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND            CID not found."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE            Invalid SDU length supplied, must not be more than"]
#[doc = "                                          @ref ble_l2cap_ch_tx_params_t::tx_mtu provided in"]
#[doc = "                                          @ref BLE_L2CAP_EVT_CH_SETUP event."]
#[doc = " @retval ::NRF_ERROR_RESOURCES            Too many SDUs queued for transmission. Wait for a"]
#[doc = "                                          @ref BLE_L2CAP_EVT_CH_TX event and retry."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_tx(conn_handle: u16, local_cid: u16, p_sdu_buf: *const ble_data_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 187",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        inout("r2") to_asm(p_sdu_buf) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Advanced SDU reception flow control."]
#[doc = ""]
#[doc = " @details Adjust the way the SoftDevice issues credits to the peer."]
#[doc = "          This may issue additional credits to the peer using an LE Flow Control Credit packet."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_L2CAP_CH_FLOW_CONTROL_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection Handle."]
#[doc = " @param[in] local_cid   Local Channel ID of the L2CAP channel or @ref BLE_L2CAP_CID_INVALID to set"]
#[doc = "                        the value that will be used for newly created channels."]
#[doc = " @param[in] credits     Number of credits that the SoftDevice will make sure the peer has every"]
#[doc = "                        time it starts using a new reception buffer."]
#[doc = "                        - @ref BLE_L2CAP_CREDITS_DEFAULT is the default value the SoftDevice will"]
#[doc = "                          use if this function is not called."]
#[doc = "                        - If set to zero, the SoftDevice will stop issuing credits for new reception"]
#[doc = "                          buffers the application provides or has provided. SDU reception that is"]
#[doc = "                          currently ongoing will be allowed to complete."]
#[doc = " @param[out] p_credits  NULL or pointer to a uint16_t. If a valid pointer is provided, it will be"]
#[doc = "                        written by the SoftDevice with the number of credits that is or will be"]
#[doc = "                        available to the peer. If the value written by the SoftDevice is 0 when"]
#[doc = "                        credits parameter was set to 0, the peer will not be able to send more"]
#[doc = "                        data until more credits are provided by calling this function again with"]
#[doc = "                        credits > 0. This parameter is ignored when local_cid is set to"]
#[doc = "                        @ref BLE_L2CAP_CID_INVALID."]
#[doc = ""]
#[doc = " @note Application should take care when setting number of credits higher than default value. In"]
#[doc = "       this case the application must make sure that the SoftDevice always has reception buffers"]
#[doc = "       available (see @ref sd_ble_l2cap_ch_rx) for that channel. If the SoftDevice does not have"]
#[doc = "       such buffers available, packets may be NACKed on the Link Layer and all Bluetooth traffic"]
#[doc = "       on the connection handle may be stalled until the SoftDevice again has an available"]
#[doc = "       reception buffer. This applies even if the application has used this call to set the"]
#[doc = "       credits back to default, or zero."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS                    Flow control parameters accepted."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is"]
#[doc = "                                          in progress for an L2CAP channel)."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND            CID not found."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_flow_control(conn_handle: u16, local_cid: u16, credits: u16, p_credits: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 188",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        inout("r2") to_asm(credits) => _,
        inout("r3") to_asm(p_credits) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = " @brief BLE GATT connection configuration parameters, set with @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM att_mtu is smaller than @ref BLE_GATT_ATT_MTU_DEFAULT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_conn_cfg_t {
    #[doc = "< Maximum size of ATT packet the SoftDevice can send or receive."]
    #[doc = "The default and minimum value is @ref BLE_GATT_ATT_MTU_DEFAULT."]
    #[doc = "@mscs"]
    #[doc = "@mmsc{@ref BLE_GATTC_MTU_EXCHANGE}"]
    #[doc = "@mmsc{@ref BLE_GATTS_MTU_EXCHANGE}"]
    #[doc = "@endmscs"]
    pub att_mtu: u16,
}
#[test]
fn bindgen_test_layout_ble_gatt_conn_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatt_conn_cfg_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gatt_conn_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatt_conn_cfg_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatt_conn_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatt_conn_cfg_t>())).att_mtu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatt_conn_cfg_t),
            "::",
            stringify!(att_mtu)
        )
    );
}
#[doc = "@brief GATT Characteristic Properties."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_char_props_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gatt_char_props_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatt_char_props_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gatt_char_props_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatt_char_props_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatt_char_props_t))
    );
}
impl ble_gatt_char_props_t {
    #[inline]
    pub fn broadcast(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_broadcast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_wo_resp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_wo_resp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn notify(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_notify(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indicate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indicate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auth_signed_wr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_signed_wr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        broadcast: u8,
        read: u8,
        write_wo_resp: u8,
        write: u8,
        notify: u8,
        indicate: u8,
        auth_signed_wr: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let broadcast: u8 = unsafe { ::core::mem::transmute(broadcast) };
            broadcast as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let read: u8 = unsafe { ::core::mem::transmute(read) };
            read as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let write_wo_resp: u8 = unsafe { ::core::mem::transmute(write_wo_resp) };
            write_wo_resp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write: u8 = unsafe { ::core::mem::transmute(write) };
            write as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let notify: u8 = unsafe { ::core::mem::transmute(notify) };
            notify as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let indicate: u8 = unsafe { ::core::mem::transmute(indicate) };
            indicate as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let auth_signed_wr: u8 = unsafe { ::core::mem::transmute(auth_signed_wr) };
            auth_signed_wr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT Characteristic Extended Properties."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_char_ext_props_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gatt_char_ext_props_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatt_char_ext_props_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gatt_char_ext_props_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatt_char_ext_props_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatt_char_ext_props_t))
    );
}
impl ble_gatt_char_ext_props_t {
    #[inline]
    pub fn reliable_wr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reliable_wr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_aux(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wr_aux(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reliable_wr: u8, wr_aux: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reliable_wr: u8 = unsafe { ::core::mem::transmute(reliable_wr) };
            reliable_wr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wr_aux: u8 = unsafe { ::core::mem::transmute(wr_aux) };
            wr_aux as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Primary Service Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER: BLE_GATTC_SVCS = 155;
#[doc = "< Relationship Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_RELATIONSHIPS_DISCOVER: BLE_GATTC_SVCS = 156;
#[doc = "< Characteristic Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_CHARACTERISTICS_DISCOVER: BLE_GATTC_SVCS = 157;
#[doc = "< Characteristic Descriptor Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_DESCRIPTORS_DISCOVER: BLE_GATTC_SVCS = 158;
#[doc = "< Attribute Information Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_ATTR_INFO_DISCOVER: BLE_GATTC_SVCS = 159;
#[doc = "< Read Characteristic Value by UUID."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ: BLE_GATTC_SVCS = 160;
#[doc = "< Generic read."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_READ: BLE_GATTC_SVCS = 161;
#[doc = "< Read multiple Characteristic Values."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_CHAR_VALUES_READ: BLE_GATTC_SVCS = 162;
#[doc = "< Generic write."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_WRITE: BLE_GATTC_SVCS = 163;
#[doc = "< Handle Value Confirmation."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_HV_CONFIRM: BLE_GATTC_SVCS = 164;
#[doc = "< Exchange MTU Request."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_EXCHANGE_MTU_REQUEST: BLE_GATTC_SVCS = 165;
#[doc = "@brief GATTC API SVC numbers."]
pub type BLE_GATTC_SVCS = self::c_uint;
#[doc = "< Primary Service Discovery Response event.          \\n See @ref ble_gattc_evt_prim_srvc_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP: BLE_GATTC_EVTS = 48;
#[doc = "< Relationship Discovery Response event.             \\n See @ref ble_gattc_evt_rel_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_REL_DISC_RSP: BLE_GATTC_EVTS = 49;
#[doc = "< Characteristic Discovery Response event.           \\n See @ref ble_gattc_evt_char_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_CHAR_DISC_RSP: BLE_GATTC_EVTS = 50;
#[doc = "< Descriptor Discovery Response event.               \\n See @ref ble_gattc_evt_desc_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_DESC_DISC_RSP: BLE_GATTC_EVTS = 51;
#[doc = "< Attribute Information Response event.              \\n See @ref ble_gattc_evt_attr_info_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_ATTR_INFO_DISC_RSP: BLE_GATTC_EVTS = 52;
#[doc = "< Read By UUID Response event.                       \\n See @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP: BLE_GATTC_EVTS = 53;
#[doc = "< Read Response event.                               \\n See @ref ble_gattc_evt_read_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_READ_RSP: BLE_GATTC_EVTS = 54;
#[doc = "< Read multiple Response event.                      \\n See @ref ble_gattc_evt_char_vals_read_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_CHAR_VALS_READ_RSP: BLE_GATTC_EVTS = 55;
#[doc = "< Write Response event.                              \\n See @ref ble_gattc_evt_write_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_WRITE_RSP: BLE_GATTC_EVTS = 56;
#[doc = "< Handle Value Notification or Indication event.     \\n Confirm indication with @ref sd_ble_gattc_hv_confirm.  \\n See @ref ble_gattc_evt_hvx_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_HVX: BLE_GATTC_EVTS = 57;
#[doc = "< Exchange MTU Response event.                       \\n See @ref ble_gattc_evt_exchange_mtu_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_EXCHANGE_MTU_RSP: BLE_GATTC_EVTS = 58;
#[doc = "< Timeout event.                                     \\n See @ref ble_gattc_evt_timeout_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_TIMEOUT: BLE_GATTC_EVTS = 59;
#[doc = "< Write without Response transmission complete.      \\n See @ref ble_gattc_evt_write_cmd_tx_complete_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE: BLE_GATTC_EVTS = 60;
#[doc = " @brief GATT Client Event IDs."]
pub type BLE_GATTC_EVTS = self::c_uint;
#[doc = " @brief BLE GATTC connection configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_conn_cfg_t {
    #[doc = "< The guaranteed minimum number of Write without Response that can be queued for transmission."]
    #[doc = "The default value is @ref BLE_GATTC_WRITE_CMD_TX_QUEUE_SIZE_DEFAULT"]
    pub write_cmd_tx_queue_size: u8,
}
#[test]
fn bindgen_test_layout_ble_gattc_conn_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_conn_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gattc_conn_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_conn_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gattc_conn_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_conn_cfg_t>())).write_cmd_tx_queue_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_conn_cfg_t),
            "::",
            stringify!(write_cmd_tx_queue_size)
        )
    );
}
#[doc = "@brief Operation Handle Range."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_handle_range_t {
    #[doc = "< Start Handle."]
    pub start_handle: u16,
    #[doc = "< End Handle."]
    pub end_handle: u16,
}
#[test]
fn bindgen_test_layout_ble_gattc_handle_range_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_handle_range_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gattc_handle_range_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_handle_range_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_handle_range_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_handle_range_t>())).start_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_handle_range_t),
            "::",
            stringify!(start_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_handle_range_t>())).end_handle as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_handle_range_t),
            "::",
            stringify!(end_handle)
        )
    );
}
#[doc = "@brief GATT service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_service_t {
    #[doc = "< Service UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Service Handle Range."]
    pub handle_range: ble_gattc_handle_range_t,
}
#[test]
fn bindgen_test_layout_ble_gattc_service_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_service_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gattc_service_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_service_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_service_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_service_t>())).uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_service_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_service_t>())).handle_range as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_service_t),
            "::",
            stringify!(handle_range)
        )
    );
}
#[doc = "@brief  GATT include."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_include_t {
    #[doc = "< Include Handle."]
    pub handle: u16,
    #[doc = "< Handle of the included service."]
    pub included_srvc: ble_gattc_service_t,
}
#[test]
fn bindgen_test_layout_ble_gattc_include_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_include_t>(),
        10usize,
        concat!("Size of: ", stringify!(ble_gattc_include_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_include_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_include_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_include_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_include_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_include_t>())).included_srvc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_include_t),
            "::",
            stringify!(included_srvc)
        )
    );
}
#[doc = "@brief GATT characteristic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_char_t {
    #[doc = "< Characteristic UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Characteristic Properties."]
    pub char_props: ble_gatt_char_props_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Handle of the Characteristic Declaration."]
    pub handle_decl: u16,
    #[doc = "< Handle of the Characteristic Value."]
    pub handle_value: u16,
}
#[test]
fn bindgen_test_layout_ble_gattc_char_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_char_t>(),
        10usize,
        concat!("Size of: ", stringify!(ble_gattc_char_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_char_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_char_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_char_t>())).uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_char_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_char_t>())).char_props as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_char_t),
            "::",
            stringify!(char_props)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_char_t>())).handle_decl as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_char_t),
            "::",
            stringify!(handle_decl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_char_t>())).handle_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_char_t),
            "::",
            stringify!(handle_value)
        )
    );
}
impl ble_gattc_char_t {
    #[inline]
    pub fn char_ext_props(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_char_ext_props(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(char_ext_props: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let char_ext_props: u8 = unsafe { ::core::mem::transmute(char_ext_props) };
            char_ext_props as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_desc_t {
    #[doc = "< Descriptor Handle."]
    pub handle: u16,
    #[doc = "< Descriptor UUID."]
    pub uuid: ble_uuid_t,
}
#[test]
fn bindgen_test_layout_ble_gattc_desc_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_desc_t>(),
        6usize,
        concat!("Size of: ", stringify!(ble_gattc_desc_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_desc_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_desc_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_desc_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_desc_t>())).uuid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_desc_t),
            "::",
            stringify!(uuid)
        )
    );
}
#[doc = "@brief Write Parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_write_params_t {
    #[doc = "< Write Operation to be performed, see @ref BLE_GATT_WRITE_OPS."]
    pub write_op: u8,
    #[doc = "< Flags, see @ref BLE_GATT_EXEC_WRITE_FLAGS."]
    pub flags: u8,
    #[doc = "< Handle to the attribute to be written."]
    pub handle: u16,
    #[doc = "< Offset in bytes. @note For WRITE_CMD and WRITE_REQ, offset must be 0."]
    pub offset: u16,
    #[doc = "< Length of data in bytes."]
    pub len: u16,
    #[doc = "< Pointer to the value data."]
    pub p_value: *const u8,
}
#[test]
fn bindgen_test_layout_ble_gattc_write_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_write_params_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_gattc_write_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_write_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gattc_write_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_write_params_t>())).write_op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_write_params_t),
            "::",
            stringify!(write_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_write_params_t>())).flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_write_params_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_write_params_t>())).handle as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_write_params_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_write_params_t>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_write_params_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_write_params_t>())).len as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_write_params_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_write_params_t>())).p_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_write_params_t),
            "::",
            stringify!(p_value)
        )
    );
}
#[doc = "@brief Attribute Information for 16-bit Attribute UUID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_attr_info16_t {
    #[doc = "< Attribute handle."]
    pub handle: u16,
    #[doc = "< 16-bit Attribute UUID."]
    pub uuid: ble_uuid_t,
}
#[test]
fn bindgen_test_layout_ble_gattc_attr_info16_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_attr_info16_t>(),
        6usize,
        concat!("Size of: ", stringify!(ble_gattc_attr_info16_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_attr_info16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_attr_info16_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_attr_info16_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_attr_info16_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_attr_info16_t>())).uuid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_attr_info16_t),
            "::",
            stringify!(uuid)
        )
    );
}
#[doc = "@brief Attribute Information for 128-bit Attribute UUID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_attr_info128_t {
    #[doc = "< Attribute handle."]
    pub handle: u16,
    #[doc = "< 128-bit Attribute UUID."]
    pub uuid: ble_uuid128_t,
}
#[test]
fn bindgen_test_layout_ble_gattc_attr_info128_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_attr_info128_t>(),
        18usize,
        concat!("Size of: ", stringify!(ble_gattc_attr_info128_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_attr_info128_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_attr_info128_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_attr_info128_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_attr_info128_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_attr_info128_t>())).uuid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_attr_info128_t),
            "::",
            stringify!(uuid)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_prim_srvc_disc_rsp_t {
    #[doc = "< Service count."]
    pub count: u16,
    #[doc = "< Service data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub services: __IncompleteArrayField<ble_gattc_service_t>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_prim_srvc_disc_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_prim_srvc_disc_rsp_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_prim_srvc_disc_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_prim_srvc_disc_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_prim_srvc_disc_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_prim_srvc_disc_rsp_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_prim_srvc_disc_rsp_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_prim_srvc_disc_rsp_t>())).services as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_prim_srvc_disc_rsp_t),
            "::",
            stringify!(services)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_REL_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_rel_disc_rsp_t {
    #[doc = "< Include count."]
    pub count: u16,
    #[doc = "< Include data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub includes: __IncompleteArrayField<ble_gattc_include_t>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_rel_disc_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_rel_disc_rsp_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_rel_disc_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_rel_disc_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_rel_disc_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_rel_disc_rsp_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_rel_disc_rsp_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_rel_disc_rsp_t>())).includes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_rel_disc_rsp_t),
            "::",
            stringify!(includes)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_CHAR_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_char_disc_rsp_t {
    #[doc = "< Characteristic count."]
    pub count: u16,
    #[doc = "< Characteristic data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub chars: __IncompleteArrayField<ble_gattc_char_t>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_char_disc_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_char_disc_rsp_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_char_disc_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_char_disc_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_char_disc_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_char_disc_rsp_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_char_disc_rsp_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_char_disc_rsp_t>())).chars as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_char_disc_rsp_t),
            "::",
            stringify!(chars)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_DESC_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_desc_disc_rsp_t {
    #[doc = "< Descriptor count."]
    pub count: u16,
    #[doc = "< Descriptor data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub descs: __IncompleteArrayField<ble_gattc_desc_t>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_desc_disc_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_desc_disc_rsp_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_desc_disc_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_desc_disc_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_desc_disc_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_desc_disc_rsp_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_desc_disc_rsp_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_desc_disc_rsp_t>())).descs as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_desc_disc_rsp_t),
            "::",
            stringify!(descs)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP."]
#[repr(C)]
pub struct ble_gattc_evt_attr_info_disc_rsp_t {
    #[doc = "< Attribute count."]
    pub count: u16,
    #[doc = "< Attribute information format, see @ref BLE_GATTC_ATTR_INFO_FORMAT."]
    pub format: u8,
    #[doc = "< Attribute information union."]
    pub info: ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1 {
    #[doc = "< Attribute information for 16-bit Attribute UUID."]
    #[doc = "@note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub attr_info16: __BindgenUnionField<[ble_gattc_attr_info16_t; 0usize]>,
    #[doc = "< Attribute information for 128-bit Attribute UUID."]
    #[doc = "@note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub attr_info128: __BindgenUnionField<[ble_gattc_attr_info128_t; 0usize]>,
    pub bindgen_union_field: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1>(),
        0usize,
        concat!(
            "Size of: ",
            stringify!(ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1>())).attr_info16 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1),
            "::",
            stringify!(attr_info16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1>())).attr_info128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1),
            "::",
            stringify!(attr_info128)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_attr_info_disc_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_attr_info_disc_rsp_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_attr_info_disc_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_attr_info_disc_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_attr_info_disc_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_attr_info_disc_rsp_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_attr_info_disc_rsp_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_attr_info_disc_rsp_t>())).format as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_attr_info_disc_rsp_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_attr_info_disc_rsp_t>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_attr_info_disc_rsp_t),
            "::",
            stringify!(info)
        )
    );
}
#[doc = "@brief GATT read by UUID handle value pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_handle_value_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Pointer to the Attribute Value, length is available in @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t::value_len."]
    pub p_value: *mut u8,
}
#[test]
fn bindgen_test_layout_ble_gattc_handle_value_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_handle_value_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gattc_handle_value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_handle_value_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gattc_handle_value_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_handle_value_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_handle_value_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_handle_value_t>())).p_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_handle_value_t),
            "::",
            stringify!(p_value)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_char_val_by_uuid_read_rsp_t {
    #[doc = "< Handle-Value Pair Count."]
    pub count: u16,
    #[doc = "< Length of the value in Handle-Value(s) list."]
    pub value_len: u16,
    #[doc = "< Handle-Value(s) list. To iterate through the list use @ref sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter."]
    #[doc = "@note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub handle_value: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_char_val_by_uuid_read_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_char_val_by_uuid_read_rsp_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_char_val_by_uuid_read_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_char_val_by_uuid_read_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_char_val_by_uuid_read_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_char_val_by_uuid_read_rsp_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_char_val_by_uuid_read_rsp_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gattc_evt_char_val_by_uuid_read_rsp_t>())).value_len as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_char_val_by_uuid_read_rsp_t),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gattc_evt_char_val_by_uuid_read_rsp_t>())).handle_value as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_char_val_by_uuid_read_rsp_t),
            "::",
            stringify!(handle_value)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_READ_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_read_rsp_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Offset of the attribute data."]
    pub offset: u16,
    #[doc = "< Attribute data length."]
    pub len: u16,
    #[doc = "< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_read_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_read_rsp_t>(),
        6usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_read_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_read_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_read_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_read_rsp_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_read_rsp_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_read_rsp_t>())).offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_read_rsp_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_read_rsp_t>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_read_rsp_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_read_rsp_t>())).data as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_read_rsp_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_char_vals_read_rsp_t {
    #[doc = "< Concatenated Attribute values length."]
    pub len: u16,
    #[doc = "< Attribute values. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub values: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_char_vals_read_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_char_vals_read_rsp_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_char_vals_read_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_char_vals_read_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_char_vals_read_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_char_vals_read_rsp_t>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_char_vals_read_rsp_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_char_vals_read_rsp_t>())).values as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_char_vals_read_rsp_t),
            "::",
            stringify!(values)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_WRITE_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_write_rsp_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Type of write operation, see @ref BLE_GATT_WRITE_OPS."]
    pub write_op: u8,
    #[doc = "< Data offset."]
    pub offset: u16,
    #[doc = "< Data length."]
    pub len: u16,
    #[doc = "< Data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_write_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_write_rsp_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_write_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_write_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_write_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_write_rsp_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_write_rsp_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_write_rsp_t>())).write_op as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_write_rsp_t),
            "::",
            stringify!(write_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_write_rsp_t>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_write_rsp_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_write_rsp_t>())).len as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_write_rsp_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_write_rsp_t>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_write_rsp_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_HVX."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_hvx_t {
    #[doc = "< Handle to which the HVx operation applies."]
    pub handle: u16,
    #[doc = "< Indication or Notification, see @ref BLE_GATT_HVX_TYPES."]
    pub type_: u8,
    #[doc = "< Attribute data length."]
    pub len: u16,
    #[doc = "< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_hvx_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_hvx_t>(),
        6usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_hvx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_hvx_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_hvx_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_hvx_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_hvx_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_hvx_t>())).type_ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_hvx_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_hvx_t>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_hvx_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_hvx_t>())).data as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_hvx_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_evt_exchange_mtu_rsp_t {
    #[doc = "< Server RX MTU size."]
    pub server_rx_mtu: u16,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_exchange_mtu_rsp_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_exchange_mtu_rsp_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_exchange_mtu_rsp_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_exchange_mtu_rsp_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_exchange_mtu_rsp_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_exchange_mtu_rsp_t>())).server_rx_mtu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_exchange_mtu_rsp_t),
            "::",
            stringify!(server_rx_mtu)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_TIMEOUT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_evt_timeout_t {
    #[doc = "< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES."]
    pub src: u8,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_timeout_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_timeout_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_timeout_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_timeout_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_timeout_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_timeout_t>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_timeout_t),
            "::",
            stringify!(src)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_evt_write_cmd_tx_complete_t {
    #[doc = "< Number of write without response transmissions completed."]
    pub count: u8,
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_write_cmd_tx_complete_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_write_cmd_tx_complete_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_write_cmd_tx_complete_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_write_cmd_tx_complete_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_write_cmd_tx_complete_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_write_cmd_tx_complete_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_write_cmd_tx_complete_t),
            "::",
            stringify!(count)
        )
    );
}
#[doc = "@brief GATTC event structure."]
#[repr(C)]
pub struct ble_gattc_evt_t {
    #[doc = "< Connection Handle on which event occurred."]
    pub conn_handle: u16,
    #[doc = "< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES."]
    pub gatt_status: u16,
    #[doc = "< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID."]
    pub error_handle: u16,
    #[doc = "< Event Parameters. @note Only valid if @ref gatt_status == @ref BLE_GATT_STATUS_SUCCESS."]
    pub params: ble_gattc_evt_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gattc_evt_t__bindgen_ty_1 {
    #[doc = "< Primary Service Discovery Response Event Parameters."]
    pub prim_srvc_disc_rsp: __BindgenUnionField<ble_gattc_evt_prim_srvc_disc_rsp_t>,
    #[doc = "< Relationship Discovery Response Event Parameters."]
    pub rel_disc_rsp: __BindgenUnionField<ble_gattc_evt_rel_disc_rsp_t>,
    #[doc = "< Characteristic Discovery Response Event Parameters."]
    pub char_disc_rsp: __BindgenUnionField<ble_gattc_evt_char_disc_rsp_t>,
    #[doc = "< Descriptor Discovery Response Event Parameters."]
    pub desc_disc_rsp: __BindgenUnionField<ble_gattc_evt_desc_disc_rsp_t>,
    #[doc = "< Characteristic Value Read by UUID Response Event Parameters."]
    pub char_val_by_uuid_read_rsp: __BindgenUnionField<ble_gattc_evt_char_val_by_uuid_read_rsp_t>,
    #[doc = "< Read Response Event Parameters."]
    pub read_rsp: __BindgenUnionField<ble_gattc_evt_read_rsp_t>,
    #[doc = "< Characteristic Values Read Response Event Parameters."]
    pub char_vals_read_rsp: __BindgenUnionField<ble_gattc_evt_char_vals_read_rsp_t>,
    #[doc = "< Write Response Event Parameters."]
    pub write_rsp: __BindgenUnionField<ble_gattc_evt_write_rsp_t>,
    #[doc = "< Handle Value Notification/Indication Event Parameters."]
    pub hvx: __BindgenUnionField<ble_gattc_evt_hvx_t>,
    #[doc = "< Exchange MTU Response Event Parameters."]
    pub exchange_mtu_rsp: __BindgenUnionField<ble_gattc_evt_exchange_mtu_rsp_t>,
    #[doc = "< Timeout Event Parameters."]
    pub timeout: __BindgenUnionField<ble_gattc_evt_timeout_t>,
    #[doc = "< Attribute Information Discovery Event Parameters."]
    pub attr_info_disc_rsp: __BindgenUnionField<ble_gattc_evt_attr_info_disc_rsp_t>,
    #[doc = "< Write without Response transmission complete Event Parameters."]
    pub write_cmd_tx_complete: __BindgenUnionField<ble_gattc_evt_write_cmd_tx_complete_t>,
    pub bindgen_union_field: [u16; 4usize],
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).prim_srvc_disc_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(prim_srvc_disc_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).rel_disc_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(rel_disc_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).char_disc_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(char_disc_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).desc_disc_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(desc_disc_rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).char_val_by_uuid_read_rsp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(char_val_by_uuid_read_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).read_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(read_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).char_vals_read_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(char_vals_read_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).write_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(write_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).hvx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(hvx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).exchange_mtu_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(exchange_mtu_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).attr_info_disc_rsp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(attr_info_disc_rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gattc_evt_t__bindgen_ty_1>())).write_cmd_tx_complete as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t__bindgen_ty_1),
            "::",
            stringify!(write_cmd_tx_complete)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_gattc_evt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gattc_evt_t>(),
        14usize,
        concat!("Size of: ", stringify!(ble_gattc_evt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gattc_evt_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gattc_evt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t>())).gatt_status as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t),
            "::",
            stringify!(gatt_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t>())).error_handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t),
            "::",
            stringify!(error_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gattc_evt_t>())).params as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gattc_evt_t),
            "::",
            stringify!(params)
        )
    );
}

#[doc = "@brief Initiate or continue a GATT Primary Service Discovery procedure."]
#[doc = ""]
#[doc = " @details This function initiates or resumes a Primary Service discovery procedure, starting from the supplied handle."]
#[doc = "          If the last service has not been reached, this function must be called again with an updated start handle value to continue the search."]
#[doc = ""]
#[doc = " @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with"]
#[doc = "       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_PRIM_SRVC_DISC_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] start_handle Handle to start searching from."]
#[doc = " @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started or resumed the Primary Service Discovery procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_primary_services_discover(
    conn_handle: u16,
    start_handle: u16,
    p_srvc_uuid: *const ble_uuid_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 155",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(start_handle) => _,
        inout("r2") to_asm(p_srvc_uuid) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Relationship Discovery procedure."]
#[doc = ""]
#[doc = " @details This function initiates or resumes the Find Included Services sub-procedure. If the last included service has not been reached,"]
#[doc = "          this must be called again with an updated handle range to continue the search."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_REL_DISC_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_REL_DISC_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started or resumed the Relationship Discovery procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_relationships_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 156",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Characteristic Discovery procedure."]
#[doc = ""]
#[doc = " @details This function initiates or resumes a Characteristic discovery procedure. If the last Characteristic has not been reached,"]
#[doc = "          this must be called again with an updated handle range to continue the discovery."]
#[doc = ""]
#[doc = " @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with"]
#[doc = "       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_CHAR_DISC_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_CHAR_DISC_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started or resumed the Characteristic Discovery procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_characteristics_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 157",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Characteristic Descriptor Discovery procedure."]
#[doc = ""]
#[doc = " @details This function initiates or resumes a Characteristic Descriptor discovery procedure. If the last Descriptor has not been reached,"]
#[doc = "          this must be called again with an updated handle range to continue the discovery."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_DESC_DISC_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_DESC_DISC_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] p_handle_range A pointer to the range of handles of the Characteristic to perform this procedure on."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started or resumed the Descriptor Discovery procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_descriptors_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 158",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Read using Characteristic UUID procedure."]
#[doc = ""]
#[doc = " @details This function initiates or resumes a Read using Characteristic UUID procedure. If the last Characteristic has not been reached,"]
#[doc = "          this must be called again with an updated handle range to continue the discovery."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_READ_UUID_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] p_uuid Pointer to a Characteristic value UUID to read."]
#[doc = " @param[in] p_handle_range A pointer to the range of handles to perform this procedure on."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_char_value_by_uuid_read(
    conn_handle: u16,
    p_uuid: *const ble_uuid_t,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 160",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_uuid) => _,
        inout("r2") to_asm(p_handle_range) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure."]
#[doc = ""]
#[doc = " @details This function initiates or resumes a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor"]
#[doc = "          to be read is longer than ATT_MTU - 1, this function must be called multiple times with appropriate offset to read the"]
#[doc = "          complete value."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_READ_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_VALUE_READ_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] handle The handle of the attribute to be read."]
#[doc = " @param[in] offset Offset into the attribute value to be read."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started or resumed the Read (Long) procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_read(conn_handle: u16, handle: u16, offset: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 161",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(offset) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate a GATT Read Multiple Characteristic Values procedure."]
#[doc = ""]
#[doc = " @details This function initiates a GATT Read Multiple Characteristic Values procedure."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_READ_MULT_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read."]
#[doc = " @param[in] handle_count The number of handles in p_handles."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_char_values_read(conn_handle: u16, p_handles: *const u16, handle_count: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 162",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handles) => _,
        inout("r2") to_asm(handle_count) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Perform a Write (Characteristic Value or Descriptor, with or without response, signed or not, long or reliable) procedure."]
#[doc = ""]
#[doc = " @details This function can perform all write procedures described in GATT."]
#[doc = ""]
#[doc = " @note    Only one write with response procedure can be ongoing per connection at a time."]
#[doc = "          If the application tries to write with response while another write with response procedure is ongoing,"]
#[doc = "          the function call will return @ref NRF_ERROR_BUSY."]
#[doc = "          A @ref BLE_GATTC_EVT_WRITE_RSP event will be issued as soon as the write response arrives from the peer."]
#[doc = ""]
#[doc = " @note    The number of Write without Response that can be queued is configured by @ref ble_gattc_conn_cfg_t::write_cmd_tx_queue_size"]
#[doc = "          When the queue is full, the function call will return @ref NRF_ERROR_RESOURCES."]
#[doc = "          A @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event will be issued as soon as the transmission of the write without response is complete."]
#[doc = ""]
#[doc = " @note    The application can keep track of the available queue element count for writes without responses by following the procedure below:"]
#[doc = "          - Store initial queue element count in a variable."]
#[doc = "          - Decrement the variable, which stores the currently available queue element count, by one when a call to this function returns @ref NRF_SUCCESS."]
#[doc = "          - Increment the variable, which stores the current available queue element count, by the count variable in @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE, Write without response transmission complete.}"]
#[doc = " @event{@ref BLE_GATTC_EVT_WRITE_RSP, Write response received from the peer.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_VALUE_WRITE_WITHOUT_RESP_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTC_VALUE_WRITE_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTC_VALUE_LONG_WRITE_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTC_VALUE_RELIABLE_WRITE_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] p_write_params A pointer to a write parameters structure."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started the Write procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY For write with response, procedure already in progress. Wait for a @ref BLE_GATTC_EVT_WRITE_RSP event and retry."]
#[doc = " @retval ::NRF_ERROR_RESOURCES Too many writes without responses queued."]
#[doc = "                               Wait for a @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event and retry."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_write(conn_handle: u16, p_write_params: *const ble_gattc_write_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 163",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_write_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Send a Handle Value Confirmation to the GATT Server."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_HVI_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] handle The handle of the attribute in the indication."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully queued the Handle Value Confirmation for transmission."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no Indication pending to be confirmed."]
#[doc = " @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_hv_confirm(conn_handle: u16, handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 164",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Discovers information about a range of attributes on a GATT server."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP, Generated when information about a range of attributes has been received.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] p_handle_range The range of handles to request information about."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully started an attribute information discovery procedure."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid connection state"]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR  Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_attr_info_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 159",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start an ATT_MTU exchange by sending an Exchange MTU Request to the server."]
#[doc = ""]
#[doc = " @details The SoftDevice sets ATT_MTU to the minimum of:"]
#[doc = "          - The Client RX MTU value, and"]
#[doc = "          - The Server RX MTU value from @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP."]
#[doc = ""]
#[doc = "          However, the SoftDevice never sets ATT_MTU lower than @ref BLE_GATT_ATT_MTU_DEFAULT."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] client_rx_mtu  Client RX MTU size."]
#[doc = "                           - The minimum value is @ref BLE_GATT_ATT_MTU_DEFAULT."]
#[doc = "                           - The maximum value is @ref ble_gatt_conn_cfg_t::att_mtu in the connection configuration"]
#[doc = "used for this connection."]
#[doc = "                           - The value must be equal to Server RX MTU size given in @ref sd_ble_gatts_exchange_mtu_reply"]
#[doc = "                             if an ATT_MTU exchange has already been performed in the other direction."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully sent request to the server."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid connection state or an ATT_MTU exchange was already requested once."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid Client RX MTU size supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY Client procedure already in progress."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_exchange_mtu_request(conn_handle: u16, client_rx_mtu: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 165",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(client_rx_mtu) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< Add a service."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SERVICE_ADD: BLE_GATTS_SVCS = 168;
#[doc = "< Add an included service."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_INCLUDE_ADD: BLE_GATTS_SVCS = 169;
#[doc = "< Add a characteristic."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_CHARACTERISTIC_ADD: BLE_GATTS_SVCS = 170;
#[doc = "< Add a generic attribute."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_DESCRIPTOR_ADD: BLE_GATTS_SVCS = 171;
#[doc = "< Set an attribute value."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_VALUE_SET: BLE_GATTS_SVCS = 172;
#[doc = "< Get an attribute value."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_VALUE_GET: BLE_GATTS_SVCS = 173;
#[doc = "< Handle Value Notification or Indication."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_HVX: BLE_GATTS_SVCS = 174;
#[doc = "< Perform a Service Changed Indication to one or more peers."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SERVICE_CHANGED: BLE_GATTS_SVCS = 175;
#[doc = "< Reply to an authorization request for a read or write operation on one or more attributes."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_RW_AUTHORIZE_REPLY: BLE_GATTS_SVCS = 176;
#[doc = "< Set the persistent system attributes for a connection."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SYS_ATTR_SET: BLE_GATTS_SVCS = 177;
#[doc = "< Retrieve the persistent system attributes."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SYS_ATTR_GET: BLE_GATTS_SVCS = 178;
#[doc = "< Retrieve the first valid user handle."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_INITIAL_USER_HANDLE_GET: BLE_GATTS_SVCS = 179;
#[doc = "< Retrieve the UUID and/or metadata of an attribute."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_ATTR_GET: BLE_GATTS_SVCS = 180;
#[doc = "< Reply to Exchange MTU Request."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_EXCHANGE_MTU_REPLY: BLE_GATTS_SVCS = 181;
#[doc = " @brief GATTS API SVC numbers."]
pub type BLE_GATTS_SVCS = self::c_uint;
#[doc = "< Write operation performed.                                           \\n See @ref ble_gatts_evt_write_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_WRITE: BLE_GATTS_EVTS = 80;
#[doc = "< Read/Write Authorization request.                                    \\n Reply with @ref sd_ble_gatts_rw_authorize_reply. \\n See @ref ble_gatts_evt_rw_authorize_request_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST: BLE_GATTS_EVTS = 81;
#[doc = "< A persistent system attribute access is pending.                     \\n Respond with @ref sd_ble_gatts_sys_attr_set.     \\n See @ref ble_gatts_evt_sys_attr_missing_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_SYS_ATTR_MISSING: BLE_GATTS_EVTS = 82;
#[doc = "< Handle Value Confirmation.                                           \\n See @ref ble_gatts_evt_hvc_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_HVC: BLE_GATTS_EVTS = 83;
#[doc = "< Service Changed Confirmation.                                        \\n No additional event structure applies."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_SC_CONFIRM: BLE_GATTS_EVTS = 84;
#[doc = "< Exchange MTU Request.                                                \\n Reply with @ref sd_ble_gatts_exchange_mtu_reply. \\n See @ref ble_gatts_evt_exchange_mtu_request_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST: BLE_GATTS_EVTS = 85;
#[doc = "< Peer failed to respond to an ATT request in time.                    \\n See @ref ble_gatts_evt_timeout_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_TIMEOUT: BLE_GATTS_EVTS = 86;
#[doc = "< Handle Value Notification transmission complete.                     \\n See @ref ble_gatts_evt_hvn_tx_complete_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_HVN_TX_COMPLETE: BLE_GATTS_EVTS = 87;
#[doc = " @brief GATT Server Event IDs."]
pub type BLE_GATTS_EVTS = self::c_uint;
#[doc = "< Service changed configuration."]
pub const BLE_GATTS_CFGS_BLE_GATTS_CFG_SERVICE_CHANGED: BLE_GATTS_CFGS = 160;
#[doc = "< Attribute table size configuration."]
pub const BLE_GATTS_CFGS_BLE_GATTS_CFG_ATTR_TAB_SIZE: BLE_GATTS_CFGS = 161;
#[doc = "@brief GATTS Configuration IDs."]
#[doc = ""]
#[doc = " IDs that uniquely identify a GATTS configuration."]
pub type BLE_GATTS_CFGS = self::c_uint;
#[doc = " @brief BLE GATTS connection configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_conn_cfg_t {
    #[doc = "< Minimum guaranteed number of Handle Value Notifications that can be queued for transmission."]
    #[doc = "The default value is @ref BLE_GATTS_HVN_TX_QUEUE_SIZE_DEFAULT"]
    pub hvn_tx_queue_size: u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_conn_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_conn_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gatts_conn_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_conn_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatts_conn_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_conn_cfg_t>())).hvn_tx_queue_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_conn_cfg_t),
            "::",
            stringify!(hvn_tx_queue_size)
        )
    );
}
#[doc = "@brief Attribute metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_attr_md_t {
    #[doc = "< Read permissions."]
    pub read_perm: ble_gap_conn_sec_mode_t,
    #[doc = "< Write permissions."]
    pub write_perm: ble_gap_conn_sec_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gatts_attr_md_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_attr_md_t>(),
        3usize,
        concat!("Size of: ", stringify!(ble_gatts_attr_md_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_attr_md_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatts_attr_md_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_md_t>())).read_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_md_t),
            "::",
            stringify!(read_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_md_t>())).write_perm as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_md_t),
            "::",
            stringify!(write_perm)
        )
    );
}
impl ble_gatts_attr_md_t {
    #[inline]
    pub fn vlen(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlen(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vloc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_vloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_auth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rd_auth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_auth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wr_auth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vlen: u8, vloc: u8, rd_auth: u8, wr_auth: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlen: u8 = unsafe { ::core::mem::transmute(vlen) };
            vlen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let vloc: u8 = unsafe { ::core::mem::transmute(vloc) };
            vloc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rd_auth: u8 = unsafe { ::core::mem::transmute(rd_auth) };
            rd_auth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wr_auth: u8 = unsafe { ::core::mem::transmute(wr_auth) };
            wr_auth as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT Attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_attr_t {
    #[doc = "< Pointer to the attribute UUID."]
    pub p_uuid: *const ble_uuid_t,
    #[doc = "< Pointer to the attribute metadata structure."]
    pub p_attr_md: *const ble_gatts_attr_md_t,
    #[doc = "< Initial attribute value length in bytes."]
    pub init_len: u16,
    #[doc = "< Initial attribute value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized."]
    pub init_offs: u16,
    #[doc = "< Maximum attribute value length in bytes, see @ref BLE_GATTS_ATTR_LENS_MAX for maximum values."]
    pub max_len: u16,
    #[doc = "< Pointer to the attribute data. Please note that if the @ref BLE_GATTS_VLOC_USER value location is selected in the attribute metadata, this will have to point to a buffer"]
    #[doc = "that remains valid through the lifetime of the attribute. This excludes usage of automatic variables that may go out of scope or any other temporary location."]
    #[doc = "The stack may access that memory directly without the application's knowledge. For writable characteristics, this value must not be a location in flash memory."]
    pub p_value: *mut u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_attr_t>(),
        20usize,
        concat!("Size of: ", stringify!(ble_gatts_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_t>())).p_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_t),
            "::",
            stringify!(p_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_t>())).p_attr_md as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_t),
            "::",
            stringify!(p_attr_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_t>())).init_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_t),
            "::",
            stringify!(init_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_t>())).init_offs as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_t),
            "::",
            stringify!(init_offs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_t>())).max_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_t),
            "::",
            stringify!(max_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_attr_t>())).p_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_attr_t),
            "::",
            stringify!(p_value)
        )
    );
}
#[doc = "@brief GATT Attribute Value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_value_t {
    #[doc = "< Length in bytes to be written or read. Length in bytes written or read after successful return."]
    pub len: u16,
    #[doc = "< Attribute value offset."]
    pub offset: u16,
    #[doc = "< Pointer to where value is stored or will be stored."]
    #[doc = "If value is stored in user memory, only the attribute length is updated when p_value == NULL."]
    #[doc = "Set to NULL when reading to obtain the complete length of the attribute value"]
    pub p_value: *mut u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_value_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_value_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gatts_value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_value_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_value_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_value_t>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_value_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_value_t>())).offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_value_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_value_t>())).p_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_value_t),
            "::",
            stringify!(p_value)
        )
    );
}
#[doc = "@brief GATT Characteristic Presentation Format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_char_pf_t {
    #[doc = "< Format of the value, see @ref BLE_GATT_CPF_FORMATS."]
    pub format: u8,
    #[doc = "< Exponent for integer data types."]
    pub exponent: i8,
    #[doc = "< Unit from Bluetooth Assigned Numbers."]
    pub unit: u16,
    #[doc = "< Namespace from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES."]
    pub name_space: u8,
    #[doc = "< Namespace description from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES."]
    pub desc: u16,
}
#[test]
fn bindgen_test_layout_ble_gatts_char_pf_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_char_pf_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gatts_char_pf_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_char_pf_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_char_pf_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_pf_t>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_pf_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_pf_t>())).exponent as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_pf_t),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_pf_t>())).unit as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_pf_t),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_pf_t>())).name_space as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_pf_t),
            "::",
            stringify!(name_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_pf_t>())).desc as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_pf_t),
            "::",
            stringify!(desc)
        )
    );
}
#[doc = "@brief GATT Characteristic metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_char_md_t {
    #[doc = "< Characteristic Properties."]
    pub char_props: ble_gatt_char_props_t,
    #[doc = "< Characteristic Extended Properties."]
    pub char_ext_props: ble_gatt_char_ext_props_t,
    #[doc = "< Pointer to a UTF-8 encoded string (non-NULL terminated), NULL if the descriptor is not required."]
    pub p_char_user_desc: *const u8,
    #[doc = "< The maximum size in bytes of the user description descriptor."]
    pub char_user_desc_max_size: u16,
    #[doc = "< The size of the user description, must be smaller or equal to char_user_desc_max_size."]
    pub char_user_desc_size: u16,
    #[doc = "< Pointer to a presentation format structure or NULL if the CPF descriptor is not required."]
    pub p_char_pf: *const ble_gatts_char_pf_t,
    #[doc = "< Attribute metadata for the User Description descriptor, or NULL for default values."]
    pub p_user_desc_md: *const ble_gatts_attr_md_t,
    #[doc = "< Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values."]
    pub p_cccd_md: *const ble_gatts_attr_md_t,
    #[doc = "< Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values."]
    pub p_sccd_md: *const ble_gatts_attr_md_t,
}
#[test]
fn bindgen_test_layout_ble_gatts_char_md_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_char_md_t>(),
        28usize,
        concat!("Size of: ", stringify!(ble_gatts_char_md_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_char_md_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_char_md_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).char_props as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(char_props)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).char_ext_props as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(char_ext_props)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).p_char_user_desc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(p_char_user_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).char_user_desc_max_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(char_user_desc_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).char_user_desc_size as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(char_user_desc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).p_char_pf as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(p_char_pf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).p_user_desc_md as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(p_user_desc_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).p_cccd_md as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(p_cccd_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_md_t>())).p_sccd_md as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_md_t),
            "::",
            stringify!(p_sccd_md)
        )
    );
}
#[doc = "@brief GATT Characteristic Definition Handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_char_handles_t {
    #[doc = "< Handle to the characteristic value."]
    pub value_handle: u16,
    #[doc = "< Handle to the User Description descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present."]
    pub user_desc_handle: u16,
    #[doc = "< Handle to the Client Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present."]
    pub cccd_handle: u16,
    #[doc = "< Handle to the Server Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present."]
    pub sccd_handle: u16,
}
#[test]
fn bindgen_test_layout_ble_gatts_char_handles_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_char_handles_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gatts_char_handles_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_char_handles_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_char_handles_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_handles_t>())).value_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_handles_t),
            "::",
            stringify!(value_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_handles_t>())).user_desc_handle as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_handles_t),
            "::",
            stringify!(user_desc_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_handles_t>())).cccd_handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_handles_t),
            "::",
            stringify!(cccd_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_char_handles_t>())).sccd_handle as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_char_handles_t),
            "::",
            stringify!(sccd_handle)
        )
    );
}
#[doc = "@brief GATT HVx parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_hvx_params_t {
    #[doc = "< Characteristic Value Handle."]
    pub handle: u16,
    #[doc = "< Indication or Notification, see @ref BLE_GATT_HVX_TYPES."]
    pub type_: u8,
    #[doc = "< Offset within the attribute value."]
    pub offset: u16,
    #[doc = "< Length in bytes to be written, length in bytes written after return."]
    pub p_len: *mut u16,
    #[doc = "< Actual data content, use NULL to use the current attribute value."]
    pub p_data: *const u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_hvx_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_hvx_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_gatts_hvx_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_hvx_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_hvx_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_hvx_params_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_hvx_params_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_hvx_params_t>())).type_ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_hvx_params_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_hvx_params_t>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_hvx_params_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_hvx_params_t>())).p_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_hvx_params_t),
            "::",
            stringify!(p_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_hvx_params_t>())).p_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_hvx_params_t),
            "::",
            stringify!(p_data)
        )
    );
}
#[doc = "@brief GATT Authorization parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_authorize_params_t {
    #[doc = "< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES."]
    pub gatt_status: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Offset of the attribute value being updated."]
    pub offset: u16,
    #[doc = "< Length in bytes of the value in p_data pointer, see @ref BLE_GATTS_ATTR_LENS_MAX."]
    pub len: u16,
    #[doc = "< Pointer to new value used to update the attribute value."]
    pub p_data: *const u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_authorize_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_authorize_params_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_gatts_authorize_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_authorize_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_authorize_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_authorize_params_t>())).gatt_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_authorize_params_t),
            "::",
            stringify!(gatt_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_authorize_params_t>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_authorize_params_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_authorize_params_t>())).len as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_authorize_params_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_authorize_params_t>())).p_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_authorize_params_t),
            "::",
            stringify!(p_data)
        )
    );
}
impl ble_gatts_authorize_params_t {
    #[inline]
    pub fn update(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(update: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let update: u8 = unsafe { ::core::mem::transmute(update) };
            update as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT Read or Write Authorize Reply parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gatts_rw_authorize_reply_params_t {
    #[doc = "< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES."]
    pub type_: u8,
    #[doc = "< Reply Parameters."]
    pub params: ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1 {
    #[doc = "< Read authorization parameters."]
    pub read: ble_gatts_authorize_params_t,
    #[doc = "< Write authorization parameters."]
    pub write: ble_gatts_authorize_params_t,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1>())).read as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1>())).write as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1),
            "::",
            stringify!(write)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_gatts_rw_authorize_reply_params_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_rw_authorize_reply_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_gatts_rw_authorize_reply_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_rw_authorize_reply_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_rw_authorize_reply_params_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_rw_authorize_reply_params_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_rw_authorize_reply_params_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_rw_authorize_reply_params_t>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_rw_authorize_reply_params_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = "@brief Service Changed Inclusion configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_cfg_service_changed_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_gatts_cfg_service_changed_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_cfg_service_changed_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gatts_cfg_service_changed_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_cfg_service_changed_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatts_cfg_service_changed_t))
    );
}
impl ble_gatts_cfg_service_changed_t {
    #[inline]
    pub fn service_changed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_service_changed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(service_changed: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let service_changed: u8 = unsafe { ::core::mem::transmute(service_changed) };
            service_changed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Attribute table size configuration parameters, set with @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH One or more of the following is true:"]
#[doc = "                                    - The specified Attribute Table size is too small."]
#[doc = "                                      The minimum acceptable size is defined by @ref BLE_GATTS_ATTR_TAB_SIZE_MIN."]
#[doc = "                                    - The specified Attribute Table size is not a multiple of 4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_cfg_attr_tab_size_t {
    #[doc = "< Attribute table size. Default is @ref BLE_GATTS_ATTR_TAB_SIZE_DEFAULT, minimum is @ref BLE_GATTS_ATTR_TAB_SIZE_MIN."]
    pub attr_tab_size: u32,
}
#[test]
fn bindgen_test_layout_ble_gatts_cfg_attr_tab_size_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_cfg_attr_tab_size_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gatts_cfg_attr_tab_size_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_cfg_attr_tab_size_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_cfg_attr_tab_size_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_cfg_attr_tab_size_t>())).attr_tab_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_cfg_attr_tab_size_t),
            "::",
            stringify!(attr_tab_size)
        )
    );
}
#[doc = "@brief Config structure for GATTS configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gatts_cfg_t {
    #[doc = "< Include service changed characteristic, cfg_id is @ref BLE_GATTS_CFG_SERVICE_CHANGED."]
    pub service_changed: ble_gatts_cfg_service_changed_t,
    #[doc = "< Attribute table size, cfg_id is @ref BLE_GATTS_CFG_ATTR_TAB_SIZE."]
    pub attr_tab_size: ble_gatts_cfg_attr_tab_size_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ble_gatts_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_cfg_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_gatts_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_cfg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_gatts_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_cfg_t>())).service_changed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_cfg_t),
            "::",
            stringify!(service_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_cfg_t>())).attr_tab_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_cfg_t),
            "::",
            stringify!(attr_tab_size)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_WRITE."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gatts_evt_write_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Attribute UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Type of write operation, see @ref BLE_GATTS_OPS."]
    pub op: u8,
    #[doc = "< Writing operation deferred due to authorization requirement. Application may use @ref sd_ble_gatts_value_set to finalize the writing operation."]
    pub auth_required: u8,
    #[doc = "< Offset for the write operation."]
    pub offset: u16,
    #[doc = "< Length of the received data."]
    pub len: u16,
    #[doc = "< Received data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation."]
    #[doc = "See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_write_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_write_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_write_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_write_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_write_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_write_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_write_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_write_t>())).uuid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_write_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_write_t>())).op as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_write_t),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_write_t>())).auth_required as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_write_t),
            "::",
            stringify!(auth_required)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_write_t>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_write_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_write_t>())).len as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_write_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_write_t>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_write_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "@brief Event substructure for authorized read requests, see @ref ble_gatts_evt_rw_authorize_request_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_read_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Attribute UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Offset for the read operation."]
    pub offset: u16,
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_read_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_read_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_read_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_read_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_read_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_read_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_read_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_read_t>())).uuid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_read_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_read_t>())).offset as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_read_t),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST."]
#[repr(C)]
pub struct ble_gatts_evt_rw_authorize_request_t {
    #[doc = "< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES."]
    pub type_: u8,
    #[doc = "< Request Parameters."]
    pub request: ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1 {
    #[doc = "< Attribute Read Parameters."]
    pub read: __BindgenUnionField<ble_gatts_evt_read_t>,
    #[doc = "< Attribute Write Parameters."]
    pub write: __BindgenUnionField<ble_gatts_evt_write_t>,
    pub bindgen_union_field: [u16; 6usize],
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1>())).read as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1>())).write as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1),
            "::",
            stringify!(write)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_rw_authorize_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_rw_authorize_request_t>(),
        14usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_rw_authorize_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_rw_authorize_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_rw_authorize_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_rw_authorize_request_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_rw_authorize_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_rw_authorize_request_t>())).request as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_rw_authorize_request_t),
            "::",
            stringify!(request)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_SYS_ATTR_MISSING."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_sys_attr_missing_t {
    #[doc = "< Hint (currently unused)."]
    pub hint: u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_sys_attr_missing_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_sys_attr_missing_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_sys_attr_missing_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_sys_attr_missing_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_sys_attr_missing_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_sys_attr_missing_t>())).hint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_sys_attr_missing_t),
            "::",
            stringify!(hint)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_HVC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_hvc_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_hvc_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_hvc_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_hvc_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_hvc_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_hvc_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_hvc_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_hvc_t),
            "::",
            stringify!(handle)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_exchange_mtu_request_t {
    #[doc = "< Client RX MTU size."]
    pub client_rx_mtu: u16,
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_exchange_mtu_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_exchange_mtu_request_t>(),
        2usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_exchange_mtu_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_exchange_mtu_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_exchange_mtu_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_exchange_mtu_request_t>())).client_rx_mtu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_exchange_mtu_request_t),
            "::",
            stringify!(client_rx_mtu)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_TIMEOUT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_timeout_t {
    #[doc = "< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES."]
    pub src: u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_timeout_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_timeout_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_timeout_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_timeout_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_timeout_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_timeout_t>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_timeout_t),
            "::",
            stringify!(src)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_HVN_TX_COMPLETE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_hvn_tx_complete_t {
    #[doc = "< Number of notification transmissions completed."]
    pub count: u8,
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_hvn_tx_complete_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_hvn_tx_complete_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_hvn_tx_complete_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_hvn_tx_complete_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_hvn_tx_complete_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_hvn_tx_complete_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_hvn_tx_complete_t),
            "::",
            stringify!(count)
        )
    );
}
#[doc = "@brief GATTS event structure."]
#[repr(C)]
pub struct ble_gatts_evt_t {
    #[doc = "< Connection Handle on which the event occurred."]
    pub conn_handle: u16,
    #[doc = "< Event Parameters."]
    pub params: ble_gatts_evt_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gatts_evt_t__bindgen_ty_1 {
    #[doc = "< Write Event Parameters."]
    pub write: __BindgenUnionField<ble_gatts_evt_write_t>,
    #[doc = "< Read or Write Authorize Request Parameters."]
    pub authorize_request: __BindgenUnionField<ble_gatts_evt_rw_authorize_request_t>,
    #[doc = "< System attributes missing."]
    pub sys_attr_missing: __BindgenUnionField<ble_gatts_evt_sys_attr_missing_t>,
    #[doc = "< Handle Value Confirmation Event Parameters."]
    pub hvc: __BindgenUnionField<ble_gatts_evt_hvc_t>,
    #[doc = "< Exchange MTU Request Event Parameters."]
    pub exchange_mtu_request: __BindgenUnionField<ble_gatts_evt_exchange_mtu_request_t>,
    #[doc = "< Timeout Event."]
    pub timeout: __BindgenUnionField<ble_gatts_evt_timeout_t>,
    #[doc = "< Handle Value Notification transmission complete Event Parameters."]
    pub hvn_tx_complete: __BindgenUnionField<ble_gatts_evt_hvn_tx_complete_t>,
    pub bindgen_union_field: [u16; 7usize],
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_t__bindgen_ty_1>(),
        14usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t__bindgen_ty_1>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t__bindgen_ty_1),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t__bindgen_ty_1>())).authorize_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t__bindgen_ty_1),
            "::",
            stringify!(authorize_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t__bindgen_ty_1>())).sys_attr_missing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t__bindgen_ty_1),
            "::",
            stringify!(sys_attr_missing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t__bindgen_ty_1>())).hvc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t__bindgen_ty_1),
            "::",
            stringify!(hvc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t__bindgen_ty_1>())).exchange_mtu_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t__bindgen_ty_1),
            "::",
            stringify!(exchange_mtu_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t__bindgen_ty_1>())).timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t__bindgen_ty_1),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t__bindgen_ty_1>())).hvn_tx_complete as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t__bindgen_ty_1),
            "::",
            stringify!(hvn_tx_complete)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_gatts_evt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_gatts_evt_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_gatts_evt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_gatts_evt_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_gatts_evt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_gatts_evt_t>())).params as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_gatts_evt_t),
            "::",
            stringify!(params)
        )
    );
}

#[doc = "@brief Add a service declaration to the Attribute Table."]
#[doc = ""]
#[doc = " @note Secondary Services are only relevant in the context of the entity that references them, it is therefore forbidden to"]
#[doc = "       add a secondary service declaration that is not referenced by another service later in the Attribute Table."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] type      Toggles between primary and secondary services, see @ref BLE_GATTS_SRVC_TYPES."]
#[doc = " @param[in] p_uuid    Pointer to service UUID."]
#[doc = " @param[out] p_handle Pointer to a 16-bit word where the assigned handle will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully added a service declaration."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack."]
#[doc = " @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_service_add(type_: u8, p_uuid: *const ble_uuid_t, p_handle: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 168",
        inout("r0") to_asm(type_) => ret,
        inout("r1") to_asm(p_uuid) => _,
        inout("r2") to_asm(p_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add an include declaration to the Attribute Table."]
#[doc = ""]
#[doc = " @note It is currently only possible to add an include declaration to the last added service (i.e. only sequential population is supported at this time)."]
#[doc = ""]
#[doc = " @note The included service must already be present in the Attribute Table prior to this call."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] service_handle    Handle of the service where the included service is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially."]
#[doc = " @param[in] inc_srvc_handle   Handle of the included service."]
#[doc = " @param[out] p_include_handle Pointer to a 16-bit word where the assigned handle will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully added an include declaration."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, handle values need to match previously added services."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED Feature is not supported, service_handle must be that of the last added service."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, self inclusions are not allowed."]
#[doc = " @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND Attribute not found."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_include_add(service_handle: u16, inc_srvc_handle: u16, p_include_handle: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 169",
        inout("r0") to_asm(service_handle) => ret,
        inout("r1") to_asm(inc_srvc_handle) => _,
        inout("r2") to_asm(p_include_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add a characteristic declaration, a characteristic value declaration and optional characteristic descriptor declarations to the Attribute Table."]
#[doc = ""]
#[doc = " @note It is currently only possible to add a characteristic to the last added service (i.e. only sequential population is supported at this time)."]
#[doc = ""]
#[doc = " @note Several restrictions apply to the parameters, such as matching permissions between the user description descriptor and the writable auxiliaries bits,"]
#[doc = "       readable (no security) and writable (selectable) CCCDs and SCCDs and valid presentation format values."]
#[doc = ""]
#[doc = " @note If no metadata is provided for the optional descriptors, their permissions will be derived from the characteristic permissions."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] service_handle    Handle of the service where the characteristic is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially."]
#[doc = " @param[in] p_char_md         Characteristic metadata."]
#[doc = " @param[in] p_attr_char_value Pointer to the attribute structure corresponding to the characteristic value."]
#[doc = " @param[out] p_handles        Pointer to the structure where the assigned handles will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully added a characteristic."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack."]
#[doc = " @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_characteristic_add(
    service_handle: u16,
    p_char_md: *const ble_gatts_char_md_t,
    p_attr_char_value: *const ble_gatts_attr_t,
    p_handles: *mut ble_gatts_char_handles_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 170",
        inout("r0") to_asm(service_handle) => ret,
        inout("r1") to_asm(p_char_md) => _,
        inout("r2") to_asm(p_attr_char_value) => _,
        inout("r3") to_asm(p_handles) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add a descriptor to the Attribute Table."]
#[doc = ""]
#[doc = " @note It is currently only possible to add a descriptor to the last added characteristic (i.e. only sequential population is supported at this time)."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] char_handle   Handle of the characteristic where the descriptor is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially."]
#[doc = " @param[in] p_attr        Pointer to the attribute structure."]
#[doc = " @param[out] p_handle     Pointer to a 16-bit word where the assigned handle will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully added a descriptor."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a characteristic context is required."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack."]
#[doc = " @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_descriptor_add(
    char_handle: u16,
    p_attr: *const ble_gatts_attr_t,
    p_handle: *mut u16,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 171",
        inout("r0") to_asm(char_handle) => ret,
        inout("r1") to_asm(p_attr) => _,
        inout("r2") to_asm(p_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set the value of a given attribute."]
#[doc = ""]
#[doc = " @note Values other than system attributes can be set at any time, regardless of whether any active connections exist."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle  Connection handle. Ignored if the value does not belong to a system attribute."]
#[doc = " @param[in] handle       Attribute handle."]
#[doc = " @param[in,out] p_value  Attribute value information."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully set the value of the attribute."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND Attribute not found."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN Forbidden handle supplied, certain attributes are not modifiable by the application."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied on a system attribute."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_value_set(conn_handle: u16, handle: u16, p_value: *mut ble_gatts_value_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 172",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(p_value) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the value of a given attribute."]
#[doc = ""]
#[doc = " @note                 If the attribute value is longer than the size of the supplied buffer,"]
#[doc = "                       @ref ble_gatts_value_t::len will return the total attribute value length (excluding offset),"]
#[doc = "                       and not the number of bytes actually returned in @ref ble_gatts_value_t::p_value."]
#[doc = "                       The application may use this information to allocate a suitable buffer size."]
#[doc = ""]
#[doc = " @note                 When retrieving system attribute values with this function, the connection handle"]
#[doc = "                       may refer to an already disconnected connection. Refer to the documentation of"]
#[doc = "                       @ref sd_ble_gatts_sys_attr_get for further information."]
#[doc = ""]
#[doc = " @param[in] conn_handle  Connection handle. Ignored if the value does not belong to a system attribute."]
#[doc = " @param[in] handle       Attribute handle."]
#[doc = " @param[in,out] p_value  Attribute value information."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully retrieved the value of the attribute."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND Attribute not found."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid attribute offset supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied on a system attribute."]
#[doc = " @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_value_get(conn_handle: u16, handle: u16, p_value: *mut ble_gatts_value_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 173",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(p_value) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Notify or Indicate an attribute value."]
#[doc = ""]
#[doc = " @details This function checks for the relevant Client Characteristic Configuration descriptor value to verify that the relevant operation"]
#[doc = "          (notification or indication) has been enabled by the client. It is also able to update the attribute value before issuing the PDU, so that"]
#[doc = "          the application can atomically perform a value update and a server initiated transaction with a single API call."]
#[doc = ""]
#[doc = " @note    The local attribute value may be updated even if an outgoing packet is not sent to the peer due to an error during execution."]
#[doc = "          The Attribute Table has been updated if one of the following error codes is returned: @ref NRF_ERROR_INVALID_STATE, @ref NRF_ERROR_BUSY,"]
#[doc = "          @ref NRF_ERROR_FORBIDDEN, @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING and @ref NRF_ERROR_RESOURCES."]
#[doc = "          The caller can check whether the value has been updated by looking at the contents of *(@ref ble_gatts_hvx_params_t::p_len)."]
#[doc = ""]
#[doc = " @note    Only one indication procedure can be ongoing per connection at a time."]
#[doc = "          If the application tries to indicate an attribute value while another indication procedure is ongoing,"]
#[doc = "          the function call will return @ref NRF_ERROR_BUSY."]
#[doc = "          A @ref BLE_GATTS_EVT_HVC event will be issued as soon as the confirmation arrives from the peer."]
#[doc = ""]
#[doc = " @note    The number of Handle Value Notifications that can be queued is configured by @ref ble_gatts_conn_cfg_t::hvn_tx_queue_size"]
#[doc = "          When the queue is full, the function call will return @ref NRF_ERROR_RESOURCES."]
#[doc = "          A @ref BLE_GATTS_EVT_HVN_TX_COMPLETE event will be issued as soon as the transmission of the notification is complete."]
#[doc = ""]
#[doc = " @note    The application can keep track of the available queue element count for notifications by following the procedure below:"]
#[doc = "          - Store initial queue element count in a variable."]
#[doc = "          - Decrement the variable, which stores the currently available queue element count, by one when a call to this function returns @ref NRF_SUCCESS."]
#[doc = "          - Increment the variable, which stores the current available queue element count, by the count variable in @ref BLE_GATTS_EVT_HVN_TX_COMPLETE event."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTS_EVT_HVN_TX_COMPLETE, Notification transmission complete.}"]
#[doc = " @event{@ref BLE_GATTS_EVT_HVC, Confirmation received from the peer.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_HVN_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_HVI_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_HVX_DISABLED_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle      Connection handle."]
#[doc = " @param[in,out] p_hvx_params Pointer to an HVx parameters structure. If @ref ble_gatts_hvx_params_t::p_data"]
#[doc = "                             contains a non-NULL pointer the attribute value will be updated with the contents"]
#[doc = "                             pointed by it before sending the notification or indication. If the attribute value"]
#[doc = "                             is updated, @ref ble_gatts_hvx_params_t::p_len is updated by the SoftDevice to"]
#[doc = "                             contain the number of actual bytes written, else it will be set to 0."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully queued a notification or indication for transmission, and optionally updated the attribute value."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:"]
#[doc = "                                   - Invalid Connection State"]
#[doc = "                                   - Notifications and/or indications not enabled in the CCCD"]
#[doc = "                                   - An ATT_MTU exchange is ongoing"]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied. Only attributes added directly by the application are available to notify and indicate."]
#[doc = " @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE Invalid attribute type(s) supplied, only characteristic values may be notified and indicated."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND Attribute not found."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN The connection's current security level is lower than the one required by the write permissions of the CCCD associated with this characteristic."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY For @ref BLE_GATT_HVX_INDICATION Procedure already in progress. Wait for a @ref BLE_GATTS_EVT_HVC event and retry."]
#[doc = " @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value."]
#[doc = " @retval ::NRF_ERROR_RESOURCES Too many notifications queued."]
#[doc = "                               Wait for a @ref BLE_GATTS_EVT_HVN_TX_COMPLETE event and retry."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_hvx(conn_handle: u16, p_hvx_params: *const ble_gatts_hvx_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 174",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_hvx_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Indicate the Service Changed attribute value."]
#[doc = ""]
#[doc = " @details This call will send a Handle Value Indication to one or more peers connected to inform them that the Attribute"]
#[doc = "          Table layout has changed. As soon as the peer has confirmed the indication, a @ref BLE_GATTS_EVT_SC_CONFIRM event will"]
#[doc = "          be issued."]
#[doc = ""]
#[doc = " @note    Some of the restrictions and limitations that apply to @ref sd_ble_gatts_hvx also apply here."]
#[doc = ""]
#[doc = " @events"]
#[doc = " @event{@ref BLE_GATTS_EVT_SC_CONFIRM, Confirmation of attribute table change received from peer.}"]
#[doc = " @endevents"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_SC_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle  Connection handle."]
#[doc = " @param[in] start_handle Start of affected attribute handle range."]
#[doc = " @param[in] end_handle   End of affected attribute handle range."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully queued the Service Changed indication for transmission."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED Service Changed not enabled at initialization. See @ref"]
#[doc = "                                   sd_ble_cfg_set and @ref ble_gatts_cfg_service_changed_t."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:"]
#[doc = "                                   - Invalid Connection State"]
#[doc = "                                   - Notifications and/or indications not enabled in the CCCD"]
#[doc = "                                   - An ATT_MTU exchange is ongoing"]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied, handles must be in the range populated by the application."]
#[doc = " @retval ::NRF_ERROR_BUSY Procedure already in progress."]
#[doc = " @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_service_changed(conn_handle: u16, start_handle: u16, end_handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 175",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(start_handle) => _,
        inout("r2") to_asm(end_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Respond to a Read/Write authorization request."]
#[doc = ""]
#[doc = " @note This call should only be used as a response to a @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST event issued to the application."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_READ_REQ_AUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_WRITE_REQ_AUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_PEER_CANCEL_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle                 Connection handle."]
#[doc = " @param[in] p_rw_authorize_reply_params Pointer to a structure with the attribute provided by the application."]
#[doc = ""]
#[doc = " @note @ref ble_gatts_authorize_params_t::p_data is ignored when this function is used to respond"]
#[doc = "       to a @ref BLE_GATTS_AUTHORIZE_TYPE_READ event if @ref ble_gatts_authorize_params_t::update"]
#[doc = "       is set to 0."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS               Successfully queued a response to the peer, and in the case of a write operation, Attribute Table updated."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_BUSY            The stack is busy, process pending events and retry."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR    Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE   Invalid Connection State or no authorization request pending."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM   Authorization op invalid,"]
#[doc = "                                         handle supplied does not match requested handle,"]
#[doc = "                                         or invalid data to be written provided by the application."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_rw_authorize_reply(
    conn_handle: u16,
    p_rw_authorize_reply_params: *const ble_gatts_rw_authorize_reply_params_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 176",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_rw_authorize_reply_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Update persistent system attribute information."]
#[doc = ""]
#[doc = " @details Supply information about persistent system attributes to the stack,"]
#[doc = "          previously obtained using @ref sd_ble_gatts_sys_attr_get."]
#[doc = "          This call is only allowed for active connections, and is usually"]
#[doc = "          made immediately after a connection is established with an known bonded device,"]
#[doc = "          often as a response to a @ref BLE_GATTS_EVT_SYS_ATTR_MISSING."]
#[doc = ""]
#[doc = "          p_sysattrs may point directly to the application's stored copy of the system attributes"]
#[doc = "          obtained using @ref sd_ble_gatts_sys_attr_get."]
#[doc = "          If the pointer is NULL, the system attribute info is initialized, assuming that"]
#[doc = "          the application does not have any previously saved system attribute data for this device."]
#[doc = ""]
#[doc = " @note The state of persistent system attributes is reset upon connection establishment and then remembered for its duration."]
#[doc = ""]
#[doc = " @note If this call returns with an error code different from @ref NRF_SUCCESS, the storage of persistent system attributes may have been completed only partially."]
#[doc = "       This means that the state of the attribute table is undefined, and the application should either provide a new set of attributes using this same call or"]
#[doc = "       reset the SoftDevice to return to a known state."]
#[doc = ""]
#[doc = " @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be modified."]
#[doc = " @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be modified."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_SYS_ATTRS_UNK_PEER_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in]  conn_handle        Connection handle."]
#[doc = " @param[in]  p_sys_attr_data    Pointer to a saved copy of system attributes supplied to the stack, or NULL."]
#[doc = " @param[in]  len                Size of data pointed by p_sys_attr_data, in octets."]
#[doc = " @param[in]  flags              Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully set the system attribute information."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_DATA Invalid data supplied, the data should be exactly the same as retrieved with @ref sd_ble_gatts_sys_attr_get."]
#[doc = " @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_sys_attr_set(conn_handle: u16, p_sys_attr_data: *const u8, len: u16, flags: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 177",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_sys_attr_data) => _,
        inout("r2") to_asm(len) => _,
        inout("r3") to_asm(flags) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Retrieve persistent system attribute information from the stack."]
#[doc = ""]
#[doc = " @details This call is used to retrieve information about values to be stored persistently by the application"]
#[doc = "          during the lifetime of a connection or after it has been terminated. When a new connection is established with the same bonded device,"]
#[doc = "          the system attribute information retrieved with this function should be restored using using @ref sd_ble_gatts_sys_attr_set."]
#[doc = "          If retrieved after disconnection, the data should be read before a new connection established. The connection handle for"]
#[doc = "          the previous, now disconnected, connection will remain valid until a new one is created to allow this API call to refer to it."]
#[doc = "          Connection handles belonging to active connections can be used as well, but care should be taken since the system attributes"]
#[doc = "          may be written to at any time by the peer during a connection's lifetime."]
#[doc = ""]
#[doc = " @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be returned."]
#[doc = " @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be returned."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in]     conn_handle       Connection handle of the recently terminated connection."]
#[doc = " @param[out]    p_sys_attr_data   Pointer to a buffer where updated information about system attributes will be filled in. The format of the data is described"]
#[doc = "                                  in @ref BLE_GATTS_SYS_ATTRS_FORMAT. NULL can be provided to obtain the length of the data."]
#[doc = " @param[in,out] p_len             Size of application buffer if p_sys_attr_data is not NULL. Unconditionally updated to actual length of system attribute data."]
#[doc = " @param[in]     flags             Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully retrieved the system attribute information."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE The system attribute information did not fit into the provided buffer."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND No system attributes found."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_sys_attr_get(
    conn_handle: u16,
    p_sys_attr_data: *mut u8,
    p_len: *mut u16,
    flags: u32,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 178",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_sys_attr_data) => _,
        inout("r2") to_asm(p_len) => _,
        inout("r3") to_asm(flags) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Retrieve the first valid user attribute handle."]
#[doc = ""]
#[doc = " @param[out] p_handle   Pointer to an integer where the handle will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully retrieved the handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_initial_user_handle_get(p_handle: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 179",
        inout("r0") to_asm(p_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Retrieve the attribute UUID and/or metadata."]
#[doc = ""]
#[doc = " @param[in]  handle Attribute handle"]
#[doc = " @param[out] p_uuid UUID of the attribute. Use NULL to omit this field."]
#[doc = " @param[out] p_md Metadata of the attribute. Use NULL to omit this field."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully retrieved the attribute metadata,"]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameters supplied. Returned when both @c p_uuid and @c p_md are NULL."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND Attribute was not found."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_attr_get(handle: u16, p_uuid: *mut ble_uuid_t, p_md: *mut ble_gatts_attr_md_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 180",
        inout("r0") to_asm(handle) => ret,
        inout("r1") to_asm(p_uuid) => _,
        inout("r2") to_asm(p_md) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply to an ATT_MTU exchange request by sending an Exchange MTU Response to the client."]
#[doc = ""]
#[doc = " @details This function is only used to reply to a @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST event."]
#[doc = ""]
#[doc = " @details The SoftDevice sets ATT_MTU to the minimum of:"]
#[doc = "          - The Client RX MTU value from @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST, and"]
#[doc = "          - The Server RX MTU value."]
#[doc = ""]
#[doc = "          However, the SoftDevice never sets ATT_MTU lower than @ref BLE_GATT_ATT_MTU_DEFAULT."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_MTU_EXCHANGE}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on."]
#[doc = " @param[in] server_rx_mtu  Server RX MTU size."]
#[doc = "                           - The minimum value is @ref BLE_GATT_ATT_MTU_DEFAULT."]
#[doc = "                           - The maximum value is @ref ble_gatt_conn_cfg_t::att_mtu in the connection configuration"]
#[doc = "                             used for this connection."]
#[doc = "                           - The value must be equal to Client RX MTU size given in @ref sd_ble_gattc_exchange_mtu_request"]
#[doc = "                             if an ATT_MTU exchange has already been performed in the other direction."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully sent response to the client."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no ATT_MTU exchange request pending."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid Server RX MTU size supplied."]
#[doc = " @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_exchange_mtu_reply(conn_handle: u16, server_rx_mtu: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 181",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(server_rx_mtu) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< Enable and initialize the BLE stack"]
pub const BLE_COMMON_SVCS_SD_BLE_ENABLE: BLE_COMMON_SVCS = 96;
#[doc = "< Get an event from the pending events queue."]
pub const BLE_COMMON_SVCS_SD_BLE_EVT_GET: BLE_COMMON_SVCS = 97;
#[doc = "< Add a Vendor Specific base UUID."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_VS_ADD: BLE_COMMON_SVCS = 98;
#[doc = "< Decode UUID bytes."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_DECODE: BLE_COMMON_SVCS = 99;
#[doc = "< Encode UUID bytes."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_ENCODE: BLE_COMMON_SVCS = 100;
#[doc = "< Get the local version information (company ID, Link Layer Version, Link Layer Subversion)."]
pub const BLE_COMMON_SVCS_SD_BLE_VERSION_GET: BLE_COMMON_SVCS = 101;
#[doc = "< User Memory Reply."]
pub const BLE_COMMON_SVCS_SD_BLE_USER_MEM_REPLY: BLE_COMMON_SVCS = 102;
#[doc = "< Set a BLE option."]
pub const BLE_COMMON_SVCS_SD_BLE_OPT_SET: BLE_COMMON_SVCS = 103;
#[doc = "< Get a BLE option."]
pub const BLE_COMMON_SVCS_SD_BLE_OPT_GET: BLE_COMMON_SVCS = 104;
#[doc = "< Add a configuration to the BLE stack."]
pub const BLE_COMMON_SVCS_SD_BLE_CFG_SET: BLE_COMMON_SVCS = 105;
#[doc = "< Remove a Vendor Specific base UUID."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_VS_REMOVE: BLE_COMMON_SVCS = 106;
#[doc = " @brief Common API SVC numbers."]
pub type BLE_COMMON_SVCS = self::c_uint;
#[doc = "< User Memory request. @ref ble_evt_user_mem_request_t"]
pub const BLE_COMMON_EVTS_BLE_EVT_USER_MEM_REQUEST: BLE_COMMON_EVTS = 1;
#[doc = "< User Memory release. @ref ble_evt_user_mem_release_t"]
pub const BLE_COMMON_EVTS_BLE_EVT_USER_MEM_RELEASE: BLE_COMMON_EVTS = 2;
#[doc = " @brief BLE Module Independent Event IDs."]
pub type BLE_COMMON_EVTS = self::c_uint;
#[doc = "< BLE GAP specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GAP: BLE_CONN_CFGS = 32;
#[doc = "< BLE GATTC specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GATTC: BLE_CONN_CFGS = 33;
#[doc = "< BLE GATTS specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GATTS: BLE_CONN_CFGS = 34;
#[doc = "< BLE GATT specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GATT: BLE_CONN_CFGS = 35;
#[doc = "< BLE L2CAP specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_L2CAP: BLE_CONN_CFGS = 36;
#[doc = "@brief BLE Connection Configuration IDs."]
#[doc = ""]
#[doc = " IDs that uniquely identify a connection configuration."]
pub type BLE_CONN_CFGS = self::c_uint;
#[doc = "< Vendor specific base UUID configuration"]
pub const BLE_COMMON_CFGS_BLE_COMMON_CFG_VS_UUID: BLE_COMMON_CFGS = 1;
#[doc = "@brief BLE Common Configuration IDs."]
#[doc = ""]
#[doc = " IDs that uniquely identify a common configuration."]
pub type BLE_COMMON_CFGS = self::c_uint;
#[doc = "< PA and LNA options"]
pub const BLE_COMMON_OPTS_BLE_COMMON_OPT_PA_LNA: BLE_COMMON_OPTS = 1;
#[doc = "< Extended connection events option"]
pub const BLE_COMMON_OPTS_BLE_COMMON_OPT_CONN_EVT_EXT: BLE_COMMON_OPTS = 2;
#[doc = "< Extended RC calibration option"]
pub const BLE_COMMON_OPTS_BLE_COMMON_OPT_EXTENDED_RC_CAL: BLE_COMMON_OPTS = 3;
#[doc = "@brief Common Option IDs."]
#[doc = " IDs that uniquely identify a common option."]
pub type BLE_COMMON_OPTS = self::c_uint;
#[doc = "@brief User Memory Block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_user_mem_block_t {
    #[doc = "< Pointer to the start of the user memory block."]
    pub p_mem: *mut u8,
    #[doc = "< Length in bytes of the user memory block."]
    pub len: u16,
}
#[test]
fn bindgen_test_layout_ble_user_mem_block_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_user_mem_block_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_user_mem_block_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_user_mem_block_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_user_mem_block_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_user_mem_block_t>())).p_mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_user_mem_block_t),
            "::",
            stringify!(p_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_user_mem_block_t>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_user_mem_block_t),
            "::",
            stringify!(len)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_EVT_USER_MEM_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_evt_user_mem_request_t {
    #[doc = "< User memory type, see @ref BLE_USER_MEM_TYPES."]
    pub type_: u8,
}
#[test]
fn bindgen_test_layout_ble_evt_user_mem_request_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_evt_user_mem_request_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_evt_user_mem_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_evt_user_mem_request_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_evt_user_mem_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_user_mem_request_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_user_mem_request_t),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "@brief Event structure for @ref BLE_EVT_USER_MEM_RELEASE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_evt_user_mem_release_t {
    #[doc = "< User memory type, see @ref BLE_USER_MEM_TYPES."]
    pub type_: u8,
    #[doc = "< User memory block"]
    pub mem_block: ble_user_mem_block_t,
}
#[test]
fn bindgen_test_layout_ble_evt_user_mem_release_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_evt_user_mem_release_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_evt_user_mem_release_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_evt_user_mem_release_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_evt_user_mem_release_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_user_mem_release_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_user_mem_release_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_user_mem_release_t>())).mem_block as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_user_mem_release_t),
            "::",
            stringify!(mem_block)
        )
    );
}
#[doc = "@brief Event structure for events not associated with a specific function module."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_common_evt_t {
    #[doc = "< Connection Handle on which this event occurred."]
    pub conn_handle: u16,
    #[doc = "< Event parameter union."]
    pub params: ble_common_evt_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_common_evt_t__bindgen_ty_1 {
    #[doc = "< User Memory Request Event Parameters."]
    pub user_mem_request: ble_evt_user_mem_request_t,
    #[doc = "< User Memory Release Event Parameters."]
    pub user_mem_release: ble_evt_user_mem_release_t,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ble_common_evt_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_evt_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ble_common_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_evt_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_common_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_evt_t__bindgen_ty_1>())).user_mem_request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_evt_t__bindgen_ty_1),
            "::",
            stringify!(user_mem_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_evt_t__bindgen_ty_1>())).user_mem_release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_evt_t__bindgen_ty_1),
            "::",
            stringify!(user_mem_release)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_common_evt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_evt_t>(),
        16usize,
        concat!("Size of: ", stringify!(ble_common_evt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_evt_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_common_evt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_evt_t>())).conn_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_evt_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_evt_t>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_evt_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = "@brief BLE Event header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_evt_hdr_t {
    #[doc = "< Value from a BLE_<module>_EVT series."]
    pub evt_id: u16,
    #[doc = "< Length in octets including this header."]
    pub evt_len: u16,
}
#[test]
fn bindgen_test_layout_ble_evt_hdr_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_evt_hdr_t>(),
        4usize,
        concat!("Size of: ", stringify!(ble_evt_hdr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_evt_hdr_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_evt_hdr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_hdr_t>())).evt_id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_evt_hdr_t), "::", stringify!(evt_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_hdr_t>())).evt_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_hdr_t),
            "::",
            stringify!(evt_len)
        )
    );
}
#[doc = "@brief Common BLE Event type, wrapping the module specific event reports."]
#[repr(C)]
pub struct ble_evt_t {
    #[doc = "< Event header."]
    pub header: ble_evt_hdr_t,
    #[doc = "< Event union."]
    pub evt: ble_evt_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_evt_t__bindgen_ty_1 {
    #[doc = "< Common Event, evt_id in BLE_EVT_* series."]
    pub common_evt: __BindgenUnionField<ble_common_evt_t>,
    #[doc = "< GAP originated event, evt_id in BLE_GAP_EVT_* series."]
    pub gap_evt: __BindgenUnionField<ble_gap_evt_t>,
    #[doc = "< GATT client originated event, evt_id in BLE_GATTC_EVT* series."]
    pub gattc_evt: __BindgenUnionField<ble_gattc_evt_t>,
    #[doc = "< GATT server originated event, evt_id in BLE_GATTS_EVT* series."]
    pub gatts_evt: __BindgenUnionField<ble_gatts_evt_t>,
    #[doc = "< L2CAP originated event, evt_id in BLE_L2CAP_EVT* series."]
    pub l2cap_evt: __BindgenUnionField<ble_l2cap_evt_t>,
    pub bindgen_union_field: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_ble_evt_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_evt_t__bindgen_ty_1>(),
        44usize,
        concat!("Size of: ", stringify!(ble_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_evt_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_evt_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_t__bindgen_ty_1>())).common_evt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_t__bindgen_ty_1),
            "::",
            stringify!(common_evt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_t__bindgen_ty_1>())).gap_evt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_t__bindgen_ty_1),
            "::",
            stringify!(gap_evt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_t__bindgen_ty_1>())).gattc_evt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_t__bindgen_ty_1),
            "::",
            stringify!(gattc_evt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_t__bindgen_ty_1>())).gatts_evt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_t__bindgen_ty_1),
            "::",
            stringify!(gatts_evt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_t__bindgen_ty_1>())).l2cap_evt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_evt_t__bindgen_ty_1),
            "::",
            stringify!(l2cap_evt)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_evt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_evt_t>(),
        48usize,
        concat!("Size of: ", stringify!(ble_evt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_evt_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_evt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_t>())).header as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_evt_t), "::", stringify!(header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_evt_t>())).evt as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ble_evt_t), "::", stringify!(evt))
    );
}
#[doc = " @brief Version Information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_version_t {
    #[doc = "< Link Layer Version number. See https://www.bluetooth.org/en-us/specification/assigned-numbers/link-layer for assigned values."]
    pub version_number: u8,
    #[doc = "< Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708)."]
    pub company_id: u16,
    #[doc = "< Link Layer Sub Version number, corresponds to the SoftDevice Config ID or Firmware ID (FWID)."]
    pub subversion_number: u16,
}
#[test]
fn bindgen_test_layout_ble_version_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_version_t>(),
        6usize,
        concat!("Size of: ", stringify!(ble_version_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_version_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_version_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_version_t>())).version_number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_version_t),
            "::",
            stringify!(version_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_version_t>())).company_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_version_t),
            "::",
            stringify!(company_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_version_t>())).subversion_number as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_version_t),
            "::",
            stringify!(subversion_number)
        )
    );
}
#[doc = " @brief Configuration parameters for the PA and LNA."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_pa_lna_cfg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_pa_lna_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_pa_lna_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_pa_lna_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_pa_lna_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_pa_lna_cfg_t))
    );
}
impl ble_pa_lna_cfg_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active_high(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active_high(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_pin(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_pin(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8, active_high: u8, gpio_pin: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let active_high: u8 = unsafe { ::core::mem::transmute(active_high) };
            active_high as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let gpio_pin: u8 = unsafe { ::core::mem::transmute(gpio_pin) };
            gpio_pin as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief PA & LNA GPIO toggle configuration"]
#[doc = ""]
#[doc = " This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or"]
#[doc = " a low noise amplifier."]
#[doc = ""]
#[doc = " Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided"]
#[doc = " by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled."]
#[doc = ""]
#[doc = " @note  @ref sd_ble_opt_get is not supported for this option."]
#[doc = " @note  Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences"]
#[doc = " and must be avoided by the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_opt_pa_lna_t {
    #[doc = "< Power Amplifier configuration"]
    pub pa_cfg: ble_pa_lna_cfg_t,
    #[doc = "< Low Noise Amplifier configuration"]
    pub lna_cfg: ble_pa_lna_cfg_t,
    #[doc = "< PPI channel used for radio pin setting"]
    pub ppi_ch_id_set: u8,
    #[doc = "< PPI channel used for radio pin clearing"]
    pub ppi_ch_id_clr: u8,
    #[doc = "< GPIOTE channel used for radio pin toggling"]
    pub gpiote_ch_id: u8,
}
#[test]
fn bindgen_test_layout_ble_common_opt_pa_lna_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_opt_pa_lna_t>(),
        5usize,
        concat!("Size of: ", stringify!(ble_common_opt_pa_lna_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_opt_pa_lna_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_common_opt_pa_lna_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_pa_lna_t>())).pa_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_pa_lna_t),
            "::",
            stringify!(pa_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_pa_lna_t>())).lna_cfg as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_pa_lna_t),
            "::",
            stringify!(lna_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_pa_lna_t>())).ppi_ch_id_set as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_pa_lna_t),
            "::",
            stringify!(ppi_ch_id_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_pa_lna_t>())).ppi_ch_id_clr as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_pa_lna_t),
            "::",
            stringify!(ppi_ch_id_clr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_pa_lna_t>())).gpiote_ch_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_pa_lna_t),
            "::",
            stringify!(gpiote_ch_id)
        )
    );
}
#[doc = " @brief Configuration of extended BLE connection events."]
#[doc = ""]
#[doc = " When enabled the SoftDevice will dynamically extend the connection event when possible."]
#[doc = ""]
#[doc = " The connection event length is controlled by the connection configuration as set by @ref ble_gap_conn_cfg_t::event_length."]
#[doc = " The connection event can be extended if there is time to send another packet pair before the start of the next connection interval,"]
#[doc = " and if there are no conflicts with other BLE roles requesting radio time."]
#[doc = ""]
#[doc = " @note @ref sd_ble_opt_get is not supported for this option."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_opt_conn_evt_ext_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_common_opt_conn_evt_ext_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_opt_conn_evt_ext_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_common_opt_conn_evt_ext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_opt_conn_evt_ext_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_common_opt_conn_evt_ext_t))
    );
}
impl ble_common_opt_conn_evt_ext_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Enable/disable extended RC calibration."]
#[doc = ""]
#[doc = " If extended RC calibration is enabled and the internal RC oscillator (@ref NRF_CLOCK_LF_SRC_RC) is used as the SoftDevice"]
#[doc = " LFCLK source, the SoftDevice as a peripheral will by default try to increase the receive window if two consecutive packets"]
#[doc = " are not received. If it turns out that the packets were not received due to clock drift, the RC calibration is started."]
#[doc = " This calibration comes in addition to the periodic calibration that is configured by @ref sd_softdevice_enable(). When"]
#[doc = " using only peripheral connections, the periodic calibration can therefore be configured with a much longer interval as the"]
#[doc = " peripheral will be able to detect and adjust automatically to clock drift, and calibrate on demand."]
#[doc = ""]
#[doc = " If extended RC calibration is disabled and the internal RC oscillator is used as the SoftDevice LFCLK source, the"]
#[doc = " RC oscillator is calibrated periodically as configured by @ref sd_softdevice_enable()."]
#[doc = ""]
#[doc = " @note @ref sd_ble_opt_get is not supported for this option."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_opt_extended_rc_cal_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ble_common_opt_extended_rc_cal_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_opt_extended_rc_cal_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_common_opt_extended_rc_cal_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_opt_extended_rc_cal_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_common_opt_extended_rc_cal_t))
    );
}
impl ble_common_opt_extended_rc_cal_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Option structure for common options."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_common_opt_t {
    #[doc = "< Parameters for controlling PA and LNA pin toggling."]
    pub pa_lna: ble_common_opt_pa_lna_t,
    #[doc = "< Parameters for enabling extended connection events."]
    pub conn_evt_ext: ble_common_opt_conn_evt_ext_t,
    #[doc = "< Parameters for enabling extended RC calibration."]
    pub extended_rc_cal: ble_common_opt_extended_rc_cal_t,
    _bindgen_union_align: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_ble_common_opt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_opt_t>(),
        5usize,
        concat!("Size of: ", stringify!(ble_common_opt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_opt_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_common_opt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_t>())).pa_lna as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_t),
            "::",
            stringify!(pa_lna)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_t>())).conn_evt_ext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_t),
            "::",
            stringify!(conn_evt_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_opt_t>())).extended_rc_cal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_opt_t),
            "::",
            stringify!(extended_rc_cal)
        )
    );
}
#[doc = "@brief Common BLE Option type, wrapping the module specific options."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_opt_t {
    #[doc = "< COMMON options, opt_id in @ref BLE_COMMON_OPTS series."]
    pub common_opt: ble_common_opt_t,
    #[doc = "< GAP option, opt_id in @ref BLE_GAP_OPTS series."]
    pub gap_opt: ble_gap_opt_t,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_ble_opt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_opt_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_opt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_opt_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_opt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).common_opt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_opt_t), "::", stringify!(common_opt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).gap_opt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_opt_t), "::", stringify!(gap_opt))
    );
}
#[doc = "@brief BLE connection configuration type, wrapping the module specific configurations, set with"]
#[doc = " @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @note Connection configurations don't have to be set."]
#[doc = " In the case that no configurations has been set, or fewer connection configurations has been set than enabled connections,"]
#[doc = " the default connection configuration will be automatically added for the remaining connections."]
#[doc = " When creating connections with the default configuration, @ref BLE_CONN_CFG_TAG_DEFAULT should be used in"]
#[doc = " place of @ref ble_conn_cfg_t::conn_cfg_tag."]
#[doc = ""]
#[doc = " @sa sd_ble_gap_adv_start()"]
#[doc = " @sa sd_ble_gap_connect()"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_CONN_CFG}"]
#[doc = " @endmscs"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_conn_cfg_t {
    #[doc = "< The application chosen tag it can use with the"]
    #[doc = "@ref sd_ble_gap_adv_start() and @ref sd_ble_gap_connect() calls"]
    #[doc = "to select this configuration when creating a connection."]
    #[doc = "Must be different for all connection configurations added and not @ref BLE_CONN_CFG_TAG_DEFAULT."]
    pub conn_cfg_tag: u8,
    #[doc = "< Connection configuration union."]
    pub params: ble_conn_cfg_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_conn_cfg_t__bindgen_ty_1 {
    #[doc = "< GAP connection configuration, cfg_id is @ref BLE_CONN_CFG_GAP."]
    pub gap_conn_cfg: ble_gap_conn_cfg_t,
    #[doc = "< GATTC connection configuration, cfg_id is @ref BLE_CONN_CFG_GATTC."]
    pub gattc_conn_cfg: ble_gattc_conn_cfg_t,
    #[doc = "< GATTS connection configuration, cfg_id is @ref BLE_CONN_CFG_GATTS."]
    pub gatts_conn_cfg: ble_gatts_conn_cfg_t,
    #[doc = "< GATT connection configuration, cfg_id is @ref BLE_CONN_CFG_GATT."]
    pub gatt_conn_cfg: ble_gatt_conn_cfg_t,
    #[doc = "< L2CAP connection configuration, cfg_id is @ref BLE_CONN_CFG_L2CAP."]
    pub l2cap_conn_cfg: ble_l2cap_conn_cfg_t,
    _bindgen_union_align: [u16; 4usize],
}
#[test]
fn bindgen_test_layout_ble_conn_cfg_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ble_conn_cfg_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ble_conn_cfg_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_conn_cfg_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_conn_cfg_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_conn_cfg_t__bindgen_ty_1>())).gap_conn_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_conn_cfg_t__bindgen_ty_1),
            "::",
            stringify!(gap_conn_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_conn_cfg_t__bindgen_ty_1>())).gattc_conn_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_conn_cfg_t__bindgen_ty_1),
            "::",
            stringify!(gattc_conn_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_conn_cfg_t__bindgen_ty_1>())).gatts_conn_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_conn_cfg_t__bindgen_ty_1),
            "::",
            stringify!(gatts_conn_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_conn_cfg_t__bindgen_ty_1>())).gatt_conn_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_conn_cfg_t__bindgen_ty_1),
            "::",
            stringify!(gatt_conn_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_conn_cfg_t__bindgen_ty_1>())).l2cap_conn_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_conn_cfg_t__bindgen_ty_1),
            "::",
            stringify!(l2cap_conn_cfg)
        )
    );
}
#[test]
fn bindgen_test_layout_ble_conn_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_conn_cfg_t>(),
        10usize,
        concat!("Size of: ", stringify!(ble_conn_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_conn_cfg_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ble_conn_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_conn_cfg_t>())).conn_cfg_tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_conn_cfg_t),
            "::",
            stringify!(conn_cfg_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_conn_cfg_t>())).params as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_conn_cfg_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = " @brief Configuration of Vendor Specific base UUIDs, set with @ref sd_ble_cfg_set."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Too many UUIDs configured."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_cfg_vs_uuid_t {
    #[doc = "< Number of 128-bit Vendor Specific base UUID bases to allocate memory for."]
    #[doc = "Default value is @ref BLE_UUID_VS_COUNT_DEFAULT. Maximum value is"]
    #[doc = "@ref BLE_UUID_VS_COUNT_MAX."]
    pub vs_uuid_count: u8,
}
#[test]
fn bindgen_test_layout_ble_common_cfg_vs_uuid_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_cfg_vs_uuid_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_common_cfg_vs_uuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_cfg_vs_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_common_cfg_vs_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_cfg_vs_uuid_t>())).vs_uuid_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_cfg_vs_uuid_t),
            "::",
            stringify!(vs_uuid_count)
        )
    );
}
#[doc = "@brief Common BLE Configuration type, wrapping the common configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_common_cfg_t {
    #[doc = "< Vendor Specific base UUID configuration, cfg_id is @ref BLE_COMMON_CFG_VS_UUID."]
    pub vs_uuid_cfg: ble_common_cfg_vs_uuid_t,
    _bindgen_union_align: u8,
}
#[test]
fn bindgen_test_layout_ble_common_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_common_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(ble_common_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_common_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ble_common_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_common_cfg_t>())).vs_uuid_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_common_cfg_t),
            "::",
            stringify!(vs_uuid_cfg)
        )
    );
}
#[doc = "@brief BLE Configuration type, wrapping the module specific configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_cfg_t {
    #[doc = "< Connection specific configurations, cfg_id in @ref BLE_CONN_CFGS series."]
    pub conn_cfg: ble_conn_cfg_t,
    #[doc = "< Global common configurations, cfg_id in @ref BLE_COMMON_CFGS series."]
    pub common_cfg: ble_common_cfg_t,
    #[doc = "< Global GAP configurations, cfg_id in @ref BLE_GAP_CFGS series."]
    pub gap_cfg: ble_gap_cfg_t,
    #[doc = "< Global GATTS configuration, cfg_id in @ref BLE_GATTS_CFGS series."]
    pub gatts_cfg: ble_gatts_cfg_t,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ble_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_cfg_t>(),
        12usize,
        concat!("Size of: ", stringify!(ble_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_cfg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_cfg_t>())).conn_cfg as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_cfg_t), "::", stringify!(conn_cfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_cfg_t>())).common_cfg as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_cfg_t), "::", stringify!(common_cfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_cfg_t>())).gap_cfg as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_cfg_t), "::", stringify!(gap_cfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_cfg_t>())).gatts_cfg as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ble_cfg_t), "::", stringify!(gatts_cfg))
    );
}

#[doc = "@brief Enable the BLE stack"]
#[doc = ""]
#[doc = " @param[in, out] p_app_ram_base   Pointer to a variable containing the start address of the"]
#[doc = "                                  application RAM region (APP_RAM_BASE). On return, this will"]
#[doc = "                                  contain the minimum start address of the application RAM region"]
#[doc = "                                  required by the SoftDevice for this configuration."]
#[doc = ""]
#[doc = " @note The memory requirement for a specific configuration will not increase between SoftDevices"]
#[doc = "       with the same major version number."]
#[doc = ""]
#[doc = " @note At runtime the IC's RAM is split into 2 regions: The SoftDevice RAM region is located"]
#[doc = "       between 0x20000000 and APP_RAM_BASE-1 and the application's RAM region is located between"]
#[doc = "       APP_RAM_BASE and the start of the call stack."]
#[doc = ""]
#[doc = " @details This call initializes the BLE stack, no BLE related function other than @ref"]
#[doc = "          sd_ble_cfg_set can be called before this one."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_COMMON_ENABLE}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS              The BLE stack has been initialized successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE  The BLE stack had already been initialized and cannot be reinitialized."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR   Invalid or not sufficiently aligned pointer supplied."]
#[doc = " @retval ::NRF_ERROR_NO_MEM         One or more of the following is true:"]
#[doc = "                                    - The amount of memory assigned to the SoftDevice by *p_app_ram_base is not"]
#[doc = "                                      large enough to fit this configuration's memory requirement. Check *p_app_ram_base"]
#[doc = "                                      and set the start address of the application RAM region accordingly."]
#[doc = "                                    - Dynamic part of the SoftDevice RAM region is larger then 64 kB which"]
#[doc = "                                      is currently not supported."]
#[doc = " @retval ::NRF_ERROR_RESOURCES      The total number of L2CAP Channels configured using @ref sd_ble_cfg_set is too large."]
#[inline(always)]
pub unsafe fn sd_ble_enable(p_app_ram_base: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 96",
        inout("r0") to_asm(p_app_ram_base) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add configurations for the BLE stack"]
#[doc = ""]
#[doc = " @param[in] cfg_id              Config ID, see @ref BLE_CONN_CFGS, @ref BLE_COMMON_CFGS, @ref"]
#[doc = "                                BLE_GAP_CFGS or @ref BLE_GATTS_CFGS."]
#[doc = " @param[in] p_cfg               Pointer to a ble_cfg_t structure containing the configuration value."]
#[doc = " @param[in] app_ram_base        The start address of the application RAM region (APP_RAM_BASE)."]
#[doc = "                                See @ref sd_ble_enable for details about APP_RAM_BASE."]
#[doc = ""]
#[doc = " @note The memory requirement for a specific configuration will not increase between SoftDevices"]
#[doc = "       with the same major version number."]
#[doc = ""]
#[doc = " @note If a configuration is set more than once, the last one set is the one that takes effect on"]
#[doc = "       @ref sd_ble_enable."]
#[doc = ""]
#[doc = " @note Any part of the BLE stack that is NOT configured with @ref sd_ble_cfg_set will have default"]
#[doc = "       configuration."]
#[doc = ""]
#[doc = " @note @ref sd_ble_cfg_set may be called at any time when the SoftDevice is enabled (see @ref"]
#[doc = "       sd_softdevice_enable) while the BLE part of the SoftDevice is not enabled (see @ref"]
#[doc = "       sd_ble_enable)."]
#[doc = ""]
#[doc = " @note Error codes for the configurations are described in the configuration structs."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_COMMON_ENABLE}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS              The configuration has been added successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE  The BLE stack had already been initialized."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR   Invalid or not sufficiently aligned pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM  Invalid cfg_id supplied."]
#[doc = " @retval ::NRF_ERROR_NO_MEM         The amount of memory assigned to the SoftDevice by app_ram_base is not"]
#[doc = "                                    large enough to fit this configuration's memory requirement."]
#[inline(always)]
pub unsafe fn sd_ble_cfg_set(cfg_id: u32, p_cfg: *const ble_cfg_t, app_ram_base: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 105",
        inout("r0") to_asm(cfg_id) => ret,
        inout("r1") to_asm(p_cfg) => _,
        inout("r2") to_asm(app_ram_base) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get an event from the pending events queue."]
#[doc = ""]
#[doc = " @param[out] p_dest Pointer to buffer to be filled in with an event, or NULL to retrieve the event length."]
#[doc = "                    This buffer <b>must be aligned to the extend defined by @ref BLE_EVT_PTR_ALIGNMENT</b>."]
#[doc = "                    The buffer should be interpreted as a @ref ble_evt_t struct."]
#[doc = " @param[in, out] p_len Pointer the length of the buffer, on return it is filled with the event length."]
#[doc = ""]
#[doc = " @details This call allows the application to pull a BLE event from the BLE stack. The application is signaled that"]
#[doc = " an event is available from the BLE stack by the triggering of the SD_EVT_IRQn interrupt."]
#[doc = " The application is free to choose whether to call this function from thread mode (main context) or directly from the"]
#[doc = " Interrupt Service Routine that maps to SD_EVT_IRQn. In any case however, and because the BLE stack runs at a higher"]
#[doc = " priority than the application, this function should be called in a loop (until @ref NRF_ERROR_NOT_FOUND is returned)"]
#[doc = " every time SD_EVT_IRQn is raised to ensure that all available events are pulled from the BLE stack. Failure to do so"]
#[doc = " could potentially leave events in the internal queue without the application being aware of this fact."]
#[doc = ""]
#[doc = " Sizing the p_dest buffer is equally important, since the application needs to provide all the memory necessary for the event to"]
#[doc = " be copied into application memory. If the buffer provided is not large enough to fit the entire contents of the event,"]
#[doc = " @ref NRF_ERROR_DATA_SIZE will be returned and the application can then call again with a larger buffer size."]
#[doc = " The maximum possible event length is defined by @ref BLE_EVT_LEN_MAX. The application may also \"peek\" the event length"]
#[doc = " by providing p_dest as a NULL pointer and inspecting the value of *p_len upon return:"]
#[doc = ""]
#[doc = "     \\code"]
#[doc = "     uint16_t len;"]
#[doc = "     errcode = sd_ble_evt_get(NULL, &len);"]
#[doc = "     \\endcode"]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_COMMON_IRQ_EVT_MSC}"]
#[doc = " @mmsc{@ref BLE_COMMON_THREAD_EVT_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Event pulled and stored into the supplied buffer."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND No events ready to be pulled."]
#[doc = " @retval ::NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer."]
#[inline(always)]
pub unsafe fn sd_ble_evt_get(p_dest: *mut u8, p_len: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 97",
        inout("r0") to_asm(p_dest) => ret,
        inout("r1") to_asm(p_len) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add a Vendor Specific base UUID."]
#[doc = ""]
#[doc = " @details This call enables the application to add a Vendor Specific base UUID to the BLE stack's table, for later"]
#[doc = " use with all other modules and APIs. This then allows the application to use the shorter, 24-bit @ref ble_uuid_t"]
#[doc = " format when dealing with both 16-bit and 128-bit UUIDs without having to check for lengths and having split code"]
#[doc = " paths. This is accomplished by extending the grouping mechanism that the Bluetooth SIG standard base UUID uses"]
#[doc = " for all other 128-bit UUIDs. The type field in the @ref ble_uuid_t structure is an index (relative to"]
#[doc = " @ref BLE_UUID_TYPE_VENDOR_BEGIN) to the table populated by multiple calls to this function, and the UUID field"]
#[doc = " in the same structure contains the 2 bytes at indexes 12 and 13. The number of possible 128-bit UUIDs available to"]
#[doc = " the application is therefore the number of Vendor Specific UUIDs added with the help of this function times 65536,"]
#[doc = " although restricted to modifying bytes 12 and 13 for each of the entries in the supplied array."]
#[doc = ""]
#[doc = " @note Bytes 12 and 13 of the provided UUID will not be used internally, since those are always replaced by"]
#[doc = " the 16-bit uuid field in @ref ble_uuid_t."]
#[doc = ""]
#[doc = " @note If a UUID is already present in the BLE stack's internal table, the corresponding index will be returned in"]
#[doc = " p_uuid_type along with an @ref NRF_SUCCESS error code."]
#[doc = ""]
#[doc = " @param[in]  p_vs_uuid    Pointer to a 16-octet (128-bit) little endian Vendor Specific base UUID disregarding"]
#[doc = "                          bytes 12 and 13."]
#[doc = " @param[out] p_uuid_type  Pointer to a uint8_t where the type field in @ref ble_uuid_t corresponding to this UUID will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully added the Vendor Specific base UUID."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR If p_vs_uuid or p_uuid_type is NULL or invalid."]
#[doc = " @retval ::NRF_ERROR_NO_MEM If there are no more free slots for VS UUIDs."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_vs_add(p_vs_uuid: *const ble_uuid128_t, p_uuid_type: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 98",
        inout("r0") to_asm(p_vs_uuid) => ret,
        inout("r1") to_asm(p_uuid_type) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Remove a Vendor Specific base UUID."]
#[doc = ""]
#[doc = " @details This call removes a Vendor Specific base UUID that has been added with @ref sd_ble_uuid_vs_add. This function allows"]
#[doc = " the application to reuse memory allocated for Vendor Specific base UUIDs."]
#[doc = ""]
#[doc = " @note Currently this function can only be called with a p_uuid_type set to @ref BLE_UUID_TYPE_UNKNOWN or the last added UUID type."]
#[doc = ""]
#[doc = " @param[inout] p_uuid_type Pointer to a uint8_t where its value matches the UUID type in @ref ble_uuid_t::type to be removed."]
#[doc = "                           If the type is set to @ref BLE_UUID_TYPE_UNKNOWN, or the pointer is NULL, the last Vendor Specific"]
#[doc = "                           base UUID will be removed. If the function returns successfully, the UUID type that was removed will"]
#[doc = "                           be written back to @p p_uuid_type. If function returns with a failure, it contains the last type that"]
#[doc = "                           is in use by the ATT Server."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully removed the Vendor Specific base UUID."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR If p_uuid_type is invalid."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM If p_uuid_type points to a non-valid UUID type."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN If the Vendor Specific base UUID is in use by the ATT Server."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_vs_remove(p_uuid_type: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 106",
        inout("r0") to_asm(p_uuid_type) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = " @brief Decode little endian raw UUID bytes (16-bit or 128-bit) into a 24 bit @ref ble_uuid_t structure."]
#[doc = ""]
#[doc = " @details The raw UUID bytes excluding bytes 12 and 13 (i.e. bytes 0-11 and 14-15) of p_uuid_le are compared"]
#[doc = " to the corresponding ones in each entry of the table of Vendor Specific base UUIDs populated with @ref sd_ble_uuid_vs_add"]
#[doc = " to look for a match. If there is such a match, bytes 12 and 13 are returned as p_uuid->uuid and the index"]
#[doc = " relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN as p_uuid->type."]
#[doc = ""]
#[doc = " @note If the UUID length supplied is 2, then the type set by this call will always be @ref BLE_UUID_TYPE_BLE."]
#[doc = ""]
#[doc = " @param[in]   uuid_le_len Length in bytes of the buffer pointed to by p_uuid_le (must be 2 or 16 bytes)."]
#[doc = " @param[in]   p_uuid_le   Pointer pointing to little endian raw UUID bytes."]
#[doc = " @param[out]  p_uuid      Pointer to a @ref ble_uuid_t structure to be filled in."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully decoded into the @ref ble_uuid_t structure."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH Invalid UUID length."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND For a 128-bit UUID, no match in the populated table of UUIDs."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_decode(uuid_le_len: u8, p_uuid_le: *const u8, p_uuid: *mut ble_uuid_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 99",
        inout("r0") to_asm(uuid_le_len) => ret,
        inout("r1") to_asm(p_uuid_le) => _,
        inout("r2") to_asm(p_uuid) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = " @brief Encode a @ref ble_uuid_t structure into little endian raw UUID bytes (16-bit or 128-bit)."]
#[doc = ""]
#[doc = " @note The pointer to the destination buffer p_uuid_le may be NULL, in which case only the validity and size of p_uuid is computed."]
#[doc = ""]
#[doc = " @param[in]   p_uuid        Pointer to a @ref ble_uuid_t structure that will be encoded into bytes."]
#[doc = " @param[out]  p_uuid_le_len Pointer to a uint8_t that will be filled with the encoded length (2 or 16 bytes)."]
#[doc = " @param[out]  p_uuid_le     Pointer to a buffer where the little endian raw UUID bytes (2 or 16) will be stored."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully encoded into the buffer."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid UUID type."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_encode(p_uuid: *const ble_uuid_t, p_uuid_le_len: *mut u8, p_uuid_le: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 100",
        inout("r0") to_asm(p_uuid) => ret,
        inout("r1") to_asm(p_uuid_le_len) => _,
        inout("r2") to_asm(p_uuid_le) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get Version Information."]
#[doc = ""]
#[doc = " @details This call allows the application to get the BLE stack version information."]
#[doc = ""]
#[doc = " @param[out] p_version Pointer to a ble_version_t structure to be filled in."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS  Version information stored successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY The BLE stack is busy (typically doing a locally-initiated disconnection procedure)."]
#[inline(always)]
pub unsafe fn sd_ble_version_get(p_version: *mut ble_version_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 101",
        inout("r0") to_asm(p_version) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Provide a user memory block."]
#[doc = ""]
#[doc = " @note This call can only be used as a response to a @ref BLE_EVT_USER_MEM_REQUEST event issued to the application."]
#[doc = ""]
#[doc = " @param[in] conn_handle Connection handle."]
#[doc = " @param[in] p_block Pointer to a user memory block structure or NULL if memory is managed by the application."]
#[doc = ""]
#[doc = " @mscs"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_PEER_CANCEL_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_NOAUTH_MSC}"]
#[doc = " @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}"]
#[doc = " @endmscs"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS Successfully queued a response to the peer."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH Invalid user memory block length supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Invalid Connection state or no user memory request pending."]
#[inline(always)]
pub unsafe fn sd_ble_user_mem_reply(conn_handle: u16, p_block: *const ble_user_mem_block_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 102",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_block) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set a BLE option."]
#[doc = ""]
#[doc = " @details This call allows the application to set the value of an option."]
#[doc = ""]
#[doc = " @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS."]
#[doc = " @param[in] p_opt Pointer to a ble_opt_t structure containing the option value."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS  Option set successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Unable to set the parameter at this time."]
#[doc = " @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed."]
#[inline(always)]
pub unsafe fn sd_ble_opt_set(opt_id: u32, p_opt: *const ble_opt_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 103",
        inout("r0") to_asm(opt_id) => ret,
        inout("r1") to_asm(p_opt) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get a BLE option."]
#[doc = ""]
#[doc = " @details This call allows the application to retrieve the value of an option."]
#[doc = ""]
#[doc = " @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS."]
#[doc = " @param[out] p_opt Pointer to a ble_opt_t structure to be filled in."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS  Option retrieved successfully."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[doc = " @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE Unable to retrieve the parameter at this time."]
#[doc = " @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed."]
#[doc = " @retval ::NRF_ERROR_NOT_SUPPORTED This option is not supported."]
#[doc = ""]
#[inline(always)]
pub unsafe fn sd_ble_opt_get(opt_id: u32, p_opt: *mut ble_opt_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 104",
        inout("r0") to_asm(opt_id) => ret,
        inout("r1") to_asm(p_opt) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ENABLE_GET: NRF_SOC_SVCS = 32;
pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ENABLE_SET: NRF_SOC_SVCS = 33;
pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ENABLE_CLR: NRF_SOC_SVCS = 34;
pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ASSIGN: NRF_SOC_SVCS = 35;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_TASK_ENABLE: NRF_SOC_SVCS = 36;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_TASK_DISABLE: NRF_SOC_SVCS = 37;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_ASSIGN: NRF_SOC_SVCS = 38;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_GET: NRF_SOC_SVCS = 39;
pub const NRF_SOC_SVCS_SD_FLASH_PAGE_ERASE: NRF_SOC_SVCS = 40;
pub const NRF_SOC_SVCS_SD_FLASH_WRITE: NRF_SOC_SVCS = 41;
pub const NRF_SOC_SVCS_SD_PROTECTED_REGISTER_WRITE: NRF_SOC_SVCS = 43;
pub const NRF_SOC_SVCS_SD_MUTEX_NEW: NRF_SOC_SVCS = 44;
pub const NRF_SOC_SVCS_SD_MUTEX_ACQUIRE: NRF_SOC_SVCS = 45;
pub const NRF_SOC_SVCS_SD_MUTEX_RELEASE: NRF_SOC_SVCS = 46;
pub const NRF_SOC_SVCS_SD_RAND_APPLICATION_POOL_CAPACITY_GET: NRF_SOC_SVCS = 47;
pub const NRF_SOC_SVCS_SD_RAND_APPLICATION_BYTES_AVAILABLE_GET: NRF_SOC_SVCS = 48;
pub const NRF_SOC_SVCS_SD_RAND_APPLICATION_VECTOR_GET: NRF_SOC_SVCS = 49;
pub const NRF_SOC_SVCS_SD_POWER_MODE_SET: NRF_SOC_SVCS = 50;
pub const NRF_SOC_SVCS_SD_POWER_SYSTEM_OFF: NRF_SOC_SVCS = 51;
pub const NRF_SOC_SVCS_SD_POWER_RESET_REASON_GET: NRF_SOC_SVCS = 52;
pub const NRF_SOC_SVCS_SD_POWER_RESET_REASON_CLR: NRF_SOC_SVCS = 53;
pub const NRF_SOC_SVCS_SD_POWER_POF_ENABLE: NRF_SOC_SVCS = 54;
pub const NRF_SOC_SVCS_SD_POWER_POF_THRESHOLD_SET: NRF_SOC_SVCS = 55;
pub const NRF_SOC_SVCS_SD_POWER_POF_THRESHOLDVDDH_SET: NRF_SOC_SVCS = 56;
pub const NRF_SOC_SVCS_SD_POWER_RAM_POWER_SET: NRF_SOC_SVCS = 57;
pub const NRF_SOC_SVCS_SD_POWER_RAM_POWER_CLR: NRF_SOC_SVCS = 58;
pub const NRF_SOC_SVCS_SD_POWER_RAM_POWER_GET: NRF_SOC_SVCS = 59;
pub const NRF_SOC_SVCS_SD_POWER_GPREGRET_SET: NRF_SOC_SVCS = 60;
pub const NRF_SOC_SVCS_SD_POWER_GPREGRET_CLR: NRF_SOC_SVCS = 61;
pub const NRF_SOC_SVCS_SD_POWER_GPREGRET_GET: NRF_SOC_SVCS = 62;
pub const NRF_SOC_SVCS_SD_POWER_DCDC_MODE_SET: NRF_SOC_SVCS = 63;
pub const NRF_SOC_SVCS_SD_POWER_DCDC0_MODE_SET: NRF_SOC_SVCS = 64;
pub const NRF_SOC_SVCS_SD_APP_EVT_WAIT: NRF_SOC_SVCS = 65;
pub const NRF_SOC_SVCS_SD_CLOCK_HFCLK_REQUEST: NRF_SOC_SVCS = 66;
pub const NRF_SOC_SVCS_SD_CLOCK_HFCLK_RELEASE: NRF_SOC_SVCS = 67;
pub const NRF_SOC_SVCS_SD_CLOCK_HFCLK_IS_RUNNING: NRF_SOC_SVCS = 68;
pub const NRF_SOC_SVCS_SD_RADIO_NOTIFICATION_CFG_SET: NRF_SOC_SVCS = 69;
pub const NRF_SOC_SVCS_SD_ECB_BLOCK_ENCRYPT: NRF_SOC_SVCS = 70;
pub const NRF_SOC_SVCS_SD_ECB_BLOCKS_ENCRYPT: NRF_SOC_SVCS = 71;
pub const NRF_SOC_SVCS_SD_RADIO_SESSION_OPEN: NRF_SOC_SVCS = 72;
pub const NRF_SOC_SVCS_SD_RADIO_SESSION_CLOSE: NRF_SOC_SVCS = 73;
pub const NRF_SOC_SVCS_SD_RADIO_REQUEST: NRF_SOC_SVCS = 74;
pub const NRF_SOC_SVCS_SD_EVT_GET: NRF_SOC_SVCS = 75;
pub const NRF_SOC_SVCS_SD_TEMP_GET: NRF_SOC_SVCS = 76;
pub const NRF_SOC_SVCS_SD_POWER_USBPWRRDY_ENABLE: NRF_SOC_SVCS = 77;
pub const NRF_SOC_SVCS_SD_POWER_USBDETECTED_ENABLE: NRF_SOC_SVCS = 78;
pub const NRF_SOC_SVCS_SD_POWER_USBREMOVED_ENABLE: NRF_SOC_SVCS = 79;
pub const NRF_SOC_SVCS_SD_POWER_USBREGSTATUS_GET: NRF_SOC_SVCS = 80;
pub const NRF_SOC_SVCS_SVC_SOC_LAST: NRF_SOC_SVCS = 81;
#[doc = "@brief The SVC numbers used by the SVC functions in the SoC library."]
pub type NRF_SOC_SVCS = self::c_uint;
pub const NRF_MUTEX_VALUES_NRF_MUTEX_FREE: NRF_MUTEX_VALUES = 0;
pub const NRF_MUTEX_VALUES_NRF_MUTEX_TAKEN: NRF_MUTEX_VALUES = 1;
#[doc = "@brief Possible values of a ::nrf_mutex_t."]
pub type NRF_MUTEX_VALUES = self::c_uint;
#[doc = "< Constant latency mode. See power management in the reference manual."]
pub const NRF_POWER_MODES_NRF_POWER_MODE_CONSTLAT: NRF_POWER_MODES = 0;
#[doc = "< Low power mode. See power management in the reference manual."]
pub const NRF_POWER_MODES_NRF_POWER_MODE_LOWPWR: NRF_POWER_MODES = 1;
#[doc = "@brief Power modes."]
pub type NRF_POWER_MODES = self::c_uint;
#[doc = "< 1.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V17: NRF_POWER_THRESHOLDS = 4;
#[doc = "< 1.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V18: NRF_POWER_THRESHOLDS = 5;
#[doc = "< 1.9 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V19: NRF_POWER_THRESHOLDS = 6;
#[doc = "< 2.0 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V20: NRF_POWER_THRESHOLDS = 7;
#[doc = "< 2.1 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V21: NRF_POWER_THRESHOLDS = 8;
#[doc = "< 2.2 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V22: NRF_POWER_THRESHOLDS = 9;
#[doc = "< 2.3 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V23: NRF_POWER_THRESHOLDS = 10;
#[doc = "< 2.4 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V24: NRF_POWER_THRESHOLDS = 11;
#[doc = "< 2.5 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V25: NRF_POWER_THRESHOLDS = 12;
#[doc = "< 2.6 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V26: NRF_POWER_THRESHOLDS = 13;
#[doc = "< 2.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V27: NRF_POWER_THRESHOLDS = 14;
#[doc = "< 2.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V28: NRF_POWER_THRESHOLDS = 15;
#[doc = "@brief Power failure thresholds"]
pub type NRF_POWER_THRESHOLDS = self::c_uint;
#[doc = "< 2.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V27: NRF_POWER_THRESHOLDVDDHS = 0;
#[doc = "< 2.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V28: NRF_POWER_THRESHOLDVDDHS = 1;
#[doc = "< 2.9 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V29: NRF_POWER_THRESHOLDVDDHS = 2;
#[doc = "< 3.0 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V30: NRF_POWER_THRESHOLDVDDHS = 3;
#[doc = "< 3.1 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V31: NRF_POWER_THRESHOLDVDDHS = 4;
#[doc = "< 3.2 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V32: NRF_POWER_THRESHOLDVDDHS = 5;
#[doc = "< 3.3 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V33: NRF_POWER_THRESHOLDVDDHS = 6;
#[doc = "< 3.4 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V34: NRF_POWER_THRESHOLDVDDHS = 7;
#[doc = "< 3.5 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V35: NRF_POWER_THRESHOLDVDDHS = 8;
#[doc = "< 3.6 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V36: NRF_POWER_THRESHOLDVDDHS = 9;
#[doc = "< 3.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V37: NRF_POWER_THRESHOLDVDDHS = 10;
#[doc = "< 3.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V38: NRF_POWER_THRESHOLDVDDHS = 11;
#[doc = "< 3.9 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V39: NRF_POWER_THRESHOLDVDDHS = 12;
#[doc = "< 4.0 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V40: NRF_POWER_THRESHOLDVDDHS = 13;
#[doc = "< 4.1 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V41: NRF_POWER_THRESHOLDVDDHS = 14;
#[doc = "< 4.2 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V42: NRF_POWER_THRESHOLDVDDHS = 15;
#[doc = "@brief Power failure thresholds for high voltage"]
pub type NRF_POWER_THRESHOLDVDDHS = self::c_uint;
#[doc = "< The DCDC is disabled."]
pub const NRF_POWER_DCDC_MODES_NRF_POWER_DCDC_DISABLE: NRF_POWER_DCDC_MODES = 0;
#[doc = "< The DCDC is enabled."]
pub const NRF_POWER_DCDC_MODES_NRF_POWER_DCDC_ENABLE: NRF_POWER_DCDC_MODES = 1;
#[doc = "@brief DC/DC converter modes."]
pub type NRF_POWER_DCDC_MODES = self::c_uint;
#[doc = "< The event does not have a notification."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_NONE: NRF_RADIO_NOTIFICATION_DISTANCES = 0;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_800US: NRF_RADIO_NOTIFICATION_DISTANCES = 1;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_1740US: NRF_RADIO_NOTIFICATION_DISTANCES = 2;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_2680US: NRF_RADIO_NOTIFICATION_DISTANCES = 3;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_3620US: NRF_RADIO_NOTIFICATION_DISTANCES = 4;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_4560US: NRF_RADIO_NOTIFICATION_DISTANCES = 5;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_5500US: NRF_RADIO_NOTIFICATION_DISTANCES = 6;
#[doc = "@brief Radio notification distances."]
pub type NRF_RADIO_NOTIFICATION_DISTANCES = self::c_uint;
#[doc = "< The event does not have a radio notification signal."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_NONE: NRF_RADIO_NOTIFICATION_TYPES = 0;
#[doc = "< Using interrupt for notification when the radio will be enabled."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE: NRF_RADIO_NOTIFICATION_TYPES = 1;
#[doc = "< Using interrupt for notification when the radio has been disabled."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE: NRF_RADIO_NOTIFICATION_TYPES = 2;
#[doc = "< Using interrupt for notification both when the radio will be enabled and disabled."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH: NRF_RADIO_NOTIFICATION_TYPES = 3;
#[doc = "@brief Radio notification types."]
pub type NRF_RADIO_NOTIFICATION_TYPES = self::c_uint;
#[doc = "< This signal indicates the start of the radio timeslot."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_START: NRF_RADIO_CALLBACK_SIGNAL_TYPE = 0;
#[doc = "< This signal indicates the NRF_TIMER0 interrupt."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0: NRF_RADIO_CALLBACK_SIGNAL_TYPE = 1;
#[doc = "< This signal indicates the NRF_RADIO interrupt."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO: NRF_RADIO_CALLBACK_SIGNAL_TYPE = 2;
#[doc = "< This signal indicates extend action failed."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED: NRF_RADIO_CALLBACK_SIGNAL_TYPE =
    3;
#[doc = "< This signal indicates extend action succeeded."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED:
    NRF_RADIO_CALLBACK_SIGNAL_TYPE = 4;
#[doc = "@brief The Radio signal callback types."]
pub type NRF_RADIO_CALLBACK_SIGNAL_TYPE = self::c_uint;
#[doc = "< Return without action."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE: NRF_RADIO_SIGNAL_CALLBACK_ACTION = 0;
#[doc = "< Request an extension of the current"]
#[doc = "timeslot. Maximum execution time for this action:"]
#[doc = "@ref NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US."]
#[doc = "This action must be started at least"]
#[doc = "@ref NRF_RADIO_MIN_EXTENSION_MARGIN_US before"]
#[doc = "the end of the timeslot."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND: NRF_RADIO_SIGNAL_CALLBACK_ACTION =
    1;
#[doc = "< End the current radio timeslot."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_END: NRF_RADIO_SIGNAL_CALLBACK_ACTION = 2;
#[doc = "< Request a new radio timeslot and end the current timeslot."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END:
    NRF_RADIO_SIGNAL_CALLBACK_ACTION = 3;
#[doc = "@brief The actions requested by the signal callback."]
#[doc = ""]
#[doc = "  This code gives the SOC instructions about what action to take when the signal callback has"]
#[doc = "  returned."]
pub type NRF_RADIO_SIGNAL_CALLBACK_ACTION = self::c_uint;
#[doc = "< The SoftDevice will guarantee that the high frequency clock source is the"]
#[doc = "external crystal for the whole duration of the timeslot. This should be the"]
#[doc = "preferred option for events that use the radio or require high timing accuracy."]
#[doc = "@note The SoftDevice will automatically turn on and off the external crystal,"]
#[doc = "at the beginning and end of the timeslot, respectively. The crystal may also"]
#[doc = "intentionally be left running after the timeslot, in cases where it is needed"]
#[doc = "by the SoftDevice shortly after the end of the timeslot."]
pub const NRF_RADIO_HFCLK_CFG_NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED: NRF_RADIO_HFCLK_CFG = 0;
#[doc = "< This configuration allows for earlier and tighter scheduling of timeslots."]
#[doc = "The RC oscillator may be the clock source in part or for the whole duration of the timeslot."]
#[doc = "The RC oscillator's accuracy must therefore be taken into consideration."]
#[doc = "@note If the application will use the radio peripheral in timeslots with this configuration,"]
#[doc = "it must make sure that the crystal is running and stable before starting the radio."]
pub const NRF_RADIO_HFCLK_CFG_NRF_RADIO_HFCLK_CFG_NO_GUARANTEE: NRF_RADIO_HFCLK_CFG = 1;
#[doc = "@brief Radio timeslot high frequency clock source configuration."]
pub type NRF_RADIO_HFCLK_CFG = self::c_uint;
#[doc = "< High (equal priority as the normal connection priority of the SoftDevice stack(s))."]
pub const NRF_RADIO_PRIORITY_NRF_RADIO_PRIORITY_HIGH: NRF_RADIO_PRIORITY = 0;
#[doc = "< Normal (equal priority as the priority of secondary activities of the SoftDevice stack(s))."]
pub const NRF_RADIO_PRIORITY_NRF_RADIO_PRIORITY_NORMAL: NRF_RADIO_PRIORITY = 1;
#[doc = "@brief Radio timeslot priorities."]
pub type NRF_RADIO_PRIORITY = self::c_uint;
#[doc = "< Request radio timeslot as early as possible. This should always be used for the first request in a session."]
pub const NRF_RADIO_REQUEST_TYPE_NRF_RADIO_REQ_TYPE_EARLIEST: NRF_RADIO_REQUEST_TYPE = 0;
#[doc = "< Normal radio timeslot request."]
pub const NRF_RADIO_REQUEST_TYPE_NRF_RADIO_REQ_TYPE_NORMAL: NRF_RADIO_REQUEST_TYPE = 1;
#[doc = "@brief Radio timeslot request type."]
pub type NRF_RADIO_REQUEST_TYPE = self::c_uint;
#[doc = "< Event indicating that the HFCLK has started."]
pub const NRF_SOC_EVTS_NRF_EVT_HFCLKSTARTED: NRF_SOC_EVTS = 0;
#[doc = "< Event indicating that a power failure warning has occurred."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_FAILURE_WARNING: NRF_SOC_EVTS = 1;
#[doc = "< Event indicating that the ongoing flash operation has completed successfully."]
pub const NRF_SOC_EVTS_NRF_EVT_FLASH_OPERATION_SUCCESS: NRF_SOC_EVTS = 2;
#[doc = "< Event indicating that the ongoing flash operation has timed out with an error."]
pub const NRF_SOC_EVTS_NRF_EVT_FLASH_OPERATION_ERROR: NRF_SOC_EVTS = 3;
#[doc = "< Event indicating that a radio timeslot was blocked."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_BLOCKED: NRF_SOC_EVTS = 4;
#[doc = "< Event indicating that a radio timeslot was canceled by SoftDevice."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_CANCELED: NRF_SOC_EVTS = 5;
#[doc = "< Event indicating that a radio timeslot signal callback handler return was invalid."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN: NRF_SOC_EVTS = 6;
#[doc = "< Event indicating that a radio timeslot session is idle."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_SESSION_IDLE: NRF_SOC_EVTS = 7;
#[doc = "< Event indicating that a radio timeslot session is closed."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_SESSION_CLOSED: NRF_SOC_EVTS = 8;
#[doc = "< Event indicating that a USB 3.3 V supply is ready."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_USB_POWER_READY: NRF_SOC_EVTS = 9;
#[doc = "< Event indicating that voltage supply is detected on VBUS."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_USB_DETECTED: NRF_SOC_EVTS = 10;
#[doc = "< Event indicating that voltage supply is removed from VBUS."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_USB_REMOVED: NRF_SOC_EVTS = 11;
pub const NRF_SOC_EVTS_NRF_EVT_NUMBER_OF_EVTS: NRF_SOC_EVTS = 12;
#[doc = "@brief SoC Events."]
pub type NRF_SOC_EVTS = self::c_uint;
#[doc = "@brief Represents a mutex for use with the nrf_mutex functions."]
#[doc = " @note Accessing the value directly is not safe, use the mutex functions!"]
pub type nrf_mutex_t = u8;
#[doc = "@brief Parameters for a request for a timeslot as early as possible."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_request_earliest_t {
    #[doc = "< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY."]
    pub priority: u8,
    #[doc = "< The radio timeslot length (in the range 100 to 100,000] microseconds)."]
    pub length_us: u32,
    #[doc = "< Longest acceptable delay until the start of the requested timeslot (up to @ref NRF_RADIO_EARLIEST_TIMEOUT_MAX_US microseconds)."]
    pub timeout_us: u32,
}
#[test]
fn bindgen_test_layout_nrf_radio_request_earliest_t() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_request_earliest_t>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_radio_request_earliest_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_request_earliest_t>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_radio_request_earliest_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_earliest_t>())).hfclk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_earliest_t),
            "::",
            stringify!(hfclk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_earliest_t>())).priority as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_earliest_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_earliest_t>())).length_us as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_earliest_t),
            "::",
            stringify!(length_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_earliest_t>())).timeout_us as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_earliest_t),
            "::",
            stringify!(timeout_us)
        )
    );
}
#[doc = "@brief Parameters for a normal radio timeslot request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_request_normal_t {
    #[doc = "< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY."]
    pub priority: u8,
    #[doc = "< Distance from the start of the previous radio timeslot (up to @ref NRF_RADIO_DISTANCE_MAX_US microseconds)."]
    pub distance_us: u32,
    #[doc = "< The radio timeslot length (in the range [100..100,000] microseconds)."]
    pub length_us: u32,
}
#[test]
fn bindgen_test_layout_nrf_radio_request_normal_t() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_request_normal_t>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_radio_request_normal_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_request_normal_t>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_radio_request_normal_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_normal_t>())).hfclk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_normal_t),
            "::",
            stringify!(hfclk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_normal_t>())).priority as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_normal_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_normal_t>())).distance_us as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_normal_t),
            "::",
            stringify!(distance_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_normal_t>())).length_us as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_normal_t),
            "::",
            stringify!(length_us)
        )
    );
}
#[doc = "@brief Radio timeslot request parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nrf_radio_request_t {
    #[doc = "< Type of request, see @ref NRF_RADIO_REQUEST_TYPE."]
    pub request_type: u8,
    #[doc = "< Parameter union."]
    pub params: nrf_radio_request_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nrf_radio_request_t__bindgen_ty_1 {
    #[doc = "< Parameters for requesting a radio timeslot as early as possible."]
    pub earliest: nrf_radio_request_earliest_t,
    #[doc = "< Parameters for requesting a normal radio timeslot."]
    pub normal: nrf_radio_request_normal_t,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nrf_radio_request_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_request_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_radio_request_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_request_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_radio_request_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_t__bindgen_ty_1>())).earliest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_t__bindgen_ty_1),
            "::",
            stringify!(earliest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_t__bindgen_ty_1>())).normal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_t__bindgen_ty_1),
            "::",
            stringify!(normal)
        )
    );
}
#[test]
fn bindgen_test_layout_nrf_radio_request_t() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(nrf_radio_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_radio_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_t>())).request_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_t),
            "::",
            stringify!(request_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_request_t>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_request_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = "@brief Return parameters of the radio timeslot signal callback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nrf_radio_signal_callback_return_param_t {
    #[doc = "< The action requested by the application when returning from the signal callback, see @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION."]
    pub callback_action: u8,
    #[doc = "< Parameter union."]
    pub params: nrf_radio_signal_callback_return_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nrf_radio_signal_callback_return_param_t__bindgen_ty_1 {
    #[doc = "< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END."]
    pub request: nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND."]
    pub extend: nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The request parameters for the next radio timeslot."]
    pub p_next: *mut nrf_radio_request_t,
}
#[test]
fn bindgen_test_layout_nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1>())).p_next
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(p_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Requested extension of the radio timeslot duration (microseconds) (for minimum time see @ref NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US)."]
    pub length_us: u32,
}
#[test]
fn bindgen_test_layout_nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2>())).length_us
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(length_us)
        )
    );
}
#[test]
fn bindgen_test_layout_nrf_radio_signal_callback_return_param_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1>())).request as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1>())).extend as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1),
            "::",
            stringify!(extend)
        )
    );
}
#[test]
fn bindgen_test_layout_nrf_radio_signal_callback_return_param_t() {
    assert_eq!(
        ::core::mem::size_of::<nrf_radio_signal_callback_return_param_t>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_radio_signal_callback_return_param_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_radio_signal_callback_return_param_t>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_radio_signal_callback_return_param_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nrf_radio_signal_callback_return_param_t>())).callback_action as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_signal_callback_return_param_t),
            "::",
            stringify!(callback_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_radio_signal_callback_return_param_t>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_radio_signal_callback_return_param_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = "@brief The radio timeslot signal callback type."]
#[doc = ""]
#[doc = " @note In case of invalid return parameters, the radio timeslot will automatically end"]
#[doc = "       immediately after returning from the signal callback and the"]
#[doc = "       @ref NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN event will be sent."]
#[doc = " @note The returned struct pointer must remain valid after the signal callback"]
#[doc = "       function returns. For instance, this means that it must not point to a stack variable."]
#[doc = ""]
#[doc = " @param[in] signal_type Type of signal, see @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE."]
#[doc = ""]
#[doc = " @return Pointer to structure containing action requested by the application."]
pub type nrf_radio_signal_callback_t =
    ::core::option::Option<unsafe extern "C" fn(signal_type: u8) -> *mut nrf_radio_signal_callback_return_param_t>;
#[doc = "@brief AES ECB parameter typedefs"]
pub type soc_ecb_key_t = [u8; 16usize];
pub type soc_ecb_cleartext_t = [u8; 16usize];
pub type soc_ecb_ciphertext_t = [u8; 16usize];
#[doc = "@brief AES ECB data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_ecb_hal_data_t {
    #[doc = "< Encryption key."]
    pub key: soc_ecb_key_t,
    #[doc = "< Cleartext data."]
    pub cleartext: soc_ecb_cleartext_t,
    #[doc = "< Ciphertext data."]
    pub ciphertext: soc_ecb_ciphertext_t,
}
#[test]
fn bindgen_test_layout_nrf_ecb_hal_data_t() {
    assert_eq!(
        ::core::mem::size_of::<nrf_ecb_hal_data_t>(),
        48usize,
        concat!("Size of: ", stringify!(nrf_ecb_hal_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_ecb_hal_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_ecb_hal_data_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_ecb_hal_data_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_ecb_hal_data_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_ecb_hal_data_t>())).cleartext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_ecb_hal_data_t),
            "::",
            stringify!(cleartext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_ecb_hal_data_t>())).ciphertext as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_ecb_hal_data_t),
            "::",
            stringify!(ciphertext)
        )
    );
}
#[doc = "@brief AES ECB block. Used to provide multiple blocks in a single call"]
#[doc = "to @ref sd_ecb_blocks_encrypt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_ecb_hal_data_block_t {
    #[doc = "< Pointer to the Encryption key."]
    pub p_key: *const soc_ecb_key_t,
    #[doc = "< Pointer to the Cleartext data."]
    pub p_cleartext: *const soc_ecb_cleartext_t,
    #[doc = "< Pointer to the Ciphertext data."]
    pub p_ciphertext: *mut soc_ecb_ciphertext_t,
}
#[test]
fn bindgen_test_layout_nrf_ecb_hal_data_block_t() {
    assert_eq!(
        ::core::mem::size_of::<nrf_ecb_hal_data_block_t>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_ecb_hal_data_block_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_ecb_hal_data_block_t>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_ecb_hal_data_block_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_ecb_hal_data_block_t>())).p_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_ecb_hal_data_block_t),
            "::",
            stringify!(p_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_ecb_hal_data_block_t>())).p_cleartext as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_ecb_hal_data_block_t),
            "::",
            stringify!(p_cleartext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_ecb_hal_data_block_t>())).p_ciphertext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_ecb_hal_data_block_t),
            "::",
            stringify!(p_ciphertext)
        )
    );
}

#[doc = "@brief Initialize a mutex."]
#[doc = ""]
#[doc = " @param[in] p_mutex Pointer to the mutex to initialize."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_mutex_new(p_mutex: *mut nrf_mutex_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 44",
        inout("r0") to_asm(p_mutex) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Attempt to acquire a mutex."]
#[doc = ""]
#[doc = " @param[in] p_mutex Pointer to the mutex to acquire."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The mutex was successfully acquired."]
#[doc = " @retval ::NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN The mutex could not be acquired."]
#[inline(always)]
pub unsafe fn sd_mutex_acquire(p_mutex: *mut nrf_mutex_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 45",
        inout("r0") to_asm(p_mutex) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Release a mutex."]
#[doc = ""]
#[doc = " @param[in] p_mutex Pointer to the mutex to release."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_mutex_release(p_mutex: *mut nrf_mutex_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 46",
        inout("r0") to_asm(p_mutex) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Query the capacity of the application random pool."]
#[doc = ""]
#[doc = " @param[out] p_pool_capacity The capacity of the pool."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_rand_application_pool_capacity_get(p_pool_capacity: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 47",
        inout("r0") to_asm(p_pool_capacity) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get number of random bytes available to the application."]
#[doc = ""]
#[doc = " @param[out] p_bytes_available The number of bytes currently available in the pool."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_rand_application_bytes_available_get(p_bytes_available: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 48",
        inout("r0") to_asm(p_bytes_available) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get random bytes from the application pool."]
#[doc = ""]
#[doc = " @param[out]  p_buff  Pointer to unit8_t buffer for storing the bytes."]
#[doc = " @param[in]   length  Number of bytes to take from pool and place in p_buff."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The requested bytes were written to p_buff."]
#[doc = " @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available."]
#[inline(always)]
pub unsafe fn sd_rand_application_vector_get(p_buff: *mut u8, length: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 49",
        inout("r0") to_asm(p_buff) => ret,
        inout("r1") to_asm(length) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Gets the reset reason register."]
#[doc = ""]
#[doc = " @param[out]  p_reset_reason  Contents of the NRF_POWER->RESETREAS register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_reset_reason_get(p_reset_reason: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 52",
        inout("r0") to_asm(p_reset_reason) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Clears the bits of the reset reason register."]
#[doc = ""]
#[doc = " @param[in] reset_reason_clr_msk Contains the bits to clear from the reset reason register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_reset_reason_clr(reset_reason_clr_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 53",
        inout("r0") to_asm(reset_reason_clr_msk) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the power mode when in CPU sleep."]
#[doc = ""]
#[doc = " @param[in] power_mode The power mode to use when in CPU sleep, see @ref NRF_POWER_MODES. @sa sd_app_evt_wait"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The power mode was set."]
#[doc = " @retval ::NRF_ERROR_SOC_POWER_MODE_UNKNOWN The power mode was unknown."]
#[inline(always)]
pub unsafe fn sd_power_mode_set(power_mode: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 50",
        inout("r0") to_asm(power_mode) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Puts the chip in System OFF mode."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN"]
#[inline(always)]
pub unsafe fn sd_power_system_off() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 51",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the power-fail comparator."]
#[doc = ""]
#[doc = " Enabling this will give a SoftDevice event (NRF_EVT_POWER_FAILURE_WARNING) when the power failure warning occurs."]
#[doc = " The event can be retrieved with sd_evt_get();"]
#[doc = ""]
#[doc = " @param[in] pof_enable    True if the power-fail comparator should be enabled, false if it should be disabled."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_pof_enable(pof_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 54",
        inout("r0") to_asm(pof_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the USB power ready event."]
#[doc = ""]
#[doc = " Enabling this will give a SoftDevice event (NRF_EVT_POWER_USB_POWER_READY) when a USB 3.3 V supply is ready."]
#[doc = " The event can be retrieved with sd_evt_get();"]
#[doc = ""]
#[doc = " @param[in] usbpwrrdy_enable    True if the power ready event should be enabled, false if it should be disabled."]
#[doc = ""]
#[doc = " @note Calling this function on a chip without USBD peripheral will result in undefined behaviour."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbpwrrdy_enable(usbpwrrdy_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 77",
        inout("r0") to_asm(usbpwrrdy_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the power USB-detected event."]
#[doc = ""]
#[doc = " Enabling this will give a SoftDevice event (NRF_EVT_POWER_USB_DETECTED) when a voltage supply is detected on VBUS."]
#[doc = " The event can be retrieved with sd_evt_get();"]
#[doc = ""]
#[doc = " @param[in] usbdetected_enable    True if the power ready event should be enabled, false if it should be disabled."]
#[doc = ""]
#[doc = " @note Calling this function on a chip without USBD peripheral will result in undefined behaviour."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbdetected_enable(usbdetected_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 78",
        inout("r0") to_asm(usbdetected_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the power USB-removed event."]
#[doc = ""]
#[doc = " Enabling this will give a SoftDevice event (NRF_EVT_POWER_USB_REMOVED) when a voltage supply is removed from VBUS."]
#[doc = " The event can be retrieved with sd_evt_get();"]
#[doc = ""]
#[doc = " @param[in] usbremoved_enable    True if the power ready event should be enabled, false if it should be disabled."]
#[doc = ""]
#[doc = " @note Calling this function on a chip without USBD peripheral will result in undefined behaviour."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbremoved_enable(usbremoved_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 79",
        inout("r0") to_asm(usbremoved_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get USB supply status register content."]
#[doc = ""]
#[doc = " @param[out] usbregstatus    The content of USBREGSTATUS register."]
#[doc = ""]
#[doc = " @note Calling this function on a chip without USBD peripheral will result in undefined behaviour."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbregstatus_get(usbregstatus: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 80",
        inout("r0") to_asm(usbregstatus) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the power failure comparator threshold value."]
#[doc = ""]
#[doc = " @note: Power failure comparator threshold setting. This setting applies both for normal voltage"]
#[doc = "        mode (supply connected to both VDD and VDDH) and high voltage mode (supply connected to"]
#[doc = "        VDDH only)."]
#[doc = ""]
#[doc = " @param[in] threshold The power-fail threshold value to use, see @ref NRF_POWER_THRESHOLDS."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The power failure threshold was set."]
#[doc = " @retval ::NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN The power failure threshold is unknown."]
#[inline(always)]
pub unsafe fn sd_power_pof_threshold_set(threshold: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 55",
        inout("r0") to_asm(threshold) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the power failure comparator threshold value for high voltage."]
#[doc = ""]
#[doc = " @note: Power failure comparator threshold setting for high voltage mode (supply connected to"]
#[doc = "        VDDH only). This setting does not apply for normal voltage mode (supply connected to both"]
#[doc = "        VDD and VDDH)."]
#[doc = ""]
#[doc = " @param[in] threshold The power-fail threshold value to use, see @ref NRF_POWER_THRESHOLDVDDHS."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS The power failure threshold was set."]
#[doc = " @retval ::NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN The power failure threshold is unknown."]
#[inline(always)]
pub unsafe fn sd_power_pof_thresholdvddh_set(threshold: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 56",
        inout("r0") to_asm(threshold) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Writes the NRF_POWER->RAM[index].POWERSET register."]
#[doc = ""]
#[doc = " @param[in] index Contains the index in the NRF_POWER->RAM[index].POWERSET register to write to."]
#[doc = " @param[in] ram_powerset Contains the word to write to the NRF_POWER->RAM[index].POWERSET register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_ram_power_set(index: u8, ram_powerset: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 57",
        inout("r0") to_asm(index) => ret,
        inout("r1") to_asm(ram_powerset) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Writes the NRF_POWER->RAM[index].POWERCLR register."]
#[doc = ""]
#[doc = " @param[in] index Contains the index in the NRF_POWER->RAM[index].POWERCLR register to write to."]
#[doc = " @param[in] ram_powerclr Contains the word to write to the NRF_POWER->RAM[index].POWERCLR register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_ram_power_clr(index: u8, ram_powerclr: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 58",
        inout("r0") to_asm(index) => ret,
        inout("r1") to_asm(ram_powerclr) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get contents of NRF_POWER->RAM[index].POWER register, indicates power status of RAM[index] blocks."]
#[doc = ""]
#[doc = " @param[in] index Contains the index in the NRF_POWER->RAM[index].POWER register to read from."]
#[doc = " @param[out] p_ram_power Content of NRF_POWER->RAM[index].POWER register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_ram_power_get(index: u8, p_ram_power: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 59",
        inout("r0") to_asm(index) => ret,
        inout("r1") to_asm(p_ram_power) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set bits in the general purpose retention registers (NRF_POWER->GPREGRET*)."]
#[doc = ""]
#[doc = " @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2."]
#[doc = " @param[in] gpregret_msk Bits to be set in the GPREGRET register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_gpregret_set(gpregret_id: u32, gpregret_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 60",
        inout("r0") to_asm(gpregret_id) => ret,
        inout("r1") to_asm(gpregret_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Clear bits in the general purpose retention registers (NRF_POWER->GPREGRET*)."]
#[doc = ""]
#[doc = " @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2."]
#[doc = " @param[in] gpregret_msk Bits to be clear in the GPREGRET register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_gpregret_clr(gpregret_id: u32, gpregret_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 61",
        inout("r0") to_asm(gpregret_id) => ret,
        inout("r1") to_asm(gpregret_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get contents of the general purpose retention registers (NRF_POWER->GPREGRET*)."]
#[doc = ""]
#[doc = " @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2."]
#[doc = " @param[out] p_gpregret Contents of the GPREGRET register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_gpregret_get(gpregret_id: u32, p_gpregret: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 62",
        inout("r0") to_asm(gpregret_id) => ret,
        inout("r1") to_asm(p_gpregret) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enable or disable the DC/DC regulator for the regulator stage 1 (REG1)."]
#[doc = ""]
#[doc = " @param[in] dcdc_mode The mode of the DCDC, see @ref NRF_POWER_DCDC_MODES."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM The DCDC mode is invalid."]
#[inline(always)]
pub unsafe fn sd_power_dcdc_mode_set(dcdc_mode: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 63",
        inout("r0") to_asm(dcdc_mode) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enable or disable the DC/DC regulator for the regulator stage 0 (REG0)."]
#[doc = ""]
#[doc = " For more details on the REG0 stage, please see product specification."]
#[doc = ""]
#[doc = " @param[in] dcdc_mode The mode of the DCDC0, see @ref NRF_POWER_DCDC_MODES."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM The dcdc_mode is invalid."]
#[inline(always)]
pub unsafe fn sd_power_dcdc0_mode_set(dcdc_mode: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 64",
        inout("r0") to_asm(dcdc_mode) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Request the high frequency crystal oscillator."]
#[doc = ""]
#[doc = " Will start the high frequency crystal oscillator, the startup time of the crystal varies"]
#[doc = " and the ::sd_clock_hfclk_is_running function can be polled to check if it has started."]
#[doc = ""]
#[doc = " @see sd_clock_hfclk_is_running"]
#[doc = " @see sd_clock_hfclk_release"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_clock_hfclk_request() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 66",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Releases the high frequency crystal oscillator."]
#[doc = ""]
#[doc = " Will stop the high frequency crystal oscillator, this happens immediately."]
#[doc = ""]
#[doc = " @see sd_clock_hfclk_is_running"]
#[doc = " @see sd_clock_hfclk_request"]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_clock_hfclk_release() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 67",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Checks if the high frequency crystal oscillator is running."]
#[doc = ""]
#[doc = " @see sd_clock_hfclk_request"]
#[doc = " @see sd_clock_hfclk_release"]
#[doc = ""]
#[doc = " @param[out] p_is_running 1 if the external crystal oscillator is running, 0 if not."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_clock_hfclk_is_running(p_is_running: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 68",
        inout("r0") to_asm(p_is_running) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Waits for an application event."]
#[doc = ""]
#[doc = " An application event is either an application interrupt or a pended interrupt when the interrupt"]
#[doc = " is disabled."]
#[doc = ""]
#[doc = " When the application waits for an application event by calling this function, an interrupt that"]
#[doc = " is enabled will be taken immediately on pending since this function will wait in thread mode,"]
#[doc = " then the execution will return in the application's main thread."]
#[doc = ""]
#[doc = " In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M"]
#[doc = " MCU's System Control Register (SCR), CMSIS_SCB. In that case, when a disabled interrupt gets"]
#[doc = " pended, this function will return to the application's main thread."]
#[doc = ""]
#[doc = " @note The application must ensure that the pended flag is cleared using ::sd_nvic_ClearPendingIRQ"]
#[doc = "       in order to sleep using this function. This is only necessary for disabled interrupts, as"]
#[doc = "       the interrupt handler will clear the pending flag automatically for enabled interrupts."]
#[doc = ""]
#[doc = " @note If an application interrupt has happened since the last time sd_app_evt_wait was"]
#[doc = "       called this function will return immediately and not go to sleep. This is to avoid race"]
#[doc = "       conditions that can occur when a flag is updated in the interrupt handler and processed"]
#[doc = "       in the main loop."]
#[doc = ""]
#[doc = " @post An application interrupt has happened or a interrupt pending flag is set."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_app_evt_wait() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 65",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get PPI channel enable register contents."]
#[doc = ""]
#[doc = " @param[out] p_channel_enable The contents of the PPI CHEN register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_enable_get(p_channel_enable: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 32",
        inout("r0") to_asm(p_channel_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set PPI channel enable register."]
#[doc = ""]
#[doc = " @param[in] channel_enable_set_msk Mask containing the bits to set in the PPI CHEN register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_enable_set(channel_enable_set_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 33",
        inout("r0") to_asm(channel_enable_set_msk) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Clear PPI channel enable register."]
#[doc = ""]
#[doc = " @param[in] channel_enable_clr_msk Mask containing the bits to clear in the PPI CHEN register."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_enable_clr(channel_enable_clr_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 34",
        inout("r0") to_asm(channel_enable_clr_msk) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Assign endpoints to a PPI channel."]
#[doc = ""]
#[doc = " @param[in] channel_num Number of the PPI channel to assign."]
#[doc = " @param[in] evt_endpoint Event endpoint of the PPI channel."]
#[doc = " @param[in] task_endpoint Task endpoint of the PPI channel."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_SOC_PPI_INVALID_CHANNEL The channel number is invalid."]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_assign(
    channel_num: u8,
    evt_endpoint: *const self::c_void,
    task_endpoint: *const self::c_void,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 35",
        inout("r0") to_asm(channel_num) => ret,
        inout("r1") to_asm(evt_endpoint) => _,
        inout("r2") to_asm(task_endpoint) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Task to enable a channel group."]
#[doc = ""]
#[doc = " @param[in] group_num Number of the channel group."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid"]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_task_enable(group_num: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 36",
        inout("r0") to_asm(group_num) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Task to disable a channel group."]
#[doc = ""]
#[doc = " @param[in] group_num Number of the PPI group."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid."]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_task_disable(group_num: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 37",
        inout("r0") to_asm(group_num) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Assign PPI channels to a channel group."]
#[doc = ""]
#[doc = " @param[in] group_num Number of the channel group."]
#[doc = " @param[in] channel_msk Mask of the channels to assign to the group."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid."]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_assign(group_num: u8, channel_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 38",
        inout("r0") to_asm(group_num) => ret,
        inout("r1") to_asm(channel_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Gets the PPI channels of a channel group."]
#[doc = ""]
#[doc = " @param[in]   group_num Number of the channel group."]
#[doc = " @param[out]  p_channel_msk Mask of the channels assigned to the group."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid."]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_get(group_num: u8, p_channel_msk: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 39",
        inout("r0") to_asm(group_num) => ret,
        inout("r1") to_asm(p_channel_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Configures the Radio Notification signal."]
#[doc = ""]
#[doc = " @note"]
#[doc = "      - The notification signal latency depends on the interrupt priority settings of SWI used"]
#[doc = "        for notification signal."]
#[doc = "      - To ensure that the radio notification signal behaves in a consistent way, the radio"]
#[doc = "        notifications must be configured when there is no protocol stack or other SoftDevice"]
#[doc = "        activity in progress. It is recommended that the radio notification signal is"]
#[doc = "        configured directly after the SoftDevice has been enabled."]
#[doc = "      - In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice"]
#[doc = "        will interrupt the application to do Radio Event preparation."]
#[doc = "      - Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have"]
#[doc = "        to shorten the connection events to have time for the Radio Notification signals."]
#[doc = ""]
#[doc = " @param[in]  type      Type of notification signal, see @ref NRF_RADIO_NOTIFICATION_TYPES."]
#[doc = "                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE shall be used to turn off radio"]
#[doc = "                       notification. Using @ref NRF_RADIO_NOTIFICATION_DISTANCE_NONE is"]
#[doc = "                       recommended (but not required) to be used with"]
#[doc = "                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE."]
#[doc = ""]
#[doc = " @param[in]  distance  Distance between the notification signal and start of radio activity, see @ref NRF_RADIO_NOTIFICATION_DISTANCES."]
#[doc = "                       This parameter is ignored when @ref NRF_RADIO_NOTIFICATION_TYPE_NONE or"]
#[doc = "                       @ref NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE is used."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM The group number is invalid."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE A protocol stack or other SoftDevice is running. Stop all"]
#[doc = "                                   running activities and retry."]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_radio_notification_cfg_set(type_: u8, distance: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 69",
        inout("r0") to_asm(type_) => ret,
        inout("r1") to_asm(distance) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Encrypts a block according to the specified parameters."]
#[doc = ""]
#[doc = " 128-bit AES encryption."]
#[doc = ""]
#[doc = " @note:"]
#[doc = "    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while"]
#[doc = "      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application"]
#[doc = "      main or low interrupt level."]
#[doc = ""]
#[doc = " @param[in, out] p_ecb_data Pointer to the ECB parameters' struct (two input"]
#[doc = "                            parameters and one output parameter)."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ecb_block_encrypt(p_ecb_data: *mut nrf_ecb_hal_data_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 70",
        inout("r0") to_asm(p_ecb_data) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Encrypts multiple data blocks provided as an array of data block structures."]
#[doc = ""]
#[doc = " @details: Performs 128-bit AES encryption on multiple data blocks"]
#[doc = ""]
#[doc = " @note:"]
#[doc = "    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while"]
#[doc = "      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application"]
#[doc = "      main or low interrupt level."]
#[doc = ""]
#[doc = " @param[in]     block_count     Count of blocks in the p_data_blocks array."]
#[doc = " @param[in,out] p_data_blocks   Pointer to the first entry in a contiguous array of"]
#[doc = "                                @ref nrf_ecb_hal_data_block_t structures."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ecb_blocks_encrypt(block_count: u8, p_data_blocks: *mut nrf_ecb_hal_data_block_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 71",
        inout("r0") to_asm(block_count) => ret,
        inout("r1") to_asm(p_data_blocks) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Gets any pending events generated by the SoC API."]
#[doc = ""]
#[doc = " The application should keep calling this function to get events, until ::NRF_ERROR_NOT_FOUND is returned."]
#[doc = ""]
#[doc = " @param[out] p_evt_id Set to one of the values in @ref NRF_SOC_EVTS, if any events are pending."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS An event was pending. The event id is written in the p_evt_id parameter."]
#[doc = " @retval ::NRF_ERROR_NOT_FOUND No pending events."]
#[inline(always)]
pub unsafe fn sd_evt_get(p_evt_id: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 75",
        inout("r0") to_asm(p_evt_id) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the temperature measured on the chip"]
#[doc = ""]
#[doc = " This function will block until the temperature measurement is done."]
#[doc = " It takes around 50 us from call to return."]
#[doc = ""]
#[doc = " @param[out] p_temp Result of temperature measurement. Die temperature in 0.25 degrees Celsius."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS A temperature measurement was done, and the temperature was written to temp"]
#[inline(always)]
pub unsafe fn sd_temp_get(p_temp: *mut i32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 76",
        inout("r0") to_asm(p_temp) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Flash Write"]
#[doc = ""]
#[doc = " Commands to write a buffer to flash"]
#[doc = ""]
#[doc = " If the SoftDevice is enabled:"]
#[doc = "  This call initiates the flash access command, and its completion will be communicated to the"]
#[doc = "  application with exactly one of the following events:"]
#[doc = "      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed."]
#[doc = "      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started."]
#[doc = ""]
#[doc = " If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the"]
#[doc = " write has been completed"]
#[doc = ""]
#[doc = " @note"]
#[doc = "      - This call takes control over the radio and the CPU during flash erase and write to make sure that"]
#[doc = "        they will not interfere with the flash access. This means that all interrupts will be blocked"]
#[doc = "        for a predictable time (depending on the NVMC specification in the device's Product Specification"]
#[doc = "        and the command parameters)."]
#[doc = "      - The data in the p_src buffer should not be modified before the @ref NRF_EVT_FLASH_OPERATION_SUCCESS"]
#[doc = "        or the @ref NRF_EVT_FLASH_OPERATION_ERROR have been received if the SoftDevice is enabled."]
#[doc = "      - This call will make the SoftDevice trigger a hardfault when the page is written, if it is"]
#[doc = "        protected."]
#[doc = ""]
#[doc = ""]
#[doc = " @param[in]  p_dst Pointer to start of flash location to be written."]
#[doc = " @param[in]  p_src Pointer to buffer with data to be written."]
#[doc = " @param[in]  size  Number of 32-bit words to write. Maximum size is the number of words in one"]
#[doc = "                   flash page. See the device's Product Specification for details."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR   Tried to write to a non existing flash address, or p_dst or p_src was unaligned."]
#[doc = " @retval ::NRF_ERROR_BUSY           The previous command has not yet completed."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN      Tried to write to an address outside the application flash area."]
#[doc = " @retval ::NRF_SUCCESS              The command was accepted."]
#[inline(always)]
pub unsafe fn sd_flash_write(p_dst: *mut u32, p_src: *const u32, size: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 41",
        inout("r0") to_asm(p_dst) => ret,
        inout("r1") to_asm(p_src) => _,
        inout("r2") to_asm(size) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Flash Erase page"]
#[doc = ""]
#[doc = " Commands to erase a flash page"]
#[doc = " If the SoftDevice is enabled:"]
#[doc = "  This call initiates the flash access command, and its completion will be communicated to the"]
#[doc = "  application with exactly one of the following events:"]
#[doc = "      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed."]
#[doc = "      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started."]
#[doc = ""]
#[doc = " If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the"]
#[doc = " erase has been completed"]
#[doc = ""]
#[doc = " @note"]
#[doc = "      - This call takes control over the radio and the CPU during flash erase and write to make sure that"]
#[doc = "        they will not interfere with the flash access. This means that all interrupts will be blocked"]
#[doc = "        for a predictable time (depending on the NVMC specification in the device's Product Specification"]
#[doc = "        and the command parameters)."]
#[doc = "      - This call will make the SoftDevice trigger a hardfault when the page is erased, if it is"]
#[doc = "        protected."]
#[doc = ""]
#[doc = ""]
#[doc = " @param[in]  page_number           Page number of the page to erase"]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INTERNAL      If a new session could not be opened due to an internal error."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page."]
#[doc = " @retval ::NRF_ERROR_BUSY          The previous command has not yet completed."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a page outside the application flash area."]
#[doc = " @retval ::NRF_SUCCESS             The command was accepted."]
#[inline(always)]
pub unsafe fn sd_flash_page_erase(page_number: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 40",
        inout("r0") to_asm(page_number) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Opens a session for radio timeslot requests."]
#[doc = ""]
#[doc = " @note Only one session can be open at a time."]
#[doc = " @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) will be called when the radio timeslot"]
#[doc = "       starts. From this point the NRF_RADIO and NRF_TIMER0 peripherals can be freely accessed"]
#[doc = "       by the application."]
#[doc = " @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0) is called whenever the NRF_TIMER0"]
#[doc = "       interrupt occurs."]
#[doc = " @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO) is called whenever the NRF_RADIO"]
#[doc = "       interrupt occurs."]
#[doc = " @note p_radio_signal_callback() will be called at ARM interrupt priority level 0. This"]
#[doc = "       implies that none of the sd_* API calls can be used from p_radio_signal_callback()."]
#[doc = ""]
#[doc = " @param[in] p_radio_signal_callback The signal callback."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR p_radio_signal_callback is an invalid function pointer."]
#[doc = " @retval ::NRF_ERROR_BUSY If session cannot be opened."]
#[doc = " @retval ::NRF_ERROR_INTERNAL If a new session could not be opened due to an internal error."]
#[doc = " @retval ::NRF_SUCCESS Otherwise."]
#[inline(always)]
pub unsafe fn sd_radio_session_open(p_radio_signal_callback: nrf_radio_signal_callback_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 72",
        inout("r0") to_asm(p_radio_signal_callback) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Closes a session for radio timeslot requests."]
#[doc = ""]
#[doc = " @note Any current radio timeslot will be finished before the session is closed."]
#[doc = " @note If a radio timeslot is scheduled when the session is closed, it will be canceled."]
#[doc = " @note The application cannot consider the session closed until the @ref NRF_EVT_RADIO_SESSION_CLOSED"]
#[doc = "       event is received."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN If session not opened."]
#[doc = " @retval ::NRF_ERROR_BUSY If session is currently being closed."]
#[doc = " @retval ::NRF_SUCCESS Otherwise."]
#[inline(always)]
pub unsafe fn sd_radio_session_close() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 73",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Requests a radio timeslot."]
#[doc = ""]
#[doc = " @note The request type is determined by p_request->request_type, and can be one of @ref NRF_RADIO_REQ_TYPE_EARLIEST"]
#[doc = "       and @ref NRF_RADIO_REQ_TYPE_NORMAL. The first request in a session must always be of type @ref NRF_RADIO_REQ_TYPE_EARLIEST."]
#[doc = " @note For a normal request (@ref NRF_RADIO_REQ_TYPE_NORMAL), the start time of a radio timeslot is specified by"]
#[doc = "       p_request->distance_us and is given relative to the start of the previous timeslot."]
#[doc = " @note A too small p_request->distance_us will lead to a @ref NRF_EVT_RADIO_BLOCKED event."]
#[doc = " @note Timeslots scheduled too close will lead to a @ref NRF_EVT_RADIO_BLOCKED event."]
#[doc = " @note See the SoftDevice Specification for more on radio timeslot scheduling, distances and lengths."]
#[doc = " @note If an opportunity for the first radio timeslot is not found before 100 ms after the call to this"]
#[doc = "       function, it is not scheduled, and instead a @ref NRF_EVT_RADIO_BLOCKED event is sent."]
#[doc = "       The application may then try to schedule the first radio timeslot again."]
#[doc = " @note Successful requests will result in nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START)."]
#[doc = "       Unsuccessful requests will result in a @ref NRF_EVT_RADIO_BLOCKED event, see @ref NRF_SOC_EVTS."]
#[doc = " @note The jitter in the start time of the radio timeslots is +/- @ref NRF_RADIO_START_JITTER_US us."]
#[doc = " @note The nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) call has a latency relative to the"]
#[doc = "       specified radio timeslot start, but this does not affect the actual start time of the timeslot."]
#[doc = " @note NRF_TIMER0 is reset at the start of the radio timeslot, and is clocked at 1MHz from the high frequency"]
#[doc = "       (16 MHz) clock source. If p_request->hfclk_force_xtal is true, the high frequency clock is"]
#[doc = "       guaranteed to be clocked from the external crystal."]
#[doc = " @note The SoftDevice will neither access the NRF_RADIO peripheral nor the NRF_TIMER0 peripheral"]
#[doc = "       during the radio timeslot."]
#[doc = ""]
#[doc = " @param[in] p_request Pointer to the request parameters."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN Either:"]
#[doc = "                                - The session is not open."]
#[doc = "                                - The session is not IDLE."]
#[doc = "                                - This is the first request and its type is not @ref NRF_RADIO_REQ_TYPE_EARLIEST."]
#[doc = "                                - The request type was set to @ref NRF_RADIO_REQ_TYPE_NORMAL after a"]
#[doc = "                                  @ref NRF_RADIO_REQ_TYPE_EARLIEST request was blocked."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR If the p_request pointer is invalid."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM If the parameters of p_request are not valid."]
#[doc = " @retval ::NRF_SUCCESS Otherwise."]
#[inline(always)]
pub unsafe fn sd_radio_request(p_request: *const nrf_radio_request_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 74",
        inout("r0") to_asm(p_request) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Write register protected by the SoftDevice"]
#[doc = ""]
#[doc = " This function writes to a register that is write-protected by the SoftDevice. Please refer to your"]
#[doc = " SoftDevice Specification for more details about which registers that are protected by SoftDevice."]
#[doc = " This function can write to the following protected peripheral:"]
#[doc = "  - ACL"]
#[doc = ""]
#[doc = " @note Protected registers may be read directly."]
#[doc = " @note Register that are write-once will return @ref NRF_SUCCESS on second set, even the value in"]
#[doc = "       the register has not changed. See the Product Specification for more details about register"]
#[doc = "       properties."]
#[doc = ""]
#[doc = " @param[in]  p_register Pointer to register to be written."]
#[doc = " @param[in]  value Value to be written to the register."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR This function can not write to the reguested register."]
#[doc = " @retval ::NRF_SUCCESS Value successfully written to register."]
#[doc = ""]
#[inline(always)]
pub unsafe fn sd_protected_register_write(p_register: *mut u32, value: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 43",
        inout("r0") to_asm(p_register) => ret,
        inout("r1") to_asm(value) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< ::sd_mbr_command"]
pub const NRF_MBR_SVCS_SD_MBR_COMMAND: NRF_MBR_SVCS = 24;
#[doc = "@brief nRF Master Boot Record API SVC numbers."]
pub type NRF_MBR_SVCS = self::c_uint;
#[doc = "< Copy a new BootLoader. @see ::sd_mbr_command_copy_bl_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_COPY_BL: NRF_MBR_COMMANDS = 0;
#[doc = "< Copy a new SoftDevice. @see ::sd_mbr_command_copy_sd_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_COPY_SD: NRF_MBR_COMMANDS = 1;
#[doc = "< Initialize forwarding interrupts to SD, and run reset function in SD. Does not require any parameters in ::sd_mbr_command_t params."]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_INIT_SD: NRF_MBR_COMMANDS = 2;
#[doc = "< This command works like memcmp. @see ::sd_mbr_command_compare_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_COMPARE: NRF_MBR_COMMANDS = 3;
#[doc = "< Change the address the MBR starts after a reset. @see ::sd_mbr_command_vector_table_base_set_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_VECTOR_TABLE_BASE_SET: NRF_MBR_COMMANDS = 4;
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_RESERVED: NRF_MBR_COMMANDS = 5;
#[doc = "< Start forwarding all interrupts to this address. @see ::sd_mbr_command_irq_forward_address_set_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_IRQ_FORWARD_ADDRESS_SET: NRF_MBR_COMMANDS = 6;
#[doc = "@brief Possible values for ::sd_mbr_command_t.command"]
pub type NRF_MBR_COMMANDS = self::c_uint;
#[doc = "@brief This command copies part of a new SoftDevice"]
#[doc = ""]
#[doc = " The destination area is erased before copying."]
#[doc = " If dst is in the middle of a flash page, that whole flash page will be erased."]
#[doc = " If (dst+len) is in the middle of a flash page, that whole flash page will be erased."]
#[doc = ""]
#[doc = " The user of this function is responsible for setting the BPROT registers."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS indicates that the contents of the memory blocks where copied correctly."]
#[doc = " @retval ::NRF_ERROR_INTERNAL indicates that the contents of the memory blocks where not verified correctly after copying."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_copy_sd_t {
    #[doc = "< Pointer to the source of data to be copied."]
    pub src: *mut u32,
    #[doc = "< Pointer to the destination where the content is to be copied."]
    pub dst: *mut u32,
    #[doc = "< Number of 32 bit words to copy. Must be a multiple of @ref MBR_PAGE_SIZE_IN_WORDS words."]
    pub len: u32,
}
#[test]
fn bindgen_test_layout_sd_mbr_command_copy_sd_t() {
    assert_eq!(
        ::core::mem::size_of::<sd_mbr_command_copy_sd_t>(),
        12usize,
        concat!("Size of: ", stringify!(sd_mbr_command_copy_sd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sd_mbr_command_copy_sd_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sd_mbr_command_copy_sd_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_copy_sd_t>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_copy_sd_t),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_copy_sd_t>())).dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_copy_sd_t),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_copy_sd_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_copy_sd_t),
            "::",
            stringify!(len)
        )
    );
}
#[doc = "@brief This command works like memcmp, but takes the length in words."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS indicates that the contents of both memory blocks are equal."]
#[doc = " @retval ::NRF_ERROR_NULL indicates that the contents of the memory blocks are not equal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_compare_t {
    #[doc = "< Pointer to block of memory."]
    pub ptr1: *mut u32,
    #[doc = "< Pointer to block of memory."]
    pub ptr2: *mut u32,
    #[doc = "< Number of 32 bit words to compare."]
    pub len: u32,
}
#[test]
fn bindgen_test_layout_sd_mbr_command_compare_t() {
    assert_eq!(
        ::core::mem::size_of::<sd_mbr_command_compare_t>(),
        12usize,
        concat!("Size of: ", stringify!(sd_mbr_command_compare_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sd_mbr_command_compare_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sd_mbr_command_compare_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_compare_t>())).ptr1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_compare_t),
            "::",
            stringify!(ptr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_compare_t>())).ptr2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_compare_t),
            "::",
            stringify!(ptr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_compare_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_compare_t),
            "::",
            stringify!(len)
        )
    );
}
#[doc = "@brief This command copies a new BootLoader."]
#[doc = ""]
#[doc = " The MBR assumes that either @ref MBR_BOOTLOADER_ADDR or @ref MBR_UICR_BOOTLOADER_ADDR is set to"]
#[doc = " the address where the bootloader will be copied. If both addresses are set, the MBR will prioritize"]
#[doc = " @ref MBR_BOOTLOADER_ADDR."]
#[doc = ""]
#[doc = " The bootloader destination is erased by this function."]
#[doc = " If (destination+bl_len) is in the middle of a flash page, that whole flash page will be erased."]
#[doc = ""]
#[doc = " This command requires that @ref MBR_PARAM_PAGE_ADDR or @ref MBR_UICR_PARAM_PAGE_ADDR is set,"]
#[doc = " see @ref sd_mbr_command."]
#[doc = ""]
#[doc = " This command will use the flash protect peripheral (BPROT or ACL) to protect the flash that is"]
#[doc = " not intended to be written."]
#[doc = ""]
#[doc = " On success, this function will not return. It will start the new bootloader from reset-vector as normal."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INTERNAL indicates an internal error that should not happen."]
#[doc = " @retval ::NRF_ERROR_FORBIDDEN if the bootloader address is not set."]
#[doc = " @retval ::NRF_ERROR_INVALID_LENGTH if parameters attempts to read or write outside flash area."]
#[doc = " @retval ::NRF_ERROR_NO_MEM No MBR parameter page is provided. See @ref sd_mbr_command."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_copy_bl_t {
    #[doc = "< Pointer to the source of the bootloader to be be copied."]
    pub bl_src: *mut u32,
    #[doc = "< Number of 32 bit words to copy for BootLoader."]
    pub bl_len: u32,
}
#[test]
fn bindgen_test_layout_sd_mbr_command_copy_bl_t() {
    assert_eq!(
        ::core::mem::size_of::<sd_mbr_command_copy_bl_t>(),
        8usize,
        concat!("Size of: ", stringify!(sd_mbr_command_copy_bl_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sd_mbr_command_copy_bl_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sd_mbr_command_copy_bl_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_copy_bl_t>())).bl_src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_copy_bl_t),
            "::",
            stringify!(bl_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_copy_bl_t>())).bl_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_copy_bl_t),
            "::",
            stringify!(bl_len)
        )
    );
}
#[doc = "@brief Change the address the MBR starts after a reset"]
#[doc = ""]
#[doc = " Once this function has been called, this address is where the MBR will start to forward"]
#[doc = " interrupts to after a reset."]
#[doc = ""]
#[doc = " To restore default forwarding, this function should be called with @ref address set to 0. If a"]
#[doc = " bootloader is present, interrupts will be forwarded to the bootloader. If not, interrupts will"]
#[doc = " be forwarded to the SoftDevice."]
#[doc = ""]
#[doc = " The location of a bootloader can be specified in @ref MBR_BOOTLOADER_ADDR or"]
#[doc = " @ref MBR_UICR_BOOTLOADER_ADDR. If both addresses are set, the MBR will prioritize"]
#[doc = " @ref MBR_BOOTLOADER_ADDR."]
#[doc = ""]
#[doc = " This command requires that @ref MBR_PARAM_PAGE_ADDR or @ref MBR_UICR_PARAM_PAGE_ADDR is set,"]
#[doc = " see @ref sd_mbr_command."]
#[doc = ""]
#[doc = " On success, this function will not return. It will reset the device."]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_INTERNAL indicates an internal error that should not happen."]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR if parameter address is outside of the flash size."]
#[doc = " @retval ::NRF_ERROR_NO_MEM No MBR parameter page is provided. See @ref sd_mbr_command."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_vector_table_base_set_t {
    #[doc = "< The base address of the interrupt vector table for forwarded interrupts."]
    pub address: u32,
}
#[test]
fn bindgen_test_layout_sd_mbr_command_vector_table_base_set_t() {
    assert_eq!(
        ::core::mem::size_of::<sd_mbr_command_vector_table_base_set_t>(),
        4usize,
        concat!("Size of: ", stringify!(sd_mbr_command_vector_table_base_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sd_mbr_command_vector_table_base_set_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sd_mbr_command_vector_table_base_set_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_vector_table_base_set_t>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_vector_table_base_set_t),
            "::",
            stringify!(address)
        )
    );
}
#[doc = "@brief Sets the base address of the interrupt vector table for interrupts forwarded from the MBR"]
#[doc = ""]
#[doc = " Unlike sd_mbr_command_vector_table_base_set_t, this function does not reset, and it does not"]
#[doc = " change where the MBR starts after reset."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_irq_forward_address_set_t {
    #[doc = "< The base address of the interrupt vector table for forwarded interrupts."]
    pub address: u32,
}
#[test]
fn bindgen_test_layout_sd_mbr_command_irq_forward_address_set_t() {
    assert_eq!(
        ::core::mem::size_of::<sd_mbr_command_irq_forward_address_set_t>(),
        4usize,
        concat!("Size of: ", stringify!(sd_mbr_command_irq_forward_address_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sd_mbr_command_irq_forward_address_set_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sd_mbr_command_irq_forward_address_set_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_irq_forward_address_set_t>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_irq_forward_address_set_t),
            "::",
            stringify!(address)
        )
    );
}
#[doc = "@brief Input structure containing data used when calling ::sd_mbr_command"]
#[doc = ""]
#[doc = " Depending on what command value that is set, the corresponding params value type must also be"]
#[doc = " set. See @ref NRF_MBR_COMMANDS for command types and corresponding params value type. If command"]
#[doc = " @ref SD_MBR_COMMAND_INIT_SD is set, it is not necessary to set any values under params."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_mbr_command_t {
    #[doc = "< Type of command to be issued. See @ref NRF_MBR_COMMANDS."]
    pub command: u32,
    #[doc = "< Command parameters."]
    pub params: sd_mbr_command_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sd_mbr_command_t__bindgen_ty_1 {
    #[doc = "< Parameters for copy SoftDevice."]
    pub copy_sd: sd_mbr_command_copy_sd_t,
    #[doc = "< Parameters for verify."]
    pub compare: sd_mbr_command_compare_t,
    #[doc = "< Parameters for copy BootLoader. Requires parameter page."]
    pub copy_bl: sd_mbr_command_copy_bl_t,
    #[doc = "< Parameters for vector table base set. Requires parameter page."]
    pub base_set: sd_mbr_command_vector_table_base_set_t,
    #[doc = "< Parameters for irq forward address set"]
    pub irq_forward_address_set: sd_mbr_command_irq_forward_address_set_t,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_sd_mbr_command_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sd_mbr_command_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(sd_mbr_command_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sd_mbr_command_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sd_mbr_command_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_t__bindgen_ty_1>())).copy_sd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_t__bindgen_ty_1),
            "::",
            stringify!(copy_sd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_t__bindgen_ty_1>())).compare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_t__bindgen_ty_1),
            "::",
            stringify!(compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_t__bindgen_ty_1>())).copy_bl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_t__bindgen_ty_1),
            "::",
            stringify!(copy_bl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_t__bindgen_ty_1>())).base_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_t__bindgen_ty_1),
            "::",
            stringify!(base_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sd_mbr_command_t__bindgen_ty_1>())).irq_forward_address_set as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_t__bindgen_ty_1),
            "::",
            stringify!(irq_forward_address_set)
        )
    );
}
#[test]
fn bindgen_test_layout_sd_mbr_command_t() {
    assert_eq!(
        ::core::mem::size_of::<sd_mbr_command_t>(),
        16usize,
        concat!("Size of: ", stringify!(sd_mbr_command_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sd_mbr_command_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sd_mbr_command_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_t>())).command as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_t),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sd_mbr_command_t>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sd_mbr_command_t),
            "::",
            stringify!(params)
        )
    );
}

#[doc = "@brief Issue Master Boot Record commands"]
#[doc = ""]
#[doc = " Commands used when updating a SoftDevice and bootloader."]
#[doc = ""]
#[doc = " The @ref SD_MBR_COMMAND_COPY_BL and @ref SD_MBR_COMMAND_VECTOR_TABLE_BASE_SET requires"]
#[doc = " parameters to be retained by the MBR when resetting the IC. This is done in a separate flash"]
#[doc = " page. The location of the flash page should be provided by the application in either"]
#[doc = " @ref MBR_PARAM_PAGE_ADDR or @ref MBR_UICR_PARAM_PAGE_ADDR. If both addresses are set, the MBR"]
#[doc = " will prioritize @ref MBR_PARAM_PAGE_ADDR. This page will be cleared by the MBR and is used to"]
#[doc = " store the command before reset. When an address is specified, the page it refers to must not be"]
#[doc = " used by the application. If no address is provided by the application, i.e. both"]
#[doc = " @ref MBR_PARAM_PAGE_ADDR and @ref MBR_UICR_PARAM_PAGE_ADDR is 0xFFFFFFFF, MBR commands which use"]
#[doc = " flash will be unavailable and return @ref NRF_ERROR_NO_MEM."]
#[doc = ""]
#[doc = " @param[in]  param Pointer to a struct describing the command."]
#[doc = ""]
#[doc = " @note For a complete set of return values, see ::sd_mbr_command_copy_sd_t,"]
#[doc = "       ::sd_mbr_command_copy_bl_t, ::sd_mbr_command_compare_t,"]
#[doc = "       ::sd_mbr_command_vector_table_base_set_t, ::sd_mbr_command_irq_forward_address_set_t"]
#[doc = ""]
#[doc = " @retval ::NRF_ERROR_NO_MEM No MBR parameter page provided"]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM if an invalid command is given."]
#[inline(always)]
pub unsafe fn sd_mbr_command(param: *mut sd_mbr_command_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 24",
        inout("r0") to_asm(param) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< ::sd_softdevice_enable"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_ENABLE: NRF_SD_SVCS = 16;
#[doc = "< ::sd_softdevice_disable"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_DISABLE: NRF_SD_SVCS = 17;
#[doc = "< ::sd_softdevice_is_enabled"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_IS_ENABLED: NRF_SD_SVCS = 18;
#[doc = "< ::sd_softdevice_vector_table_base_set"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET: NRF_SD_SVCS = 19;
#[doc = "< Placeholder for last SDM SVC"]
pub const NRF_SD_SVCS_SVC_SDM_LAST: NRF_SD_SVCS = 20;
#[doc = "@brief nRF SoftDevice Manager API SVC numbers."]
pub type NRF_SD_SVCS = self::c_uint;
#[doc = "@brief Type representing LFCLK oscillator source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_clock_lf_cfg_t {
    #[doc = "< LF oscillator clock source, see @ref NRF_CLOCK_LF_SRC."]
    pub source: u8,
    #[doc = "< Only for ::NRF_CLOCK_LF_SRC_RC: Calibration timer interval in 1/4 second"]
    #[doc = "units (nRF52: 1-32)."]
    #[doc = "@note To avoid excessive clock drift, 0.5 degrees Celsius is the"]
    #[doc = "maximum temperature change allowed in one calibration timer"]
    #[doc = "interval. The interval should be selected to ensure this."]
    #[doc = ""]
    #[doc = "@note Must be 0 if source is not ::NRF_CLOCK_LF_SRC_RC."]
    pub rc_ctiv: u8,
    #[doc = "<  Only for ::NRF_CLOCK_LF_SRC_RC: How often (in number of calibration"]
    #[doc = "intervals) the RC oscillator shall be calibrated if the temperature"]
    #[doc = "hasn't changed."]
    #[doc = "0: Always calibrate even if the temperature hasn't changed."]
    #[doc = "1: Only calibrate if the temperature has changed (legacy - nRF51 only)."]
    #[doc = "2-33: Check the temperature and only calibrate if it has changed,"]
    #[doc = "however calibration will take place every rc_temp_ctiv"]
    #[doc = "intervals in any case."]
    #[doc = ""]
    #[doc = "@note Must be 0 if source is not ::NRF_CLOCK_LF_SRC_RC."]
    #[doc = ""]
    #[doc = "@note For nRF52, the application must ensure calibration at least once"]
    #[doc = "every 8 seconds to ensure +/-500 ppm clock stability. The"]
    #[doc = "recommended configuration for ::NRF_CLOCK_LF_SRC_RC on nRF52 is"]
    #[doc = "rc_ctiv=16 and rc_temp_ctiv=2. This will ensure calibration at"]
    #[doc = "least once every 8 seconds and for temperature changes of 0.5"]
    #[doc = "degrees Celsius every 4 seconds. See the Product Specification"]
    #[doc = "for the nRF52 device being used for more information."]
    pub rc_temp_ctiv: u8,
    #[doc = "< External clock accuracy used in the LL to compute timing"]
    #[doc = "windows, see @ref NRF_CLOCK_LF_ACCURACY."]
    pub accuracy: u8,
}
#[test]
fn bindgen_test_layout_nrf_clock_lf_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<nrf_clock_lf_cfg_t>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_clock_lf_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_clock_lf_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_clock_lf_cfg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_clock_lf_cfg_t>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_clock_lf_cfg_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_clock_lf_cfg_t>())).rc_ctiv as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_clock_lf_cfg_t),
            "::",
            stringify!(rc_ctiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_clock_lf_cfg_t>())).rc_temp_ctiv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_clock_lf_cfg_t),
            "::",
            stringify!(rc_temp_ctiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nrf_clock_lf_cfg_t>())).accuracy as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_clock_lf_cfg_t),
            "::",
            stringify!(accuracy)
        )
    );
}
#[doc = "@brief Fault Handler type."]
#[doc = ""]
#[doc = " When certain unrecoverable errors occur within the application or SoftDevice the fault handler will be called back."]
#[doc = " The protocol stack will be in an undefined state when this happens and the only way to recover will be to"]
#[doc = " perform a reset, using e.g. CMSIS NVIC_SystemReset()."]
#[doc = " If the application returns from the fault handler the SoftDevice will call NVIC_SystemReset()."]
#[doc = ""]
#[doc = " @note It is recommended to either perform a reset in the fault handler or to let the SoftDevice reset the device."]
#[doc = "       Otherwise SoC peripherals may behave in an undefined way. For example, the RADIO peripherial may"]
#[doc = "       continously transmit packets."]
#[doc = ""]
#[doc = " @note This callback is executed in HardFault context, thus SVC functions cannot be called from the fault callback."]
#[doc = ""]
#[doc = " @param[in] id Fault identifier. See @ref NRF_FAULT_IDS."]
#[doc = " @param[in] pc The program counter of the instruction that triggered the fault."]
#[doc = " @param[in] info Optional additional information regarding the fault. Refer to each Fault identifier for details."]
#[doc = ""]
#[doc = " @note When id is set to @ref NRF_FAULT_ID_APP_MEMACC, pc will contain the address of the instruction being executed at the time when"]
#[doc = " the fault is detected by the CPU. The CPU program counter may have advanced up to 2 instructions (no branching) after the one that triggered the fault."]
pub type nrf_fault_handler_t = ::core::option::Option<unsafe extern "C" fn(id: u32, pc: u32, info: u32)>;

#[doc = "@brief Enables the SoftDevice and by extension the protocol stack."]
#[doc = ""]
#[doc = " @note Some care must be taken if a low frequency clock source is already running when calling this function:"]
#[doc = "       If the LF clock has a different source then the one currently running, it will be stopped. Then, the new"]
#[doc = "       clock source will be started."]
#[doc = ""]
#[doc = " @note This function has no effect when returning with an error."]
#[doc = ""]
#[doc = " @post If return code is ::NRF_SUCCESS"]
#[doc = "       - SoC library and protocol stack APIs are made available."]
#[doc = "       - A portion of RAM will be unavailable (see relevant SDS documentation)."]
#[doc = "       - Some peripherals will be unavailable or available only through the SoC API (see relevant SDS documentation)."]
#[doc = "       - Interrupts will not arrive from protected peripherals or interrupts."]
#[doc = "       - nrf_nvic_ functions must be used instead of CMSIS NVIC_ functions for reliable usage of the SoftDevice."]
#[doc = "       - Interrupt latency may be affected by the SoftDevice  (see relevant SDS documentation)."]
#[doc = "       - Chosen low frequency clock source will be running."]
#[doc = ""]
#[doc = " @param p_clock_lf_cfg Low frequency clock source and accuracy."]
#[doc = "If NULL the clock will be configured as an RC source with rc_ctiv = 16 and .rc_temp_ctiv = 2"]
#[doc = "In the case of XTAL source, the PPM accuracy of the chosen clock source must be greater than or equal to the actual characteristics of your XTAL clock."]
#[doc = " @param fault_handler Callback to be invoked in case of fault, cannot be NULL."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[doc = " @retval ::NRF_ERROR_INVALID_ADDR  Invalid or NULL pointer supplied."]
#[doc = " @retval ::NRF_ERROR_INVALID_STATE SoftDevice is already enabled, and the clock source and fault handler cannot be updated."]
#[doc = " @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDevice interrupt is already enabled, or an enabled interrupt has an illegal priority level."]
#[doc = " @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected."]
#[doc = " @retval ::NRF_ERROR_INVALID_PARAM Invalid clock source configuration supplied in p_clock_lf_cfg."]
#[inline(always)]
pub unsafe fn sd_softdevice_enable(
    p_clock_lf_cfg: *const nrf_clock_lf_cfg_t,
    fault_handler: nrf_fault_handler_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 16",
        inout("r0") to_asm(p_clock_lf_cfg) => ret,
        inout("r1") to_asm(fault_handler) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Disables the SoftDevice and by extension the protocol stack."]
#[doc = ""]
#[doc = " Idempotent function to disable the SoftDevice."]
#[doc = ""]
#[doc = " @post SoC library and protocol stack APIs are made unavailable."]
#[doc = " @post All interrupts that was protected by the SoftDevice will be disabled and initialized to priority 0 (highest)."]
#[doc = " @post All peripherals used by the SoftDevice will be reset to default values."]
#[doc = " @post All of RAM become available."]
#[doc = " @post All interrupts are forwarded to the application."]
#[doc = " @post LFCLK source chosen in ::sd_softdevice_enable will be left running."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_softdevice_disable() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 17",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Check if the SoftDevice is enabled."]
#[doc = ""]
#[doc = " @param[out]  p_softdevice_enabled If the SoftDevice is enabled: 1 else 0."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_softdevice_is_enabled(p_softdevice_enabled: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 18",
        inout("r0") to_asm(p_softdevice_enabled) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the base address of the interrupt vector table for interrupts forwarded from the SoftDevice"]
#[doc = ""]
#[doc = " This function is only intended to be called when a bootloader is enabled."]
#[doc = ""]
#[doc = " @param[in] address The base address of the interrupt vector table for forwarded interrupts."]
#[doc = ""]
#[doc = " @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_softdevice_vector_table_base_set(address: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 19",
        inout("r0") to_asm(address) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}
